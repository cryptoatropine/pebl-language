\chapter{Detailed Function and Keyword Reference}
\label{sec:reference}

\setlength{\parindent}{0pt}

\newcommand{\rl}{\rule{\textwidth}{0.3mm}}

%% \newenvironment{desc}[1]
%%  {\begin{list}{}%
%%   {\renewcommand\makelabel[1]{{##1:}\hfil}%
%%    \settowidth\labelwidth{\makelabel{#1}}%
%%    \setlength\leftmargin{\labelwidth+\labelsep}}}%
%%  {\end{list}}

%\newenvironment{desc}[1]
%  {\begin{minipage}[b]{\linewidth}
%   \rl%
%   \vspace{3pt}%
%   \begin{list}{}%
%   {\renewcommand\makelabel[1]{{##1:}\hfil}%
%    \settowidth\labelwidth{\makelabel{#1}}%
%    \setlength\leftmargin{\labelwidth+\labelsep}}}%
%  {\end{list}%
%   \vspace{1pt}%
%   \end{minipage}%
%   }
\newenvironment{desc}[1]
  {
     \rl%
   \vspace{3pt}%
   \begin{list}{}%
   {\renewcommand\makelabel[1]{{##1:}\hfil}%
    \settowidth\labelwidth{\makelabel{#1}}%
    \setlength\leftmargin{\labelwidth+\labelsep}}}%
  {\end{list}%
   \vspace{1pt}%
   }


\vfill
\sect{Symbols}
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb!+!

\item[Description] Adds two expressions together.  Also,
concatenates strings together.

\item[Usage]
\begin{verbatim}
<num1> + <num2>
<string1> + <string2>
<string1> + <num1>
\end{verbatim}
 Using other types of variables will cause errors.

\item[Example]
\begin{verbatim}
33 + 322                   --> 355
"Hello" + " " + "World"    --> "Hello World"
"Hello" + 33 + 322.5       --> "Hello355.5"
33 + 322.5 + "Hello"       --> "33322.5Hello"
\end{verbatim}

\item[See Also]     \verb!-!, \texttt{ToString()}
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+-+

\item[Description]  Subtracts one expression from another

\item[Usage]        \verb!<num1> - <num2>!

\item[Example]     

\item[See Also]

\end{desc}




\begin{desc}{Name/Symbol}

\item[Name/Symbol] \verb+/+ 

\item[Description]  Divides one expression by another

\item[Usage]        \verb+<expression> / <expression>+ 

\item[Example]
\begin{verbatim}
333 / 10    # == 33.3
\end{verbatim}

\item[See Also]

\end{desc} 



\begin{desc}{Name/Symbol}
   

\item[Name/Symbol] \verb+*+

\item[Description]        Multiplies two expressions together

\item[Usage]       \verb+<expression> * <expression>+

\item[Example]
\begin{verbatim}
32 * 2 # == 64
\end{verbatim}

\item[See Also]     

\end{desc}




\begin{desc}{Name/Symbol}

\item[Name/Symbol] \verb!^!

\item[Description]  Raises one expression to the power of  another expression

\item[Usage]       \verb!<expression> ^ <expression>!

\item[Example]
\begin{verbatim}
25 ^ 2  # == 625
\end{verbatim}

\item[See Also]    \texttt{Exp}, \texttt{NthRoot}

\end{desc}



\begin{desc}{Name/Symbol}

\item[Name/Symbol] \verb+;+ 

\item[Description]        Finishes a statement, can start new statement
                      on the same line (not needed at end of line)

\item[Usage]       

\item[Example]     

\item[See Also]

\end{desc}



\begin{desc}{Name/Symbol}     

\item[Name/Symbol] \verb!#!

\item[Description]   Comment indicator; anything until the next CR
	       following this character is ignored

\item[Usage]       

\item[Example]     

\item[See Also]

\end{desc} 



     
\begin{desc}{Name/Symbol}

\item[Name/Symbol] \verb!<-!                  

\item[Description]  The assignment operator.  Assigns a value to a variable\\
              N.B.: This two-character sequence takes the place of the
	      `\verb!=!' operator found in many programming languages.

\item[Usage]       

\item[Example]     

\item[See Also]  

\end{desc}   



\begin{desc}{Name/Symbol}

\item[Name/Symbol] \verb+( )+                  

\item[Description] Groups mathematical operations

\item[Usage]      \verb+(expression)+

\item[Example]
\begin{verbatim}
(3 + 22) * 4  # == 100
\end{verbatim}

\item[See Also]     

\end{desc}



\begin{desc}{Name/Symbol}

\item[Name/Symbol] \verb!{ }!                  

\item[Description] Groups a series of statements

\item[Usage]
\begin{verbatim}
{ statement1
  statement2
  statement3
}
\end{verbatim}
	     

\item[Example]     

\item[See Also]     
\end{desc}



\begin{desc}{Name/Symbol}

\item[Name/Symbol] \verb+[ ]+                 

\item[Description]  Creates a list. Closing \verb+]+ must be on
 	      same line as last element of list, even
	      for nested lists.

\item[Usage]       \verb+[<item1>, <item2>, ....]+
            

\item[Example]
\begin{verbatim}
[]                    #Creates an empty list
[1,2,3]               #Simple list
[[3,3,3],[2,2],0]     #creates a nested list structure
\end{verbatim}


\item[See Also]     \texttt{List()}
\end{desc}



\begin{desc}{Name/Symbol}

\item[Name/Symbol] 	\verb+<+ 

\item[Description] 	Less than.  Used to compare two numeric quantities.

\item[Usage]
\begin{verbatim}
3 < 5
3 < value
\end{verbatim}
             
\item[Example]
\begin{verbatim}
if(j < 33)
{
  Print ("j is less than 33.")
}
\end{verbatim}

See Also:     	\verb+>+, \verb+>=+, \verb+<=+, \verb+==+, \verb+~=+, \verb+!=+, \verb+<>+

\end{desc}





\begin{desc}{Name/Symbol}

\item[Name/Symbol] 	\verb!>!                    

\item[Description] 	Greater than. Used to compare two numeric quantities.

\item[Usage]
\begin{verbatim}
5 > 3
5 > value
\end{verbatim}

\item[Example]
\begin{verbatim}
if(j > 55)
{
 Print ("j is greater than 55.")
}
\end{verbatim}

\item[See Also]     	\verb+<+, \verb+>=+, \verb+<=+, \verb+==+, \verb+~=+, \verb+!=+, \verb+<>+
\end{desc}




\begin{desc}{Name/Symbol}

\item[Name/Symbol] 	\verb+<=+                   

\item[Description] 	Less than or equal to.

\item[Usage]
\begin{verbatim}
3<=5  
3<=value
\end{verbatim}

\item[Example]
\begin{verbatim}
if(j <= 33)
{
 Print ("j is less than or equal to 33.")
}
\end{verbatim}
	
\item[See Also]     	\verb+<, >, >=, ==, ~=, !=, <>+

\end{desc}



\begin{desc}{Name/Symbol}

\item[Name/Symbol] 	\verb+>=+                   

\item[Description] 	Greater than or equal to.

\item[Usage]
\begin{verbatim}
5>=3  
5>=value
\end{verbatim}

\item[Example]
\begin{verbatim}
if(j >= 55)
{
 Print ("j is greater than or equal to 55.")
}
\end{verbatim}

\item[See Also]     	\verb+<,+ \verb+>+, \verb+<=+, \verb+==+, \verb+~=+, \verb+!=+, \verb+<>+
\end{desc}



\begin{desc}{Name/Symbol}

\item[Name/Symbol] 	\verb+==+                   

\item[Description] 	Equal to.

\item[Usage]       	\verb+4 == 4+
		

\item[Example]
\begin{verbatim}
2 + 2 == 4
\end{verbatim}

\item[See Also]     	\verb+<,+ \verb+>+, \verb+>=+, \verb+<=+, \verb+~=+, \verb+!=+, \verb+<>+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+<>+, \verb+!=+, \verb+~=+

\item[Description]  	Not equal to.

\item[Usage]		

\item[Example]	

\item[See Also]     	\verb+<+, \verb+>+, \verb+>=+, \verb+<=+, \verb+==+

\end{desc}

\vfill
\newpage
\sect{A} 
\vfill

\begin{desc}{Name/Symbol}

\item[Name/Symbol] 	\verb+Abs()+

\item[Description]   	Returns the absolute value of the number.

\item[Usage]
\begin{verbatim}
Abs(<num>)
\end{verbatim}        

\item[Example]
\begin{verbatim}
Abs(-300)  	# ==300
Abs(23)    	# ==23
\end{verbatim}

\item[See Also]     	\verb+Round()+, \verb+Floor()+, \verb+AbsFloor()+, \verb+Sign()+, \verb+Ceiling()+
\end{desc}




\begin{desc}{Name/Symbol}

\item[Name/Symbol]  	\verb+AbsFloor()+

\item[Description]  	Rounds \verb+<num>+ toward 0 to an integer.

\item[Usage]       	
\begin{verbatim}
AbsFloor(<num>)
\end{verbatim}

\item[Example]
\begin{verbatim}
AbsFloor(-332.7)   	# == -332
AbsFloor(32.88)    	# == 32
\end{verbatim}

\item[See Also]     	\verb+Round()+, \verb+Floor()+, \verb+Abs()+, \verb+Sign()+, \verb+Ceiling()+
\end{desc}




\begin{desc}{Name/Symbol}

\item[Name/Symbol] 	\verb+ACos()+ 

\item[Description]  	Inverse cosine of \verb+<num>+, in degrees.

\item[Usage]
\begin{verbatim}
ACos(<num>)
\end{verbatim}

\item[Example]	

\item[See Also]    	\verb+Cos()+, \verb+Sin()+, \verb+Tan()+, \verb+ATan()+, \verb+ATan()+ 

\end{desc}


 


\begin{desc}{Name/Symbol}

\item[Name/Symbol]  	\verb+AddObject()+

\item[Description] 	Adds a widget to a parent window, at the top of the object stack.  Once added, the object will be drawn onto the parent last, meaning it will be on top of anything previously added. 

In general, objects can be added to other objects as well as windows.  For example, you can add drawing objects (circles, etc.) to an image to annotate the image and maintain its proper x,y coordinates.

Also, if you 're-add' an object that is already on a widget, it will get automatically removed from the window first.  This is an easy way to reorder elements on a screen.

\begin{verbatim}
AddObject(<obj>, <window>)
AddObject(<obj>, <canvas>)
AddObject(<obj>, <widget>)
\end{verbatim}

\item[Example]
\begin{verbatim}

define Start(p)
{
 win <- MakeWindow()
 img <- MakeImage("pebl.png")
 circ <- Circle(20,20,10,MakeColor("red"),1)
 AddObject(circ,img)
 AddObject(img,win)
 Move(img,100,100)
 Draw()
 WaitForAnyKeyPress()
}
\end{verbatim}



\item[See Also]    	\verb+RemoveObject()+
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+and+
  
\item[Description]  	Logical and operator.

\item[Usage]       	
\begin{verbatim}
<expression> and <expression>
\end{verbatim}

\item[Example]	

\item[See Also]     	\verb+or+, \verb+not+

\end{desc}




\begin{desc}{Name/Symbol}

\item[Name/Symbol]  	\verb+Append+
  
\item[Description]  	Appends an item to a list.  Useful for constructing lists in conjunction with the loop statement.

Note: \texttt{Append()} is useful, but inefficent for large data structures, because it requires making a copy of the entire data list and then overwriting it, if you use
\texttt{list <- Append(list, item)}.  The overhead will be hardly noticeable unless you are building lists hundreds of elements long.  In that case you shuold either create the list upfront and use \texttt{SetElement}, or you \texttt{PushOnEnd} to modify the list directly.

\item[Usage] 
\begin{verbatim}
Append(<list>, <item>)
\end{verbatim}

\item[Example]
\begin{verbatim}
list <- Sequence(1,5,1)
double  <- []
loop(i, list)
{
 double <- Append(double, [i,i])
}
Print(double)
# Produces [[1,1],[2,2],[3,3],[4,4],[5,5]]
\end{verbatim}

\item[See Also]  \verb+SetElement()+ \verb+List()+, \verb+[ ]+, \verb+Merge()+, \verb+PushOnEnd+
\end{desc}



\begin{desc}{Name/Symbol}

\item[Name/Symbol]  	\verb+AppendFile+
  
\item[Description]  	Appends onto the end of \verb+<file1>+ the contents of \verb+<file2>+.  Useful for compiling pooled data at the end of an experiment.

\item[Usage] 
\begin{verbatim}
AppendFile(<file1>, <file2>)
\end{verbatim}

\item[Example]:

The following open ten consecutive files, writes 50 random numbers to each, then appends each to a master file:

\begin{verbatim}

 loop(j, Sequence(1,10,1))
   {
    file <- FileOpenWrite(j+".txt")
   loop(i,Sequence(1,50,1))
    {
       FilePrint(file,j+","+i+","+Random())
    }
    AppendFile("master.txt",j+".txt")
  }
\end{verbatim}

\item[See Also]     	\verb+FileOpenWrite()+
\end{desc}






\begin{desc}{Name/Symbol}

\item[Name/Symbol]  	\verb+ASin()+ 

\item[Description]  	Inverse Sine of \verb+<num>+, in degrees.

\item[Usage]
\begin{verbatim}
ASin(<num>)
\end{verbatim}

\item[Example]	

\item[See Also]    	 \verb+Cos()+, \verb+Sin()+, \verb+Tan()+, \verb+ATan()+, \verb+ACos()+, \verb+ATan()+ 
\end{desc}





\begin{desc}{Name/Symbol}

\item[Name/Symbol]  	\verb+ATan+ 

\item[Description]  	Inverse Tan of \verb+<num>+, in degrees.

\item[Usage]		

\item[Example]	

\item[See Also]    	\verb+Cos()+, \verb+Sin()+, \verb+Tan()+, \verb+ATan()+, \verb+ACos()+, \verb+ATan()+ 
\end{desc}

\vfill
\newpage
\sect{B} 
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Bezier+ 

\item[Description] Creates a smoothed line through the  points
specified by \verb+<xpoints>+, \verb+<ypoints>+. The lists \verb+<xpoints>+ and
\verb+<ypoints>+ are adjusted by  \verb+<x>+ and \verb+<y>+, so they
should be relative to 0, not the location you want the points to be at.

Like other drawn objects, the bezier must then be added to the window
to appear. <steps> denotes how smooth the approximation will be.

\item[Usage]		
\begin{verbatim}
  Bezier(<x>,<y>,<xpoints>,<ypoints>,
         <steps>,<color>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  win <- MakeWindow()
   #This makes a T
   xpoints <- [-10,10,10,20,20,-20,-20,-10]
   ypoints <- [-20,-20,40,40,50,50,40,40]
  p1 <-    Bezier(100,100,xpoints, ypoints,
           5, MakeColor("black"))
  AddObject(p1,win)
  Draw()
\end{verbatim}

\item[See Also]   
\verb+BlockE()+, \verb+Polygon()+, \verb+MakeStarPoints()+,
\verb+MakeNGonPoints()+
\end{desc}




\begin{desc}{Name/Symbol}

\item[Name/Symbol]  	\verb+BlockE+ 

\item[Description] Creates a polygon in the shape of a
 block E, pointing in one of four directions.
Arguments include position in window.
\begin{itemize}
\item \verb+<x>+ and \verb+<y>+ is the position of the center
\item \verb+<h>+ and \verb+<w>+ or the size of the E in pixels
\item \verb+<thickness>+ thickness of the E
\item \verb+<direction>+ specifies which way the E points:  1=right,
  2=down, 3=left, 4=up.
\item \verb+<color>+ is a color object (not just the name)
\end{itemize}

Like other drawn objects, the Block E must then be added to the window
to appear.

\item[Usage]		
\begin{verbatim}
 BlockE(x,y,h,w,thickness,direction,color)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  win <- MakeWindow()
  e1 <- BlockE(100,100,40,80,10,1,MakeColor("black"))
  AddObject(e1,win)
  Draw()
\end{verbatim}

\item[See Also]   
\verb+Plus()+, \verb+Polygon()+, \verb+MakeStarPoints()+,
\verb+MakeNGonPoints()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+break+

\item[Description]  	Breaks out of a loop immediately.

\item[Usage]        	break

\item[Example]
\begin{verbatim}
loop(i ,[1,3,5,9,2,7])
{
 Print(i)
 if(i == 3) 
        {
         break
        }
}
\end{verbatim}

\item[See Also]   	\verb+loop+, \verb+return+
\end{desc}

\vfill
\newpage
\sect{C}
\vfill

\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Ceiling()+

\item[Description] 	Rounds \verb+<num>+ up to the next integer.

\item[Usage]
\begin{verbatim}
Ceiling(<num>)
\end{verbatim}

\item[Example] 
\begin{verbatim}
Ceiling(33.23)  	# == 34
Ceiling(-33.02) 	# == -33
\end{verbatim}

\item[See Also]     	\verb+Round()+, \verb+Floor()+, \verb+AbsFloor()+, \verb+Ceiling()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ChooseN()+

\item[Description] Samples \verb+<number>+ items from list, returning
  a list in the original order. Items are sampled without replacement, so
  once an item is chosen it will not be chosen again. If
  \verb+<number>+ is larger than the length of the list, the entire
  list is returned in order.  It differs from \verb+SampleN+ in that
  \verb+ChooseN+ returns items in the order they appeared in the
  originial list, but \verb+SampleN+ is shuffled. 

\item[Usage]       	
\begin{verbatim}
ChooseN(<list>, <n>)
\end{verbatim}

\item[Example]   	
\begin{verbatim}

# Returns 5 numbers
ChooseN([1,1,1,2,2], 5)     

# Returns 3 numbers from 1 and 7:
ChooseN([1,2,3,4,5,6,7], 3) 

\end{verbatim}

\item[See Also]    	\verb+SampleN()+, \verb+SampleNWithReplacement()+, \verb+Subset()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Circle()+

\item[Description] Creates a circle for graphing at x,y with radius r.
  Circles must be added to a parent widget before it can be drawn; it
  may be added to widgets other than a base window. The properties of
  circles may be changed by accessing their properties directly,
  including the FILLED property which makes the object an outline
  versus a filled shape.


\item[Usage]
\begin{verbatim}
Circle(<x>, <y>, <r>,<color>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  
  c <- Circle(30,30,20, MakeColor(green))
  AddObject(c, win)
  Draw()

\end{verbatim}
\item[See Also]	\verb+Square()+, \verb+Ellipse()+, \verb+Rectangle()+, \verb+Line()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+CheckForNetworkConnection()+

\item[Description] Checks to see if there is an incoming TCP/IP connection on a network that is opened using \verb+OpenNetworkListener+.  This is an alternative to the \verb+WaitForNetworkConnection+ function that allows more flexibility (and allows updating the during waiting for the connection).

\item[Usage]
\begin{verbatim}
net <- CheckForNetwokConnection(network)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  network <-      OpenNetworkListener(4444) 
  time <- GetTime()
  while(not connected and (GetTime() < time + 5000))
   {
      connected <- CheckForNetwokConnection(network) 
   }

\end{verbatim}
\item[See Also]	\verb+OpenNetworkListener()+, \verb+Getdata()+, \verb+WaitForNetworkConnection()+, \verb+CloseNetwork()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ClearEventLoop()+ 

\item[Description]  Clears the event loop.  This function is currently experimental, and its usage may change in future versions of PEBL.

\item[Usage]       	
\begin{verbatim}
USAGE CURRENTLY UNDOCUMENTED
\end{verbatim}

\item[Example]	

\item[See Also] 
\verb+RegisterEvent()+, \verb+StartEventLoop()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ClickCheckbox()+

\item[Description]	
This 'clicks' a checkbox, changing its status (both the visual display and its .status property).   Its state can also be set using the \texttt{SetCheckBox()} function. The text "ClickCheckBox" is by default bound to the .clickon property of any checkbox, enabling you to handle on a number of graphical object the same (see callfunction example).   The [x,y] coordinates are ignored, and so anything can be fed to them, but the standard approach is to use give gClick, which is a global bound to the last click coordinates when WaitForClickOnTarget is used.

\item[Usage]
\begin{verbatim}
 ClickCheckBox(obj, [x,y])
  \end{verbatim}

\item[Example]      	
The following creates a button, waits for you to click on it, and animates a button press


\begin{verbatim}
 ok <- MakeCheckbox("OK?",400,250,gWin,150)
 resp <- WaitForClickOnTarget([ok],[1])
 ClickCheckBox(done,gClick) 
 Draw()
\end{verbatim}

You can handle a bunch of objects together using an idiom like this:
\begin{verbatim}
 ok <- MakeCheckbox("OK?",400,250,gWin,150)
 ok2 <- MakeCheckbox("Otherwise?",400,280,gWin,150)

 checks  <- [ok,ok2]
 resp <- WaitForClickOnTarget(checks,[1,2])
  check <- Nth(checks,resp) 
 CallFunction(check.clickon,[check,gClick]) 
 Draw()
\end{verbatim}


Examples of its use can be found in demo\\ui.pbl
\item[See Also]	\verb+MakeCheckBox()+, \verb+SetCheckBox()+
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Clickon()+

\item[Description] Calls the function named by the  .clickon property of a custom object.  Useful for handling click events of a bunch of different objects. This is essentially the same as CallFunction(obj.clickon, [obj,gClick]).

\item[Usage]
\begin{verbatim}
Clickon(obj,[x,y])	
\end{verbatim}

\item[Example]	


\begin{verbatim}
  
   ##This overrides buttons placement at the center:  
   done <- MakeButton("QUIT",400,250,gWin,150)
   WaitForClickOnTarget([done],[1])
   Clickon(done,gClick)
    
\end{verbatim}

\item[See Also]	
\verb+Inside()+, \verb+ClickCheckbox+ \verb+MoveObject+, \verb+DrawObject+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ClickOnMenu()+

\item[Description]	
Handles clicking on a menu item. It will call the .clickon property of that item, and then hide the menu.

\item[Usage]
\begin{verbatim}
 ClickOnMenu(obj,[x,y])
  \end{verbatim}
This function is typically not used directly, but rather it is called via \texttt{MakeMenu}. However, it can be used as a quick-and-dirty button.

\item[Example]      	
This creates a menu and awaits clicking on.  More complete examples are available in ui.pbl.  It requires that MyMessage is created somewhere
\begin{verbatim}

   menu1 <- MakeMenuItem("File",0,0,gWin,14,10,"MYMESSAGE")


   menu2<- MakeMenu("Edit",70,0,gWin,14,10, "MYMESSAGE")
   
   menus <- [menu1,menu2]
   opt <- WaitForClickOntarget(menu,[1,2])
   ClickOnMenu(Nth(menus,opt),gClick)
\end{verbatim}

\item[See Also]	\verb+MakeMenu()+, \verb+OpenSubMenus()+, \verb+MakeMenuItem+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ClickOnScrollbox()+

\item[Description]	
Handles a click event on the a  \verb+ScrollBox+. This should be called after one checks (e.g., via InsideTB) whether the scrollbox was actually clicked on.  It will handle scrolling, moving via the thumb, up/down arrows, and reselection. It is also used to interact with \verb+ScrollingTextBox+  objects. This function name is bound to the .clickon property of scrollboxes, so it can be called using CallFunction (see example below).

\item[Usage]
\begin{verbatim}
 ClickOnScrollbox(sb,[x,y])
  \end{verbatim}

Here, \texttt{sb} is the scrollbox object. \texttt{[x,y]} is a list of xy coordinates, which can also be the global variable \texttt{gClick}

\item[Example]      	
See ui.pbl in the demo directory for examples of the use of a scrolling text box.  A brief example follows:

\begin{verbatim}
   sb <- MakeScrollBox(Sequence(1,50,1),"The numbers",40,40,gWin,12,150,500,3)
   Draw()
	  
   resp <- WaitForClickOntarget([sb],[1])
    ClickOnScrollbox(sb,gClick) 
 
    #Alternately:   CallFunction(sb.clickon,[sb,gClick])

 
   ##change the selected items
   sb.list <- Sequence(sb.selected,sb.selected+50,1)
   UpdateScrollbox(sb)      
   DrawScrollbox(sb)
   Draw()
 
\end{verbatim}

\item[See Also]
\verb+MakeScrollingTextBox+
\verb+MakeScrollBox+
\verb+UpdateScrollBox+
\verb+DrawScrollBox+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+CloseNetworkConnection()+

\item[Description]	Closes network connection

\item[Usage]
\begin{verbatim}
   CloseNetwork(<network>)
\end{verbatim}

\item[Example]	

\begin{verbatim}
  net <- WaitForNetworkConnection("localhost",1234)
  SendData(net,"Watson, come here. I need you.")
  CloseNetworkConnection(net)
\end{verbatim}
Also see nim.pbl for example of two-way network connection.
\item[See Also]
  \verb+ConnectToIP+, \verb+ConnectToHost+,  \verb+WaitForNetworkConnection+, \\
  \verb+GetData+,  \verb+SendData+, \verb+ConvertIPString+
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+ConnectToHost()+

\item[Description]	Connects to a host computer waiting for a
  connection on <port>, returning a network object that can be used to
  communicate.  Host is a text hostname, like \verb+"myname.indiana.edu"+, or
  use \verb+"localhost"+ to specify your current computer.

\item[Usage]
\begin{verbatim}
   ConnectToHost(<hostname>,<port>)
\end{verbatim}

\item[Example]	

  See nim.pbl for example of two-way network connection.
\begin{verbatim}
  net <- ConnectToHost("localhost",1234)
  dat <- GetData(net,20)
  Print(dat)
  CloseNetworkConnection(net)
\end{verbatim}

\item[See Also]
  \verb+ConnectToIP+, \verb+GetData+, 
\verb+WaitForNetworkConnection+,\\
 \verb+SendData+, \verb+ConvertIPString+, \verb+CloseNetworkConnection+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+ConnectToIP()+

\item[Description]	Connects to a host computer waiting for a
  connection on \verb+<port>+, returning a network object that can be used to
  communicate.  \verb+<ip>+ is a numeric ip address, which must be
  created with the \verb+ConvertIPString(ip)+ function. 

\item[Usage]
\begin{verbatim}
   ConnectToIP(<ip>,<port>)
\end{verbatim}

\item[Example]	

  See nim.pbl for example of two-way network connection.
\begin{verbatim}
  ip <- ConvertIPString("192.168.0.1")
  net <- ConnectToHost(ip,1234)
  dat <- GetData(net,20)
  Print(dat)
  CloseNetworkConnection(net)
\end{verbatim}

\item[See Also]
  \verb+ConnectToHost+, \verb+GetData+, \verb+WaitForNetworkConnection+,\\
   \verb+SendData+, \verb+ConvertIPString+, \verb+CloseNetworkConnection+
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+ConvertIPString()+

\item[Description]	Converts an IP address specified as a string into
  an integer that can be used by ConnectToIP.

\item[Usage]
\begin{verbatim}
   ConvertIPString(<ip-as-string>)
\end{verbatim}

\item[Example]	

  See nim.pbl for example of two-way network connection.
\begin{verbatim}
  ip <- ConvertIPString("192.168.0.1")
  net <- ConnectToHost(ip,1234)
  dat <- GetData(net,20)
  Print(dat)
  CloseNetworkConnection(net)
\end{verbatim}

\item[See Also]
  \verb+ConnectToHost+, \verb+ConnectToIP+, \verb+GetData+, \\ \verb+WaitForNetworkConnection+,
   \verb+SendData+, \\\verb+CloseNetworkConnection+
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+ConvexHull()+

\item[Description]	Computes the convex hull of a set of [x,y]
  points. It returns a set of points that forms the convex hull, with
  the first and last point identical.  A convex hull is the set of
  outermost points, such that a polygon connecting just those points
  will encompass all other points, and such that no angle is acute.
  It is used in MakeAttneave.

\item[Usage]
\begin{verbatim}
   ConvexHull(<list-of-x-y-points>)
\end{verbatim}

\item[Example]	
\begin{verbatim} 
pts <- [[0.579081, 0.0327737], 
         [0.0536094, 0.378258], 
         [0.239628, 0.187751], 
         [0.940625, 0.26526], 
         [0.508748, 0.840846],
         [0.352604, 0.200193], 
         [0.38684, 0.212413],
         [0.00114761, 0.768165],
         [0.432963, 0.629412]]
  Print(ConvexHull(pts))

\end{verbatim}

output:
\begin{verbatim}
[[0.940625, 0.26526]
, [0.508748, 0.840846]
, [0.00114761, 0.768165]
, [0.0536094, 0.378258]
, [0.239628, 0.187751]
, [0.579081, 0.0327737]
, [0.940625, 0.26526]

\end{verbatim}


\item[See Also]
  \verb+MakeAttneave+,

\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Cos()+
			 
\item[Description] 	Cosine of \verb+<deg>+ degrees.

\item[Usage]		
\item[Example]	
\begin{verbatim}
  Cos(33.5)
  Cos(-32)
\end{verbatim}

\item[See Also]     	\verb+Sin()+, \verb+Tan()+, \verb+ATan()+, \verb+ACos()+, \verb+ATan()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Countdown()+
			 
\item[Description] 	Displays a 3-2-1 countdown on the screen in with 500 ms ISI.
\verb+CountDown+ temporarily hides whatever is on the screen. It is useful in orienting participants to
the first trial of a task.

\item[Usage]		
\begin{verbatim}
   CountDown(win)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  win <- MakeWindow()
  MessageBox("Press any key to begin",win)
  CountDown(win)
  Trial()
\end{verbatim}

\item[See Also]   \verb+MessageBox+
\end{desc}



\begin{desc}{Name/Symbol}

\item[Name/Symbol] \verb+CR()+

\item[Description]  Produces \verb+<number>+ linefeeds which can be added to a
  string and printed or saved to a file.  CR is an abbreviation for ``Carriage Return''.

\item[Usage]\verb!CR(<number>)!

\item[Example]     
\begin{verbatim}
         Print("Number: "  Tab(1) + number  + CR(2))
         Print("We needed space before this line.")
\end{verbatim}
\item[See Also]
\verb+Format()+, \verb+Tab()+
\end{desc}






\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+CrossFactorWithoutDuplicates()+

\item[Description] 	This function takes a single list, and returns a list of all 
			pairs, excluding the pairs that have two of the same item. 
			To achieve the same effect but include the duplicates, use: \\
			\verb+DesignFullCounterBalance(x,x)+.

\item[Usage]
\begin{verbatim}
CrossFactorWithoutDuplicates(<list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
CrossFactorWithoutDuplicates([a,b,c]) 
# == [[a,b],[a,c],[b,a],[b,c],[c,a],[c,b]]
\end{verbatim}

\item[See Also] \verb+DesignFullCounterBalance()+, \verb+Repeat()+,\\ \verb+DesignBalancedSampling()+,
 \verb+DesignGrecoLatinSquare()+,\\
  \verb+DesignLatinSquare()+,  \verb+RepeatList()+, 
  \verb+LatinSquare()+,\\ \verb+Shuffle()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+CumNormInv()+

\item[Description] 	This function takes a probability and returns the 
  corresponding z-score for the cumulative standard normal distribution.
  It uses an accurate numerical approximation from:\\
  \texttt{http://home.online.no/~pjacklam/notes/invnorm}
\item[Usage]
\begin{verbatim}
CumNormInv(<p>)
\end{verbatim}

\item[Example]
\begin{verbatim}

 Print(CumNormInv(0))    #= NA
  Print(CumNormInv(.01)) #= -2.32634
  Print(CumNormInv(.5))  #= 0
  Print(CumNormInv(.9))  #= 1.28
  Print(CumNormInv(1))   #= NA
\end{verbatim}

\item[See Also] \verb+NormalDensity()+, \verb+RandomNormal()+
\end{desc}


\vfill
\newpage
\sect{D}
\vfill

\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+define+

\item[Description]  	Defines a user-specified function.

\item[Usage]
\begin{verbatim}
define functionname (parameters)
{
 statement1
 statement2
 statement3
       #Return statement is optional:
 return <value>
}
\end{verbatim}

\item[Example]    	See above.

\item[See Also]
\end{desc}   	



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+DegToRad()+

\item[Description]  	Converts degrees to radians.

\item[Usage]
\begin{verbatim}
DegToRad(<deg>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
DegToRad(180) # == 3.14159...
\end{verbatim}

\item[See Also]    	\verb+Cos()+, \verb+Sin()+, \verb+Tan()+, \verb+ATan()+, \verb+ACos()+, \verb+ATan()+ 
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+DesignBalancedSampling()+

\item[Description] 	Samples elements ``roughly'' equally.
  		This function returns a list of repeated samples from
 		\verb+<treatment_list>+, such that each element in \verb+<treatment_list>+ 
		appears approximately equally.  Each element from 
		\verb+<treatment_list>+ is sampled once without replacement before 
		all elements are returned to the mix and sampling is repeated.  
		If there are no repeated items in \verb+<list>+, there will be no
 		consecutive repeats in the output.  The last repeat-sampling 
		will be truncated so that a \verb+<length>+-size list is returned.  
		If you don't want the repeated epochs this function provides, 
		Shuffle() the results.

\item[Usage]
\begin{verbatim}
DesignBalancedSampling(<list>, <length>)
\end{verbatim}

\item[Example]
\begin{verbatim}
DesignBalancedSampling([1,2,3,4,5],12)
## e.g., produces something like:
##    [5,3,1,4,2, 3,1,5,2,4, 3,1 ]
\end{verbatim}

\item[See Also]	\verb+CrossFactorWithoutDuplicates()+,
  \verb+Shuffle()+,\\ \verb+DesignFullCounterBalance()+,
  		\verb+DesignGrecoLatinSquare()+, \\
\verb+DesignLatinSquare()+, \verb+Repeat()+, 
		\verb+RepeatList()+,  \\\verb+LatinSquare()+

\end{desc}






\begin{desc}{Name/Symbol}

\item[Name/Symbol]	\verb+DesignFullCounterbalance()+

\item[Description]	This takes two lists as parameters, and returns a nested list 
		of lists that includes the full counterbalancing of both 
		parameter lists.  Use cautiously; this gets very large.

\item[Usage]
\begin{verbatim}
DesignFullCounterbalance(<lista>, <listb>)
\end{verbatim}

\item[Example]
\begin{verbatim}
a <- [1,2,3]
b <- [9,8,7]
DesignFullCounterbalance(a,b)	# == [[1,9],[1,8],[1,7],
				#     [2,9],[2,8],[2,7],
				#     [3,9],[3,8],[3,7]]
\end{verbatim}

\item[See Also] \verb+CrossFactorWithoutDuplicates()+,
  \verb+LatinSquare()+, \verb+Shuffle()+,
  \verb+DesignBalancedSampling()+, 
\\\verb+DesignGrecoLatinSquare()+, 
  \verb+DesignLatinSquare()+, \verb+Repeat()+, \verb+RepeatList()+,

\end{desc}






\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+DesignGrecoLatinSquare()+

\item[Description] This will return a list of lists formed by rotating
  through each element of the \verb+<treatment_list>+s, making a list
  containing all element of the list, according to a greco-latin
  square.  All lists must be of the same length.

\item[Usage]
\begin{verbatim}
DesignGrecoLatinSquare(<factor_list>, 
                       <treatment_list>, 
                       <treatment_list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
x <- ["a","b","c"]
y <- ["p","q","r"]
z <- ["x","y","z"]
Print(DesignGrecoLatinSquare(x,y,z))
# produces:   	[[[a, p, x], [b, q, y], [c, r, z]], 
#               [[a, q, z], [b, r, x], [c, p, y]], 
#               [[a, r, y], [b, p, z], [c, q, x]]]
\end{verbatim}

\item[See Also] \verb+CrossFactorWithoutDuplicates()+, \verb+LatinSquare()+,\\
  \verb+DesignFullCounterBalance()+, \verb+DesignBalancedSampling()+,\\
  \verb+DesignLatinSquare()+, \verb+Repeat()+, \verb+RepeatList()+,
  \verb+Shuffle()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+DesignLatinSquare()+

\item[Description] This returns return a list of lists formed by
  rotating through each element of \verb+<treatment_list>+, making a
  list containing all element of the list. Has no side effect on input
  lists.  

\item[Usage]
\begin{verbatim}
DesignLatinSquare(<treatment1_list>, 
                  <treatment2_list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
order <- [1,2,3]
treatment <- ["A","B","C"]
design <- DesignLatinSquare(order,treatment)
# produces: [[[1, A], [2, B], [3, C]],
#            [[1, B], [2, C], [3, A]],
#            [[1, C], [2, A], [3, B]]]
\end{verbatim}

\item[See Also] \verb+CrossFactorWithoutDuplicates()+,
  \verb+DesignFullCounterBalance()+, \verb+DesignBalancedSampling()+,
  \verb+DesignGrecoLatinSquare()+, \verb+Repeat()+, \verb+LatinSquare()+
  \verb+RepeatList()+, \verb+Shuffle()+, \verb+Rotate()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Dist()+

\item[Description] Returns Euclidean distance between two points.
  Each point should be [x,y], and any additional items in the list are
  ignored.  


\item[Usage]
\begin{verbatim}
Dist(<xylist1>, <xylist2>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  p1 <- [0,0]
  p2 <- [3,4]
  d <- Dist(p1,p2)  #d is 5
\end{verbatim}
\item[See Also]	
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Div()+

\item[Description]  	Returns round(\verb+<num>/<mod>+)

\item[Usage]
\begin{verbatim}
Div(<num>, <mod>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+Mod()+
\end{desc}






\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Draw()+

\item[Description]	Redraws the screen or a specific widget.

\item[Usage]
\begin{verbatim}
Draw()
Draw(<object>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+DrawFor()+, \verb+Show()+, \verb+Hide()+
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+DrawFor()+

\item[Description] Draws a screen or widget, returning after
  \verb+<cycles>+ refreshes. This function currently does not work as
  intended in the SDL implementation, because of a lack of control
  over the refresh blank.  It may work in the future.

\item[Usage]
\begin{verbatim}
DrawFor( <object>, <cycles>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+Draw()+, \verb+Show()+, \verb+Hide()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+DrawObject()+

\item[Description] Calls the function named by the  .draw property of a custom object.  Useful for handling drawing of a bunch of different objects. This is essentially the same as CallFunction(obj.draw, [obj]), but falls back to a normal Draw() command so it handles built-in objects as well.

\item[Usage]
\begin{verbatim}
DrawObject(obj)	
\end{verbatim}

\item[Example]	


\begin{verbatim}
  
   ##This overrides buttons placement at the center:  
   done <- MakeButton("QUIT",400,250,gWin,150)
   WaitForClickOnTarget([done],[1])
   Clickon(done,gClick)
   DrawObject(done)
    
\end{verbatim}

\item[See Also]	
\verb+Inside()+, \verb+ClickOnCheckbox+ \verb+MoveObject+, \verb+Draw+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+DrawPulldown()+

\item[Description]	
This handles layout/drawing of a pulldown box. This does not actually call Draw() on the window, and so an additional draw command is needed before the output is displayed.  The main use case for this function is if you need to manually change the selected object (by changing .selected). This will redraw the pulldown with the new selection.  

\item[Usage]
\begin{verbatim}
 DrawPullDown(object)
 \end{verbatim}

\item[Example]      	
\begin{verbatim}
 options  <- MakePulldownButton(["A",B","C"],400,250,gWin,14,100,1)
 Draw()
 WaitForAnyKeyPress()
 options.selected <- 2
 DrawPulldown(options)
 Draw()
 WaitForAnyKeyPress()
\end{verbatim}

\item[See Also]	\verb+MakePullDown()+, \verb+Pulldown()+, \verb+UpdatePulldown+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+DrawScrollbox()+

\item[Description]	
Redraws a \verb+ScrollBox+.  This is called by various internal functions, but should be used to handle redrawing if \texttt{UpdateScrollbox} is used. When things like the scrollbar, offset, and selected item change, this can be called directly.  If the actual list is changed, \texttt{UpdateScrollBox} should be called first. Note that the redrawn scrollbox won't be changed on the screen until a \verb+Draw()+ command is issued.

\item[Usage]
\begin{verbatim}
 DrawScrollBox(sb)
  \end{verbatim}

Here, \texttt{sb} is the scrollbox object.

\item[Example]      	
See ui.pbl in the demo directory for examples of the use of a scrolling text box.  A brief example follows:

\begin{verbatim}
   sb <- MakeScrollBox(Sequence(1,50,1),"The numbers",40,40,gWin,12,150,500,3)
   Draw()
	  
   resp <- WaitForClickOntarget([sb],[1])
   CallFunction(sb.clickon,[sb,gClick])
   #Alternately: ClickOnScrollbox(sb,gClick) 
 
   ##change the selected items
   sb.list <- Sequence(sb.selected,sb.selected+50,1)
   UpdateScrollbox(sb)      
   DrawScrollbox(sb)
   Draw()
 
\end{verbatim}

\item[See Also]
\verb+MakeScrollingTextBox+
\verb+MakeScrollBox+
\verb+UpdateScrollBox+
\verb+ClickOnScrollBox+
\end{desc}


\vfill
\newpage
\sect{E}
\vfill

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+EasyLabel()+

\item[Description] Creates and adds to the window location a label
  at specified location. Uses standard vera font with grey background.
   (May in the future get background color from window).
  Easy-to-use replacement for the \verb+MakeFont+,  ~\verb+MakeLabel+,
 ~ \verb+AddObject+, ~ \verb+Move+, steps you typically have to go through.

\item[Usage]
\begin{verbatim}
EasyLabel( <text>,<x>, <y>, <win>, <fontsize>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  win <- MakeWindow()
  lab <- EasyLabel("What?",200,100,win,12)
  Draw()
\end{verbatim}
\item[See Also]	
\verb+EasyTextBox()+, \verb+MakeLabel()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+EasyTextBox()+

\item[Description] Creates and adds to the window location a textbox
  at specified location. Uses standard vera font with white background.
  Easy-to-use replacement for the MakeFont,MakeTextBox,
  AddObject, Move, steps.

\item[Usage]
\begin{verbatim}
EasyTextBox( <text>,<x>, <y>, <win>,
             <fontsize>,<width>,<height>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  win <- MakeWindow()
  entry <- EasyTextBox("1 2 3 4 5",200,100,
                        win,12,200,50)
  Draw()
\end{verbatim}
\item[See Also]	
\verb+EasyLabel()+, \verb+MakeTextBox()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Ellipse()+
  
\item[Description]	Creates a ellipse for graphing at x,y with radii
  rx and ry. Ellipses are only currently definable oriented in
  horizontal/vertical directions.  Ellipses  must be added
  to a parent widget before it can be drawn; it may be added to
  widgets other than a base window.  The properties of ellipses may be
  changed by accessing their properties directly, including the FILLED
  property which makes the object an outline versus a filled shape.

\item[Usage]
\begin{verbatim}
Ellipse(<x>, <y>, <rx>, <ry>,<color>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  
  e <- Ellipse(30,30,20,10, MakeColor(green))
  AddObject(e, win)
  Draw()

\end{verbatim}
\item[See Also]	\verb+Square()+, \verb+Circle()+, \verb+Rectangle()+, \verb+Line()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+EndOfFile()+

\item[Description]	Returns true if at the end of a file.

\item[Usage]
\begin{verbatim}
EndOfFile(<filestream>)
\end{verbatim}

\item[Example]
\begin{verbatim}
while(not EndOfFile(fstream))
{
 Print(FileReadLine(fstream))
}
\end{verbatim}

\item[See Also]	
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+EndOfLine()+

\item[Description]	Returns true if at end of line.

\item[Usage]
\begin{verbatim}
EndOfLine(<filestream>)
\end{verbatim}

\item[Example]	

\item[See Also]	
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Enquote()+

\item[Description]	Surrounds the argument with quotes.  

\item[Usage]
\begin{verbatim}
Enquote("one two three")
\end{verbatim}

\item[Example]
\begin{verbatim}
 ##use to add quoted text to instructions.
 instructions <- "Respond whenever you see an "+ 
                  Enquote("X")

  ##Use it for saving data that may have spaces: 
  resp <-  GetInput(tb, "<enter>")
  FilePrint(fileout, Enquote(resp))

\end{verbatim}

\item[See Also]	
 gQuote 
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Exp()+

\item[Description]	$e$ to the power of \verb+<pow>+.

\item[Usage]
\begin{verbatim}
Exp(<pow>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Exp(0) 		# == 1
Exp(3)		# == 20.0855
\end{verbatim}

\item[See Also]	\verb+Log()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+ExtractListItems()+

\item[Description]	Extracts items from a list, forming a new list. 
		The list \verb+<items>+ are the integers representing the
		indices that should be extracted.  
	     
\item[Usage]
\begin{verbatim}
ExtractListItems(<list>,<items>)
\end{verbatim}

\item[Example]
\begin{verbatim}
myList <- Sequence(101, 110, 1)
ExtractListItems(myList, [2,4,5,1,4])
# produces [102, 104, 105, 101, 104]
\end{verbatim}

\item[See Also]	\verb+Subset()+, \verb+SubList()+, \verb+SampleN()+, \verb+Filter()+
\end{desc}

\vfill
\newpage
\sect{F}
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FileClose()+

\item[Description]	Closes a filestream  variable.  Be sure to 
		pass the variable name, not the filename.  

\item[Usage]
\begin{verbatim}
FileClose(<filestream>)
\end{verbatim}

\item[Example]
\begin{verbatim}
x <- FileOpenRead("file.txt")
# Do relevant stuff here.
FileClose(x)
\end{verbatim}

\item[See Also]	\verb+FileOpenAppend()+, \verb+FileOpenRead()+, \verb+FileOpenWrite()+

\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FileExists()+

\item[Description]	Checks whether a file exists.  Returns 1 if it exists, 0 otherwise.
\item[Usage]		
\begin{verbatim}
 FileExists(<path>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
 filename <- "data-"+gSubNum+".csv"
 exists <-  FileExists(filename)
  if(exists)
   {
    MessageBox("Subject file already exists. "+
    " Please try a new one.",gWin) 
    SignalFatalError("filename already used")
   }
\end{verbatim}

\item[See Also]\verb+GetDirectoryListing()+, \verb+FileExists()+,       \verb+IsDirectory()+,        
   \verb+MakeDirectory()+      

\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FileOpenAppend()+

\item[Description] Opens a filename, returning a stream that can be
  used for writing information.  Appends if the file already exists.

\item[Usage]
\begin{verbatim}
FileOpenAppend(<filename>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+FileClose()+, \verb+FileOpenRead()+, \verb+FileOpenWrite()+, 
\verb+FileOpenOverWrite()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FileOpenOverwrite()+

\item[Description] Opens a filename, returning a stream that can be
  used for writing information.  Overwrites if file already exists.
  This function should not be used for opening data files; instead,
  use FileOpenWrite, which saves to a backup file if the specified
  file already exists.

\item[Usage]
\begin{verbatim}
FileOpenOverWrite(<filename>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+FileClose()+, \verb+FileOpenAppend()+,
\verb+FileOpenRead()+  \verb+FileOpenWrite()+

\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FileOpenRead()+

\item[Description]  	Opens a filename, returning  a stream to be used 
		for reading information.

\item[Usage]
\begin{verbatim}
FileOpenRead(<filename>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+FileClose()+, \verb+FileOpenAppend()+, \verb+FileOpenWrite()+, \verb+FileOpenOverWrite()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FileOpenWrite()+

\item[Description] Opens a filename, returning a stream that can be
  used for writing information.  If the specified filename exists, it
  won't overwrite that file.  Instead, it will create a related
  filename, appending a -integer before the filename extension.


\item[Usage]
\begin{verbatim}
FileOpenWrite(<filename>)
\end{verbatim}

\item[Example]	

In the following example, test.txt gets created with the text
``testing 1'', and then a second file test-1.txt gets created with the
text ``testing 2''.

\begin{verbatim}
  f1 <- FileOpenWrite("test.txt")
  FilePrint(f1,"testing 1")
  FileClose(f1)
  f2 <- FileOpenWrite("test.txt")
  FilePrint(f2,"testing 2")
  FileClose(f2)
\end{verbatim}

\item[See Also]	\verb+FileClose()+, \verb+FileOpenAppend()+, \verb+FileOpenRead()+, \verb+FileOpenOverWrite()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FilePrint()+

\item[Description]	Like \verb+Print+, but to a file.  Prints a string to a file, 
		with a carriage return at the end.  Returns a
  copy of the string it prints.
	
\item[Usage]
\begin{verbatim}
FilePrint(<filestream>, <value>)
\end{verbatim}

\item[Example]
\begin{verbatim}
FilePrint(fstream, "Another Line.")
\end{verbatim}

\item[See Also]	\verb+Print()+, \verb+FilePrint_()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FilePrint_()+

\item[Description]	Like \verb+Print_+, but to a file.  Prints a
  string to a file,	without appending a newline character.  Returns a
  copy of the string it prints.
	
\item[Usage]
\begin{verbatim}
FilePrint_(<filestream>, <value>)
\end{verbatim}

\item[Example]
\begin{verbatim}
FilePrint_(fstream, "This line doesn't end.")
\end{verbatim}

\item[See Also]	\verb+Print_()+, \verb+FilePrint()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FilePrintList()+

\item[Description]	Prints a list to a file, without the ','s or []
  characters. Puts a carriage return at the end.  Returns a string
  that was printed.  If a list contains other lists, the printing will
  wrap multiple lines and the internal lists will be printed as
  normal.  To avoid this, try FilePrintList(file,Flatten(list)).

\item[Usage]
\begin{verbatim}
FilePrintList(<filestream>, <list>)
\end{verbatim}

\item[Example]
\begin{verbatim}

FilePrintList(fstream, [1,2,3,4,5,5,5])
##
##  Produces:
##1 2 3 4 5 5 5
FilePrintList(fstream,[[1,2],[3,4],[5,6]])
#Produces:
# [1,2]
#,[3,4]
#,[5,6]

FilePrintList(fstream,Flatten([[1,2],[3,4],[5,6]]))
#Produces:
# 1 2 3 4 5 6


\end{verbatim}

\item[See Also]	\verb+Print()+, \verb+Print_()+, \verb+FilePrint()+, \verb+FilePrint_()+, \verb+PrintList()+,
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FileReadCharacter()+

\item[Description]	Reads and returns a single character from a filestream.

\item[Usage]
\begin{verbatim}
FileReadCharacter(<filestream>)
\end{verbatim}

\item[Example]	

\item[See Also]	
   \verb+FileReadList()+, \verb+FileReadTable()+
   \verb+FileReadLine()+, 	\verb+FileReadText()+, 	\verb+FileReadWord()+,

\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FileReadLine()+

\item[Description]	Reads and returns a line from a file; all characters up
		until the next newline or the end of the file.

\item[Usage]
\begin{verbatim}
FileReadLine(<filestream>)
\end{verbatim}

\item[Example]	

\item[See Also]	

	\verb+FileReadCharacter()+,\verb+FileReadList()+, \verb+FileReadTable()+
	\verb+FileReadText()+, 	\verb+FileReadWord()+,

\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+FileReadList()+
 
\item[Description] Given a filename, will open it, read in all the
  items into a list (one item per line), and close the file afterward.
  Ignores blank lines or lines starting with \verb+#+.  Useful with a
  number of pre-defined data files stored in \verb+media/text/+.  See
  Section~\ref{sec:media}: Provided Media Files.

\item[Usage]
\begin{verbatim}
FileReadList(<filename>)
\end{verbatim}

\item[Example]
\begin{verbatim}
FileReadList("data.txt")
\end{verbatim}

\item[See Also]

	\verb+FileReadCharacter()+, \verb+FileReadTable()+
	\verb+FileReadLine()+, 	\verb+FileReadText()+, 	\verb+FileReadWord()+,

\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FileReadTable()+

\item[Description]	Reads a table directly from a file. Data in file should
		separated by spaces.  Reads each line onto a sublist,
		with space-separated tokens as items in sublist.  Ignores
		blank lines or lines beginning with \verb+#+. Optionally,
		specify a token separator other than space.

\item[Usage]
\begin{verbatim}
FileReadTable(<filename>, <optional-separator>)
\end{verbatim}

\item[Example]
\begin{verbatim}
a <- FileReadTable("data.txt")
\end{verbatim}

\item[See Also]	
	\verb+FileReadCharacter()+,\verb+FileReadList()+, 
	\verb+FileReadLine()+, 	\verb+FileReadText()+, 	\verb+FileReadWord()+,

\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FileReadText()+

\item[Description]	Returns all of the text from a file, ignoring any lines
		beginning with \verb+#+. Opens and closes the file transparently.

\item[Usage]
\begin{verbatim}
FileReadText(<filename>)
\end{verbatim}

\item[Example]
\begin{verbatim}
instructions <- FileReadText("instructions.txt")
\end{verbatim}

\item[See Also]	
	\verb+FileReadCharacter()+,\verb+FileReadList()+, \verb+FileReadTable()+
	\verb+FileReadLine()+, 	\verb+FileReadWord()+,

\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FileReadWord()+

\item[Description]	Reads and returns  a `word' from a file; the next
		connected stream of characters not including a \verb+' '+
		or a newline. Will not read newline characters.

\item[Usage]
\begin{verbatim}
FileReadWord(<filestream>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+FileReadLine()+, \verb+FileReadTable()+, \verb+FileReadList()+
	\verb+FileReadCharacter()+,\verb+FileReadList()+, \verb+FileReadTable()+
	\verb+FileReadLine()+, 	\verb+FileReadText()+, 	\verb+FileReadWord()+,

\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Filter()+            

\item[Description] Returns a subset of \verb+<list>+, depending on whether the \verb+<filter>+ list is zero or nonzero.  Both arguments must be lists of the same length.

\item[Usage]		
\begin{verbatim}
Filter(<list>,<filter>)
\end{verbatim}

\item[Example]	
\begin{verbatim} 
  x <- [1,2,3,3,2,2,1]
  Print(Filter(x,[1,1,1,0,0,0,0])) ##==[1,2,3]
  Print(Filter(x,Match(x,1)))      ##== [1,1]
\end{verbatim}

\item[See Also]	\verb+Match()+, \verb+Subset()+, \verb+Lookup()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FindInString()+

\item[Description]	Finds a token in a string, returning the position (starting at a particular position).

\item[Usage]
\begin{verbatim}
FindInString(<basestring>,<searchstring>,<startingpos>)
\end{verbatim}

If the string is not found, the value 0 is returned.
\item[Example]
\begin{verbatim}
FindInString("about","bo",1) 	# == 2
FindInString("banana","na",1) 	# == 3
FindInString("banana","na",4) 	# == 5
\end{verbatim}

\item[See Also]	\verb+SplitString()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+First()+

\item[Description]	Returns the first item of a list.

\item[Usage]
\begin{verbatim}
First(<list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
First([3,33,132])		# == 3
\end{verbatim}

\item[See Also]	\verb+Nth()+, \verb+Last()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Flatten()+

\item[Description]
	Flattens nested list \verb+<list>+ to a single flat list.

\item[Usage]
\begin{verbatim}
Flatten(<list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Flatten([1,2,[3,4],[5,[6,7],8],[9]])	# == [1,2,3,4,5,6,7,8,9]
Flatten([1,2,[3,4],[5,[6,7],8],[9]])	# == [1,2,3,4,5,6,7,8,9]
\end{verbatim}

\item[See Also]	\verb+FlattenN()+, \verb+FoldList()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FlattenN()+

\item[Description]	Flattens \verb+<n>+ levels of nested list \verb+<list>+. 

\item[Usage]
\begin{verbatim}
Flatten(<list>, <n>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Flatten([1,2,[3,4],[5,[6,7],8],[9]],1) 
# == [1,2,3,4,5,[6,7],8,9]
\end{verbatim}

\item[See Also]	\verb+Flatten()+, \verb+FoldList()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Floor()+

\item[Description]	Rounds \verb+<num>+ down to the next integer.

\item[Usage]
\begin{verbatim}
Floor(<num>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Floor(33.23)	# == 33
Floor(3.999)  	# ==3
Floor(-32.23) 	# == -33
\end{verbatim}
 
\item[See Also]	\verb+AbsFloor()+, \verb+Round()+, \verb+Ceiling()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+FoldList()+

\item[Description]	Folds a list into equal-length sublists.

\item[Usage]
\begin{verbatim}
FoldList(<list>, <size>)
\end{verbatim}

\item[Example]
\begin{verbatim}
FoldList([1,2,3,4,5,6,7,8],2)	# == [[1,2],[3,4],[5,6],[7,8]]
\end{verbatim}
 
\item[See Also]	\verb+FlattenN()+, \verb+Flatten()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Format()+            

\item[Description]	Formats the printing of values to ensure the
  proper spacing. It will either truncate or pad \verb+<value>+ with spaces
  so that it ends up exactly \verb+<length>+ characters long.  Character
  padding is at the end.
 
\item[Usage]
\begin{verbatim}
Format(<value>, <length>)
\end{verbatim}

\item[Example]	
\begin{verbatim}

  x <- 33.23425225
  y <- 23.3
  Print("["+Format(x,5)+"]")
  Print("["+Format(y,5)+"]")
  ## Output: 
  ## [33.23 ]
  ## [23.3  ]
\end{verbatim}
         

\item[See Also]	
\verb+CR()+ \verb+Tab()+
\end{desc}

\vfill
\newpage
\sect{G}
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetAngle()+

\item[Description]	Gets  an angle (in degrees) from (0,0) of an x,y coordinate


\item[Usage]
\begin{verbatim}
GetAngle(<x>,<y>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  ##point sprite in the direction of a click   
  sprite <- LoadImage("car.png")
  AddObject(sprite,gWin)
  Move(sprite,300,300)
  xy <- WaitForDownClick()
  newangle <- GetAngle(First(xy)-300,Second(xy)-300)
  sprite.rotation <- newangle
  Draw()
\end{verbatim}

\item[See Also]	\verb+DegtoRad+, \verb+RadToDeg+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetAngle3()+

\item[Description]	Gets  an angle (in radians) of abc.


\item[Usage]
\begin{verbatim}
GetAngle3(<a>,<b>,<c>)
\end{verbatim}

\item[Example]	



\begin{verbatim}
   a <- [0.579081, 0.0327737]
   b <- [0.0536094, 0.378258]
   c <- [0.239628, 0.187751]

  Print(GetAngle3(a,b,c)) ## .2157

\end{verbatim}

\item[See Also]	\verb+DegtoRad+, \verb+RadToDeg+, \verb+GetAngle+, \verb+ToRight+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetCurrentScreenResolution()+

\item[Description]	Returns an list of [width,height] specifying what the 
current computer screen resolution is.  This is used within the pebl launcher in order
to use the current resolution to run the experiment.

\item[Usage]
\begin{verbatim}
res <- GetCurrentScreenResolution()
\end{verbatim}

\item[Example]	

\begin{verbatim}
define Start(p)
{
   ## For testing, let's make the screen resolution a bit smaller than the 
   ## current one so that it doesn't get hidden by the bottom task bar
   ##
   res <- GetCurrentScreenResolution()
   gVideoWidth <- First(res)-100
   gVideoHeight <- Second(res)-100
   gWin <- MakeWindow()
   MessageBox("Window slightly smaller than screen",gWin)
}
\end{verbatim}


\item[See Also]	\verb+GetVideoModes()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetCursorPosition()+

\item[Description]	Returns an integer specifying where in a textbox the edit cursor is.  The value indicates which character it is on.

\item[Usage]
\begin{verbatim}
GetCursorPosition(<textbox>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+SetCursorPosition()+, \verb+MakeTextBox()+, \verb+SetText()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetData()+

\item[Description]	Gets Data from network connection.  Example of
  usage in demo/nim.pbl.

\item[Usage]
\begin{verbatim}
val <- GetData(<network>,<size>)
\end{verbatim}

\item[Example]	

On 'server':
\begin{verbatim}
  net <- WaitForNetworkConnection("localhost",1234)
  SendData(net,"Watson, come here. I need you.")
  value <-  GetData(net,10)
  Print(value)

\end{verbatim}
On Client:
\begin{verbatim}
  net <- ConnectToHost("localhost",1234)
  value <-  GetData(net,20)
  Print(value)
##should print out "Watson, come here. I need you."
\end{verbatim}
\item[See Also]
  \verb+ConnectToIP+, \verb+ConnectToHost+, \verb+WaitForNetworkConnection+,
   \verb+SendData+, \verb+ConvertIPString+, \verb+CloseNetworkConnection+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetDirectoryListing()+

\item[Description]	Returns a list of files and directories in a particular directory/folder.
\item[Usage]		
\begin{verbatim}
list <- GetDirectoryListing(<path>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
 files <-  GetDirectoryListing("./")
\end{verbatim}

\item[See Also]\verb+GetDirectoryListing()+, \verb+FileExists()+,       \verb+IsDirectory()+,        
   \verb+MakeDirectory()+      

\end{desc}


  
\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetEasyChoice()+

\item[Description]	Hides what is on the screen and presents a textbox with
  specified message, and a series of options to select from. Returns element from corresponding position of the \verb+<output>+ list.  

\item[Usage]		
\begin{verbatim}
GetEasyChoice(<message>,<list-of-choices>,
             <output>,<window>)
\end{verbatim}

\item[Example]	
The code snippet below produces the following screen:\\
\includegraphics[scale=.25]{images/EasyChoice.png}
\begin{verbatim}
 gWin <- MakeWindow("white")
 inp <-  GetEasyChoice("What Year are you in school",
                        ["First-year","Sophomore",
                        "Junior","Senior","Other"],
                        [1,2,3,4,5],  gWin)
 

\end{verbatim}

\item[See Also]\verb+MessageBox+,\verb+GetEasyChoice+, \verb+EasyTextBox+
\end{desc}

  
  
  
\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetEasyInput()+

\item[Description]	Hides what is on the screen and presents a textbox with
  specified message, and a second text box to enter input.  Continues
  when 'enter' it hit at the end of text entry.

\item[Usage]		
\includegraphics[scale=.25]{images/EasyInput.png}

\begin{verbatim}
GetEasyInput(<message>,<window>)
\end{verbatim}

\item[Example]	


\begin{verbatim}
 gWin <- MakeWindow()
 inp <-  GetEasyInput("Enter Participant ID Code",gWin)
\end{verbatim}

\item[See Also]\verb+MessageBox()+	\verb+GetEasyChoice()+, \verb+EasyTextBox()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetInput()+

\item[Description]	Allows user to type input into a textbox.

\item[Usage]
\begin{verbatim}
GetInput(<textbox>,<escape-key>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+SetEditable()+, \verb+GetCursorPosition()+, \verb+MakeTextBox()+, \verb+SetText()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+GetJoystickAxisState+ 

\item[Description]  
  This gets the state of a particular joystick axis.  You need to specify a joystick object, which is created with OpenJoystick().  You also need to specify the axis.  You can determine how many axes a joystick has with the GetNumJoystickAxes() function.  The function returns  a value between 1 and 32768.

\item[Usage]          \verb+GetJoystickAxisState(js,1)+ 

\item[Example]
See joysticktest.pbl in the demo\ directory

\item[See Also]
GetNumJoysticks(), OpenJoystick(), GetNumJoystickAxes()
GetNumJoystickBalls(), GetNumJoystickButtons(), GetNumJoystickHats()
GetJoystickAxisState(), GetJoystickHatState(), GetJoystickButtonState()
\end{desc} 

\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+GetJoystickButtonState+ 

\item[Description]  
  This gets the state of a particular joystick button.  You need to specify a joystick object, which is created with OpenJoystick().  You also need to specify the button.  You can determine how many buttons a joystick has with the GetNumJoystickButtons() function.  The function returns either 0 (for unpressed) or 1 (for pressed).

\item[Usage]         \verb+GetJoystickButtonState(js,1)+ 

\item[Example]
See joysticktest.pbl in the demo\ directory
\item[See Also]
GetNumJoysticks(), OpenJoystick(), GetNumJoystickAxes()
GetNumJoystickBalls(), GetNumJoystickButtons(), GetNumJoystickHats()
GetJoystickAxisState(), GetJoystickHatState(), GetJoystickButtonState()
\end{desc} 

\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+GetJoystickBallState+ 

\item[Description]  
	Not implemented.
\item[Usage]        \verb+GetJoystickBallState(js,1)+ 

\item[Example]
See joysticktest.pbl in the demo\ directory
\item[See Also]
GetNumJoysticks(), OpenJoystick(), GetNumJoystickAxes()
GetNumJoystickBalls(), GetNumJoystickButtons(), GetNumJoystickHats()
GetJoystickAxisState(), GetJoystickHatState(), GetJoystickButtonState()
\end{desc} 

\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+GetJoystickHatState+ 

\item[Description]  

\item[Usage]        \verb+GetJoystickHatState(js,1)+ 
  This gets the state of a particular joystick hat.  You need to specify a joystick object, which is created with OpenJoystick().  You also need to specify the hat id.  You can determine how many hats a joystick has with the GetNumJoystickHats() function.  The function returns a value between 0 and 15, which is the sum of values specifying whether each primary NSEW direction is pressed.  The coding is: 0=no buttons; 1=N, 2=E, 4=S, 8=W.  Thus, if 1 is returned, the north hat button is pressed.  If 3 is returned, NorthEast.  If 12 is returned, SW, and so on.
  
\item[Example]
See joysticktest.pbl in the demo\ directory

\item[See Also]
GetNumJoysticks(), OpenJoystick(), GetNumJoystickAxes()
GetNumJoystickBalls(), GetNumJoystickButtons(), GetNumJoystickHats()
GetJoystickAxisState(), GetJoystickHatState(), GetJoystickButtonState()
\end{desc} 


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetMouseCursorPosition()+

\item[Description] Gets the current x,y coordinates of the mouse
  pointer.

\item[Usage]
\begin{verbatim}
   GetMouseCursorPosition()
\end{verbatim}

\item[Example]	
\begin{verbatim}


 pos <- GetMouseCursorPosition()
\end{verbatim}


\item[See Also]
  \verb+ShowCursor+, \verb+WaitForMouseButton+,
  \verb+SetMouseCursorPosition+, \verb+GetMouseCursorPosition+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+GetMouseState()+

\item[Description] Gets the current x,y coordinates of the mouse
  pointer, plus the current state of the buttons.  Returns a 5-element list, with the first two indicating x,y position, the third is either 0 or 1 depending on if the left mouse is clicked, the fourth 0 or 2 depending on whether the middle mouse is clicked, and the fifth either 0 or 4 depending on whether the right mouse is clicked.

\item[Usage]
\verb+GetMouseState()+

\item[Example]	

\begin{verbatim}
define Start(p)
{
 
  win <- MakeWindow()
  i <- 1
  while(i < 100)
  {
    Draw()
    Print(GetMouseState())

    Wait(100)
    i <- i + 1

  }	
##Returns look like:
[417, 276, 0, 0, 0]
[495, 286, 0, 0, 0]
[460, 299, 0, 0, 0]
[428, 217, 0, 0, 0]
[446, 202, 0, 0, 4]
[446, 202, 1, 0, 0]
[446, 202, 1, 0, 0]
[446, 202, 0, 2, 0]

\end{verbatim}

\item[See Also]
  \verb+ShowCursor+ \verb+WaitForMouseButton+,
  \verb+SetMouseCursorPosition+, \verb+GetMouseCursorPosition+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetNewDataFile()+

\item[Description]	Creates a data file for output, asking for either append or renumbering the subject code if the specified file is already in use.

\item[Usage]
\begin{verbatim}
GetNewDataFile(subnum,win,basename,extension,header)
\end{verbatim} 
Here, subnum should be a subject code you want to use.  win should refer to the window a prompt will be displayed on if the subject code is already in use.  basename should be the base filename of the file, and extension should be the . extension (without the dot) at the end of the file.  Finally, header is what will be printed on the first row of a file.

When this file is used, a 'data' subdirectory will first be created in the current directory (i.e., the directory where the experiment is).  Then, a subdirectory will be created inside data based on the subnum.  Spaces and some other characters will be removed to ensure easy and uniform access to this directory.  Then, a filename will be created composed of:
\begin{verbatim}
data\subnum\basename-subnum.extension
\end{verbatim}

If this file does not exist, one will be created and the header will be printed to the first line.  If it does exist, you will be prompted that the file exists, and at that point you can choose to either append to the existing file (in which case no header will be added), or choose a new subject code (in which case, a new directory will be made).  The process can repeat until you either append or choose an unused file.

Multiple files can be made, and they will all appear in the subnum directory.  If you get a filename collision, you decision on the first file will carry forward on future files, controlled by a special global variable called gResetNumber.  


Note that nearly all of the test battery tests use this function.  This can make pooling subject data more difficult, but use the combine data dialog in the launcher to easily combine data from multiple files in multiple subdirectories.

In all situations, the global variable \verb+gSubNum+ is set to the resulting subject code (whether or not \verb+gSubNum+ is passed to this function). This should only be called at the beginning of an experiment, when the experimenter still has control of the computer, in case a subject code is reused and a decision needs to be made.  Finally, the extension chosen has essentially nothing to do with how the internals are formatted; it is up to you 


\item[Example]
\begin{verbatim}
  file1 <- GetNewDataFile("1",gWin,"memorytest","csv",
                  "sub,trial,word,answer,rt,corr")
##above creates a file data\1\memorytest-1.csv

 file2 <- GetNewDataFile("1",gWin,"memorytest","csv",
                  "sub,trial,word,answer,rt,corr")
# above will prompt you for new subject code

 file3 <- GetNewDataFile("1",gWin,"memorytest-report","txt",
                  "")
##No header is needed on a text-based report file.

\end{verbatim}

\item[See Also]	
\verb+FileOpenWrite+, \verb+FileOpenAppend+, \verb+FileOpenOverwrite+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetNIMHDemographics()+

\item[Description]	Gets demographic information that are normally required for NIMH-related research.  Currently are gender (M/F/prefer not to say), ethnicity (Hispanic or not), and race (A.I./Alaskan, Asian/A.A., Hawaiian, black/A.A., white/Caucasian, other).  
		It then prints their responses in a single line in the demographics file, along with any special code you supply and a time/date stamp. This code might include a subject number, experiment number, or something else, but many informed consent forms assure the subject that this information cannot be tied back to them or their data, so be careful about what you record. The file output will look something like: 
\begin{verbatim}
---- 
31,Thu May 12 17:00:35 2011,F,hisp,asian,3331
32,Thu May 12 22:49:10 2011,M,nothisp,amind,3332
---- 
\end{verbatim}


	The first column is the user-specified code (in this 
	case, indicating the experiment number).  The middle columns 
	indicate date/time, and the last three columns indicate 
	gender (M, F, other), Hispanic (Y/N), and race.

\item[Usage]
\begin{verbatim}
GetNIMHDemographics(<code-to-print-out>,
                     <window>, <filename>)
\end{verbatim} 

\item[Example]
\begin{verbatim}
GetNIMHDemographics("x0413", gwindow, 
                    "x0413-demographics.txt")
\end{verbatim}

\item[See Also]	
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+GetNumJoystickAxes+ 

\item[Description]  
  This gets the number of axes on a joystick.  You need to specify a joystick object, which is created with OpenJoystick(). 

\item[Usage]          \verb+GetNumJoystickAxes(js,1)+ 

\item[Example]
See joysticktest.pbl in the demo\ directory

\item[See Also]
GetNumJoysticks(), OpenJoystick(), GetNumJoystickAxes()
GetNumJoystickBalls(), GetNumJoystickButtons(), GetNumJoystickHats()
GetJoystickAxisState(), GetJoystickHatState(), GetJoystickButtonState()
\end{desc} 

\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+GetNumJoystickBalls+ 

\item[Description]  
  This gets the number of joystick balls available on a particular joystick.  You need to specify a joystick object, which is created with OpenJoystick().  
  
\item[Usage]          \verb+GetNumJoystickBalls(js)+ 

\item[Example]
See joysticktest.pbl in the demo\ directory

\item[See Also]
GetNumJoysticks(), OpenJoystick(), GetNumJoystickAxes()
GetNumJoystickBalls(), GetNumJoystickButtons(), GetNumJoystickHats()
GetJoystickAxisState(), GetJoystickHatState(), GetJoystickButtonState()
\end{desc} 


\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+GetNumJoystickButtons+ 

\item[Description]  
  This gets the number of joystick buttons available on a particular joystick.  You need to specify a joystick object, which is created with OpenJoystick(). 
\item[Usage]          \verb+GetNumJoystickButtons(js,1)+ 

\item[Example]
See joysticktest.pbl in the demo\ directory

\item[See Also]
GetNumJoysticks(), OpenJoystick(), GetNumJoystickAxes()
GetNumJoystickBalls(), GetNumJoystickButtons(), GetNumJoystickHats()
GetJoystickAxisState(), GetJoystickHatState(), GetJoystickButtonState()
\end{desc} 


\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+GetNumJoystickHats+ 

\item[Description]  
  This gets the number of hats available on a particular joystick.  You need to specify a joystick object, which is created with OpenJoystick(). 
\item[Usage]          \verb+GetNumJoystickHats(js,1)+ 

\item[Example]
See joysticktest.pbl in the demo\ directory

\item[See Also]
GetNumJoysticks(), OpenJoystick(), GetNumJoystickAxes()
GetNumJoystickBalls(), GetNumJoystickButtons(), GetNumJoystickHats()
GetJoystickAxisState(), GetJoystickHatState(), GetJoystickButtonState()
\end{desc} 

\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+GetNumJoysticks+ 

\item[Description]  
  This gets the number of joysticks available on a system. It returns an integer, which if greater than
  you can open a joystick using the OpenJoystick() function.. 
\item[Usage]          \verb+GetNumJoysticks()+ 

\item[Example]
See joysticktest.pbl in the demo\ directory

\item[See Also]
GetNumJoysticks(), OpenJoystick(), GetNumJoystickAxes()
GetNumJoystickBalls(), GetNumJoystickButtons(), GetNumJoystickHats()
GetJoystickAxisState(), GetJoystickHatState(), GetJoystickButtonState()
\end{desc} 



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetPEBLVersion()+

\item[Description]	Returns a string describing which version of PEBL you are running.

\item[Usage]
\begin{verbatim}
GetPEBLVersion() 
\end{verbatim}

\item[Example]
\begin{verbatim}
Print(GetPEBLVersion())
\end{verbatim}

\item[See Also]	\verb+TimeStamp()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetPixelColor()+

\item[Description] Gets a color object specifying the color of a particular pixel on a widget.

\item[Usage]
\begin{verbatim}
color <- GetPixelColor(widget,x,y) 
\end{verbatim}

\item[Example]
\begin{verbatim}
  ##Judge brightness of a pixel
  img <- MakeImage("test.png")
  col <- GetPixelColor(img,20,20)
  hsv <- RGBtoHSV(col)
  Print(Third(hsv))

\end{verbatim}

\item[See Also]	\verb+SetPixel()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+GetPPortState+ 

\item[Description]  
  Gets the parallel port state, as a list of 8 'bits' (1s or 0s).
  
\item[Usage]       
     \verb+out <- SetPPortState(pport)+ 
\item[Example]


\item[See Also]
\verb+COMPortGetByte+, \verb+COMPortSendByte+, \verb+OpenPPort+ \verb+OpenCOMPort+, \verb+SetPPortMode+, \verb+GetPPortState+ 
\end{desc} 


\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+GetProperty+ 

\item[Description]  
Gets a particular named property of an object. This works for custom or built-in objects.  If the property does not exist, a fatal error will be signaled, and so you should check using PropertyExists() if there is any chance the property does not exist.
  
\item[Usage]       
     \verb+out <- GetProperty(obj,property)+ 
\item[Example]

\begin{verbatim}
  obj <- MakeCustomObject("myobject")
  obj.taste <- "buttery"
  obj.texture <- "creamy"
  SetProperty(obj,"flavor","tasty")
  
  list <- GetPropertyList(obj)
  loop(i,list)
   {
     if(PropertyExists(obj,i)
      {
        Print(i  + ":  " + GetProperty(obj,i))
      }
   }

\end{verbatim}


\item[See Also]
\verb+GetPropertyList+, \verb+PropertyExists+, \verb+SetProperty+ \verb+MakeCustomObject+, \verb+PrintProperties+ 
\end{desc} 




\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+GetPropertyList+ 

\item[Description]  
Gets a list of all of the properties an object has.  This works for custom or built-in objects.
  
\item[Usage]       
     \verb+out <- GetPropertyList(obj)+ 
\item[Example]

\begin{verbatim}
  obj <- MakeCustomObject("myobject")
  obj.taste <- "buttery"
  obj.texture <- "creamy"
  SetProperty(obj,"flavor","tasty")
  
  list <- GetPropertyList(obj)
  loop(i,list)
   {
     if(PropertyExists(obj,i)
      {
        Print(i  + ":  " + GetProperty(obj,i))
      }
   }

\end{verbatim}


\item[See Also]
\verb+GetProperty+, \verb+PropertyExists+, \verb+SetProperty+ \verb+MakeCustomObject+, \verb+PrintProperties+ 
\end{desc} 



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetSize()+

\item[Description] Returns a list of \verb+[height, width]+,
  specifying the size of the widget.
  The .width and .height properties can also be used instead of this function

\item[Usage]
\begin{verbatim}
GetSize(<widget>)
\end{verbatim}

\item[Example]
\begin{verbatim}
image <- MakeImage("stim1.bmp")
xy <- GetSize(image)
x <- Nth(xy, 1)
y <- Nth(xy, 2)
\end{verbatim}

\item[See Also]	
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetSubNum()+

\item[Description]	Creates dialog to ask user to input a subject code

\item[Usage]
\begin{verbatim}
GetSubNum(<win>)
\end{verbatim}

\item[Example]

\begin{verbatim}
## Put this at the beginning of an experiment, 
## after a window gWin has been defined.
##
 if(gSubNum == 0)
  {
    gSubNum <- GetSubNum(gWin)
  }
\end{verbatim}
Note: gSubNum can also be set from the command line.
\item[See Also]
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetSystemType()+

\item[Description]	Returns a string identify what type of computer system you are using. It will return either: OSX, LINUX, or WINDOWS.

\item[Usage]
\begin{verbatim}
GetSystemType()
\end{verbatim}

\item[Example]

\begin{verbatim}
## Put this at the beginning of an experiment, 
## after a window gWin has been defined.
   if(GetSystemType() == "WINDOWS")
    {
      SignalFatalError("Experiment untested on windows")
    }

\end{verbatim}

\item[See Also]
  \verb+SystemCall()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetText()+

\item[Description]	Returns the text stored in a text object 
		(either a textbox or a label).  The .text properties can also
  be used instead of this function.

\item[Usage]
\begin{verbatim}
GetText(<widget>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+SetCursorPosition()+, \verb+GetCursorPosition()+, \verb+SetEditable()+, \verb+MakeTextBox()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetTextBoxCursorFromClick()+

\item[Description]	Returns the position (in characters) corresponding to a x,y click on a text box.  The X,Y position must be relative to the x,y position of the box, not absolute.  Once obtained, the cursor position can be set with SetCursorPosition().

\item[Usage]
\begin{verbatim}
GetTextBoxCursorFromClick(<widget>,<x>,<y>)
\end{verbatim}

\item[Example]	
\small
\begin{verbatim}
   win <- MakeWindow()
   tb <- EasyTextBox("Click here to set cursor position"
           ,100,100,win,200,200)
   Draw()
   WaitForClickOnTarget([tb],[1])
    #get the x and y cursor positions
   relx <- First(gClick) - (tb.x )
   rely <- Second(gClick) - (tb.y )
   tb.cursorpos <- GetTextBoxCursorFromClick(tb,
                                             relx,rely))
   Draw()
   WaitForAnyKeyPress()
\end{verbatim}
\normalsize
\item[See Also]	\verb+SetCursorPosition()+, \verb+GetCursorPosition()+, \verb+SetEditable()+, \verb+MakeTextBox()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetTime()+

\item[Description] Gets time, in milliseconds, from when PEBL was
  initialized.  Do not use as a seed for the RNG, because it will tend
  to be about the same on each run. Instead, use \verb+RandomizeTimer()+.

\item[Usage]
\begin{verbatim}
GetTime()
\end{verbatim}

\item[Example]
\begin{verbatim}
a <- GetTime()
WaitForKeyDown("A")
b <- GetTime()
Print("Response time is: " + (b - a))
\end{verbatim}

\item[See Also]	\verb+TimeStamp()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetVideoModes()+

\item[Description] Gets a list of useable video modes (in width/height pixel pairs), as supplied by the video driver.

\item[Usage]
\begin{verbatim}
  modes <- GetVideoModes()
\end{verbatim}

\item[Example]
\begin{verbatim}
Print(GetVideoModes)
##Might return:
[[1440, 900]
, [1360, 768]
, [1152, 864]
, [1024, 768]
, [960, 600]
, [960, 540]
, [840, 525]
, [832, 624]
, [800, 600]
, [800, 512]
, [720, 450]
, [720, 400]
, [700, 525]
]
\end{verbatim}

\item[See Also]	
\verb+GetCurrentScreenResolution+, \verb+gVideoWidth+,\verb+gVideoHeight+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+GetVocalResponseTime+

\item[Description] This is a simple audio amplitude voice key controlled by two parameters  \emph{ONLY AVAILABLE ON WINDOWS AND LINUX}.

\item[Usage]
\begin{verbatim}
GetVocalResponseTime(buffer, 
                     timethreshold,
                     energythreshold)
\end{verbatim}
This is a simple function that fairly reliably gets an audio response time.  It works by recording audio to a buffer, and computing energy for 1-ms bins.  When enough bins (whose number/duration is set by timethreshold) in a row surpass an energy threshold (scaled from 0 to 1, set by energythreshold), recording will stop, and the voice key will return.  Reasonable values depend on the amount of noise in your microphone, and the types of vocal responses being made.  The return time will lag the detection time a bit, and so using the time it takes for the function to return is an unreliable measure of vocal response time.


It returns a list of three elements:

\begin{itemize}
\item Response time (in ms),
\item End time (using ms counter),
\item Responded flag: either 0 or 1, depending on whether the key was tripped,
\end{itemize}

If the responded flag is 0, the other two numbers will be as well.

See number-stroop.pbl in the stroop directory of the test battery and testaudioin.pbl in demo/ for examples.


\item[Example]	
\begin{verbatim}

  buffer <- MakeAudioInputBuffer(5000)
  resp0 <-  GetVocalResponseTime(buffer,.35, 200)
  SaveAudioToWaveFile("output.wav",buffer)
  
\end{verbatim}
\item[See Also] 	\verb+MakeAudioInputBuffer()+, \verb+SaveAudioToWaveFile()+,
\end{desc}




\vfill
\newpage
\sect{H}
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Hide()+ 

\item[Description]	Makes an object invisible, so it will not be drawn.

\item[Usage]
\begin{verbatim}
Hide(<object>)
\end{verbatim}

\item[Example]
\begin{verbatim}
window <- MakeWindow()
image1  <- MakeImage("pebl.bmp")
image2  <- MakeImage("pebl.bmp")
AddObject(image1, window)
AddObject(image2, window)
Hide(image1)
Hide(image2)
Draw()		# empty screen will be drawn.
	
Wait(3000)
Show(image2)
Draw()		# image2 will appear.

Hide(image2)
Draw()		# image2 will disappear.

Wait(1000)
Show(image1)
Draw()		# image1 will appear.
\end{verbatim}
 
\item[See Also]	\verb+Show()+
\end{desc}

\vfill
\newpage
\sect{I}
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+if+ 

\item[Description]	Simple conditional test.

\item[Usage]
\begin{verbatim}
if(test)
{
 statements
 to
 be 
 executed
}
\end{verbatim}

\item[Example]	

\item[See Also]	
\end{desc}

\vfill

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+if...elseif...else+            

\item[Description] Complex conditional test.  Be careful of spacing
  the else---if you put carriage returns on either side of it, you
  will get a syntax error. The \verb+elseif+ is optional, but
  multiple \verb+elseif+ statements can be strung together.  The
  \verb+else+ is also optional, although only one can appear.

\item[Usage]
\begin{verbatim}
if(test)
{
 statements if true
} elseif (newtest) {
 statements if newtest true; test false
} else {
 other statements
} 
\end{verbatim}

\item[Example]	
\begin{verbatim}
 if(3 == 1) {
             Print("ONE")
  }elseif(3==4){
             Print("TWO")
  }elseif(4==4){
             Print("THREE")
  }elseif(4==4){
             Print("FOUR")
  }else{Print("FIVE")}
\end{verbatim}
\item[See Also]	
if
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Insert()+

\item[Description] Inserts an element into a list at a specified
  position, returning the new list. The original list in unchanged.

\item[Usage]	
\begin{verbatim}
Insert(<[list]>,<item>,<position>)	
\end{verbatim}
\item[Example]	

\begin{verbatim}
  x <- [1,2,3,5]
  y <- Insert(x,1,4)  
  ##y== [1,2,3,1,5]  
\end{verbatim}

\item[See Also]	
\verb+List()+, \verb+Merge+, \verb+Append+

\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Inside()+

\item[Description] Determines whether an \verb+[x,y]+ point is inside another
  object.  Will operate correctly for rectangles, squares, circles,
  textboxes, images, and labels. For custom objects having a function name bound to their .inside property, it will use that function to test for insideness. \verb+[xylist]+ can be a list containing
  [x,y], and if it is longer the other points will be ignored (such as
  the list returned by \verb+WaitForMouseButton()+.  Returns 1 if inside, 0
  if not inside.

\item[Usage]
\begin{verbatim}
Inside(<[xylist]>,<object>)	
\end{verbatim}

\item[Example]	

\begin{verbatim}
      button <- EasyLabel("Click me to continue", 100,100,gWin,12)

      continue <- 1
      while(continue)
      {
         xy <- WaitForMouseButton()
         continue <- Inside(xy,button)
      }
\end{verbatim}

\item[See Also]	
\verb+WaitForMouseButton()+, \verb+GetMouseCursorPosition+, \verb+InsideTB+

\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+InsideTB()+

\item[Description] Determines whether an \verb+[x,y]+ point is inside an object having .x, .y, .width, and .height properties, with .x and .y representing the upper left corner of the object.  This is bound to the .inside property of many custom ui objects.  The \texttt{Inside} function will use the function bound to the .inside property for any custom object having that property, and so this function's use is mainly hidden from users.

\item[Usage]
\begin{verbatim}
InsideTB([x,y],<obj>)	
\end{verbatim}

\item[Example]	

\begin{verbatim}
   pulldown <- MakePulldown(["one","two","three","four"],400-75,300,gWin,12,150,1)

   if(InsideTB([300,300],pulldown))
    {
      Print("INSIDE")
     }
\end{verbatim}

\item[See Also]	
\verb+Inside()+, \verb+MoveObject+ \verb+ClickOn+, \verb+DrawObject+

\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsAnyKeyDown()+

\item[Description]	

\item[Usage]		
\begin{verbatim}
  IsAnyKeyDown()
\end{verbatim}

\item[Example]	

\item[See Also]	
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsAudioOut()+

\item[Description]	Tests whether \verb+<variant>+ is a AudioOut stream.

\item[Usage]
\begin{verbatim}
IsAudioOut(<variant>)
\end{verbatim}

\item[Example]
\begin{verbatim}
if(IsAudioOut(x))
{
 Play(x)
}
\end{verbatim}

\item[See Also] \verb+IsColor()+, \verb+IsImage()+,
  \verb+IsInteger()+, \verb+IsFileStream()+, \verb+IsFloat()+,
  \verb+IsFont()+, \verb+IsLabel()+, \verb+IsList()+,
  \verb+IsNumber()+, \verb+IsString()+, \verb+IsTextBox()+,
  \verb+IsWidget()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsCanvas()+

\item[Description]	Tests whether \verb+<variant>+ is a Canvas widget.

\item[Usage]
\begin{verbatim}
IsCanvas(<variant>)
\end{verbatim}

\item[Example]
\begin{verbatim}
if(IsCanvas(x)
{
   SetPixel(x,10,10,MakeColor("red"))
}
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsImage()+,
  \verb+IsInteger()+, \verb+IsFileStream()+, \verb+IsFloat()+,
  \verb+IsFont()+, \verb+IsLabel()+, \verb+IsList()+,
  \verb+IsNumber()+, \verb+IsString()+, \verb+IsTextBox()+, \verb+IsText()+
  \verb+IsWidget()+, \verb+IsWindow()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsColor()+

\item[Description]	Tests whether \verb+<variant>+ is a Color.

\item[Usage]
\begin{verbatim}
IsColor(<variant>)
\end{verbatim}

\item[Example]
\begin{verbatim}
if(IsColor(x)
{
 gWin <- MakeWindow(x)
}
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsImage()+,
  \verb+IsInteger()+, \verb+IsFileStream()+, \verb+IsFloat()+,
  \verb+IsFont()+, \verb+IsLabel()+, \verb+IsList()+,
  \verb+IsNumber()+, \verb+IsString()+, \verb+IsTextBox()+,
  \verb+IsWidget()+, \verb+IsWindow()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsCustomObject()+

\item[Description]	Tests whether \verb+<variant>+ is a Custom object (created with \verb+MakeCustomObject+.) Return 1 if so, 0 if not.

\item[Usage]
\begin{verbatim}
IsCustomObject(<obj>)
\end{verbatim}

\item[Example]
\begin{verbatim}
if(IsCustomObject(obj)
{
   MoveObject(obj,x,y)
} else {
   Move(obj,x,y)
}
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsImage()+,
  \verb+IsInteger()+, \verb+IsFileStream()+, \verb+IsFloat()+,
  \verb+IsFont()+, \verb+IsLabel()+, \verb+IsList()+,
  \verb+IsNumber()+, \verb+IsString()+, \verb+IsTextBox()+, \verb+IsText()+
  \verb+IsWidget()+, \verb+IsWindow()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsDirectory()+

\item[Description]	Determines whether a named path is a directory.  Returns 1 if it exists and is a directory, and 0 otherwise.
\item[Usage]		
\begin{verbatim}
 IsDirectory(<path>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
 filename <- "data-"+gSubNum+".csv"
 exists <-  FileExists(filename)
  if(exists)
   {
    out <-    IsDirectory(filename)
    Print(out)
   }
\end{verbatim}

\item[See Also]\verb+GetDirectoryListing()+, \verb+FileExists()+,       \verb+IsDirectory()+,        
   \verb+MakeDirectory()+      

\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsImage()+

\item[Description]	Tests whether \verb+<variant>+ is an Image.

\item[Usage]
\begin{verbatim}
IsImage(<variant>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
if(IsImage(x))
{
 AddObject(gWin, x)
}
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsColor()+,
  \verb+IsInteger()+, \verb+IsFileStream()+, \verb+IsFloat()+,
  \verb+IsFont()+, \verb+IsLabel()+, \verb+IsList()+,
  \verb+IsNumber()+, \verb+IsString()+, \verb+IsTextBox()+,
  \verb+IsWidget()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsInteger()+

\item[Description] Tests whether \verb+<variant>+ is an integer type.
  Note: a number represented internally as a floating-point type whose
  is an integer will return false.  Floating-point numbers can be
  converted to internally- represented integers with the
  \verb+ToInteger()+ or \verb+Round()+ commands.
 
\item[Usage]		
\begin{verbatim}
IsInteger(<variant>)
\end{verbatim}

\item[Example]
\begin{verbatim}
x <- 44
y <- 23.5
z <- 6.5
test <- x + y + z 
	
IsInteger(x)		# true
IsInteger(y)		# false
IsInteger(z)		# false
IsInteger(test)		# false
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsColor()+,
  \verb+IsImage()+, \verb+IsFileStream()+, \verb+IsFloat()+,
  \verb+IsFont()+, \verb+IsLabel()+, \verb+IsList()+,
  \verb+IsNumber()+, \verb+IsString()+, \verb+IsTextBox()+,
  \verb+IsWidget()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsFileStream()+

\item[Description]	Tests whether \verb+<variant>+ is a FileStream object.

\item[Usage]		
\begin{verbatim}
IsFileStream(<variant>)
\end{verbatim}

\item[Example]
\begin{verbatim}
if(IsFileStream(x))
{
 Print(FileReadWord(x)
}
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsColor()+,
  \verb+IsImage()+, \verb+IsInteger()+, \verb+IsFloat()+,
  \verb+IsFont()+, \verb+IsLabel()+, \verb+IsList()+,
  \verb+IsNumber()+, \verb+IsString()+, \verb+IsTextBox()+,
  \verb+IsWidget()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsFloat()+

\item[Description] Tests whether \verb+<variant>+ is a floating-point
  value. Note that floating-point can represent integers with great
  precision, so that a number appearing as an integer can still be a
  float.

\item[Usage]
\begin{verbatim}
IsFloat(<variant>)
\end{verbatim}

\item[Example]
\begin{verbatim}
x <- 44
y <- 23.5
z <- 6.5
test <- x + y + z 

IsFloat(x)     	# false
IsFloat(y)     	# true
IsFloat(z)     	# true
IsFloat(test)  	# true
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsColor()+,
  \verb+IsImage()+, \verb+IsInteger()+, \verb+IsFileStream()+,
  \verb+IsFont()+, \verb+IsLabel()+, \verb+IsList()+,
  \verb+IsNumber()+, \verb+IsString()+, \verb+IsTextBox()+,
  \verb+IsWidget()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsFont()+

\item[Description]	Tests whether \verb+<variant>+ is a Font object.

\item[Usage]
\begin{verbatim}
IsFont(<variant>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
if(IsFont(x))
{
 y <- MakeLabel("stimulus", x)
}
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsColor()+,
  \verb+IsImage()+, \verb+IsInteger()+, \verb+IsFileStream()+,
  \verb+IsFloat()+, \verb+IsLabel()+, \verb+IsList()+,
  \verb+IsNumber()+, \verb+IsString()+, \verb+IsTextBox()+,
  \verb+IsWidget()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsKeyDown()+

\item[Description]	

\item[Usage]		

\item[Example]	

\item[See Also]	\verb+IsKeyUp()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsKeyUp()+

\item[Description]	

\item[Usage]		

\item[Example]	

\item[See Also]	\verb+IsKeyDown()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsLabel()+

\item[Description]	Tests whether \verb+<variant>+ is a text Label object.

\item[Usage]		
\begin{verbatim}
IsLabel(<variant>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
if(IsLabel(x)
{
 text <- GetText(x)
}
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsColor()+,
  \verb+IsImage()+, \verb+IsInteger()+, \verb+IsFileStream()+,
  \verb+IsFloat()+, \verb+IsFont()+, \verb+IsList()+,
  \verb+IsNumber()+, \verb+IsString()+, \verb+IsTextBox()+,
  \verb+IsWidget()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsList()+

\item[Description]	Tests whether \verb+<variant>+ is a PEBL list.

\item[Usage]
\begin{verbatim}
IsList(<variant>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
if(IsList(x))
{
 loop(item, x)
 {
  Print(item)
 }
}
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsColor()+,
  I\verb+sImage()+, \verb+IsInteger()+, \verb+IsFileStream()+,
  \verb+IsFloat()+, \verb+IsFont()+, \verb+IsLabel()+,
  \verb+IsNumber()+, \verb+IsString()+, \verb+IsTextBox()+,
  \verb+IsWidget()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsMember()+

\item[Description]	Returns true if \verb+<element>+ is a member of \verb+<list>+.

\item[Usage]		
\begin{verbatim}
IsMember(<element>,<list>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
IsMember(2,[1,4,6,7,7,7,7])		# false
IsMember(2,[1,4,6,7,2,7,7,7]) 		# true
\end{verbatim}

\item[See Also]	
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsNumber()+

\item[Description]	Tests whether \verb+<variant>+ is a number, either a
		floating-point or an integer.

\item[Usage]		
\begin{verbatim}
IsNumber(<variant>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
if(IsNumber(x))
{
 Print(Sequence(x, x+10, 1))
}
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsColor()+,
  \verb+IsImage()+, \verb+IsInteger()+, \verb+IsFileStream()+,
  \verb+IsFloat()+, \verb+IsFont()+, \verb+IsLabel()+,
  \verb+IsList()+, \verb+IsString()+, \verb+IsTextBox()+,
  \verb+IsWidget()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsShape+

\item[Description]	Tests whether \verb+<variant>+ is a drawable
  shape, such as a circle, square rectangle, line, bezier curve, or
  polygon.


\item[Usage]		
\begin{verbatim}
IsShape(<variant>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
if(IsShape(x))
{
  Move(x,300,300)
}
\end{verbatim}

\item[See Also]	\verb+Square()+, \verb+Circle()+,
  \verb+Rectangle()+, \verb+Line()+, \verb+Bezier()+, \verb+Polygon()+ 
 \verb+IsAudioOut()+, \verb+IsColor()+,
  \verb+IsImage()+, \verb+IsInteger()+, \verb+IsFileStream()+,
  \verb+IsFloat()+, \verb+IsFont()+, \verb+IsLabel()+,
  \verb+IsList()+, \verb+IsNumber()+, \verb+IsString()+,
  \verb+IsTextBox()+, \verb+IsWindow()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsString()+

\item[Description]	Tests whether \verb+<variant>+ is a text string.

\item[Usage]		
\begin{verbatim}
IsString(<variant>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
if(IsString(x))
{
 tb <- MakeTextBox(x, 100, 100)
}
\end{verbatim}

\item[See Also] \verb+IsText()+	\verb+IsAudioOut()+, \verb+IsColor()+, \verb+IsImage()+, \verb+IsInteger()+, 
		\verb+IsFileStream()+, \verb+IsFloat()+, \verb+IsFont()+, \verb+IsLabel()+,
		\verb+IsList()+, \verb+IsNumber()+, \verb+IsTextBox()+, \verb+IsWidget()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsText()+

\item[Description]	Tests whether \verb+<variant>+ is a text string.
  Same as IsString().

\item[Usage]		
\begin{verbatim}
IsString(<variant>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
if(IsText(x))
{
 tb <- MakeTextBox(x, 100, 100)
}
\end{verbatim}

\item[See Also] \verb+IsString()+	\verb+IsAudioOut()+, \verb+IsColor()+, \verb+IsImage()+, \verb+IsInteger()+, 
		\verb+IsFileStream()+, \verb+IsFloat()+, \verb+IsFont()+, \verb+IsLabel()+,
		\verb+IsList()+, \verb+IsNumber()+, \verb+IsTextBox()+, \verb+IsWidget()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsTextBox()+

\item[Description]	Tests whether \verb+<variant>+ is a TextBox Object

\item[Usage]
\begin{verbatim}
IsTextBox(<variant>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
if(IsTextBox(x))
{
 Print(GetText(x))
}
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsColor()+,
  \verb+IsImage()+, \verb+IsInteger()+, \verb+IsFileStream()+,
  \verb+IsFloat()+, \verb+IsFont()+, \verb+ IsLabel()+,
  \verb+IsList()+, \verb+IsNumber()+, \verb+IsString()+,
  \verb+IsWidget()+
\end{desc}
\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsWidget+

\item[Description]	Tests whether \verb+<variant>+ is any kind of a widget object
		(image, label, or textbox).

\item[Usage]		
\begin{verbatim}
IsWidget(<variant>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
if(IsWidget(x))
{
 Move(x, 200,300)
}
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsColor()+,
  \verb+IsImage()+, \verb+IsInteger()+, \verb+IsFileStream()+,
  \verb+IsFloat()+, \verb+IsFont()+, \verb+IsLabel()+,
  \verb+IsList()+, \verb+IsNumber()+, \verb+IsString()+,
  \verb+IsTextBox()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+IsWindow+

\item[Description]	Tests whether \verb+<variant>+ is a window.

\item[Usage]		
\begin{verbatim}
IsWindow(<variant>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
if(IsWindow(x))
{
  AddObject(y,x)
}
\end{verbatim}

\item[See Also] \verb+IsAudioOut()+, \verb+IsColor()+,
  \verb+IsImage()+, \verb+IsInteger()+, \verb+IsFileStream()+,
  \verb+IsFloat()+, \verb+IsFont()+, \verb+IsLabel()+,
  \verb+IsList()+, \verb+IsNumber()+, \verb+IsString()+,
  \verb+IsTextBox()+
\end{desc}


\vfill
\newpage
\sect{K}
\vfill
\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+KaniszaPolygon+

\item[Description]	Creates generic polygon, defined only by with ``pac-man'' circles at specified vertices.  


\item[Usage]	
\begin{verbatim}
   KaniszaPolygon(<xypoints>, <vertices-to-show>,
                  <circle-size>, <fgcol>, <bgcol>, 
                  <show-edge>)
\end{verbatim}

\includegraphics[scale=.5]{images/kaniszapoly.png}
\item[Example]	
For detailed usage example, see:\\ \verb+http://peblblog.blogspot.com/2010/11/kanizsa-shapes.html+
Part of a script using KaniszaPolygon:	
\begin{verbatim}
   #Specify the xy points
   xys <- [[10,10],[10,50],[130,60],[100,100],[150,100],
           [150,20],[80,-10],[45,10]]
    
    #Specify which vertices to show (do all)
    show <- [1,1,1,1,1,1,1,1]
     
    #Make one, showing the line
    x <-  KaniszaPolygon(xys,show,10,fg,bg,1)
    AddObject(x,gWin);   Move(x,200,200)

    #Make a second, not showing the line
    x2 <-  KaniszaPolygon(xys,show,10,fg,bg,0)
    AddObject(x2,gWin);   Move(x2,400,200)

    #Make a third, only showing some vertices:
    x3 <-  KaniszaPolygon(xys,[1,1,1,1,1,0,0,1],10,fg,bg,0)
    AddObject(x3,gWin);  Move(x3,600,200)
        
\end{verbatim}


\item[See Also] \verb+Polygon()+, \verb+KaneszaSquare()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+KaniszaSquare+

\item[Description]	Creates generic Kanesza Square, one defined only by with ``pac-man'' circles at its vertices:  

\includegraphics[scale=.5]{images/kaniszasquare.png} 
 

\item[Usage]	
\begin{verbatim}
   KaniszaSquare(<size>, <circ-rad>,<fgcol>, <bgcol>)
\end{verbatim}
KaniszaSquare creates a graphical object that can be added to a window, moved to the proper location, etc.  Parameters specify the size of the square, the size of the vertex circles, and the foreground and background colors.

\item[Example]	
For detailed usage example, see
\verb+http://peblblog.blogspot.com/2010/11/kanizsa-shapes.html+
	
\begin{verbatim}

   gWin <- MakeWindow()
   square <- KaniszaSquare(150,20,MakeColor("red"),
                                  MakeColor("green"))
   AddObject(square,gWin)
   Move(square,200,200)
   Draw()
   WaitForAnyKeyPress()

\end{verbatim}
  


\item[See Also] \verb+Polygon()+, \verb+KaneszaPolygon()+
\end{desc}

\vfill
\newpage
\sect{L}
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Last()+

\item[Description]	Returns the last item in a list. Provides faster 
		access to the last item of a list than does Nth().

\item[Usage]
\begin{verbatim}
Last(<list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Last([1,2,3,444])	# == 444
\end{verbatim}

\item[See Also]	\verb+Nth()+, \verb+First()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+LatinSquare()+

\item[Description]	Quick and dirty latin square, taking on just one
  list argument.

\item[Usage]
\begin{verbatim}
LatinSquare(<list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Print(LatinSquare([11,12,13,14,15,16]))
# Output:
#[[11, 12, 13, 14, 15, 16]
#, [12, 13, 14, 15, 16, 11]
#, [13, 14, 15, 16, 11, 12]
#, [14, 15, 16, 11, 12, 13]
#, [15, 16, 11, 12, 13, 14]
#, [16, 11, 12, 13, 14, 15]
#]

\end{verbatim}

\item[See Also] \verb+DesignFullCounterBalance()+,
  \verb+DesignBalancedSampling()+, \verb+DesignGrecoLatinSquare()+,
  \verb+DesignLatinSquare()+, \verb+Repeat()+, \verb+RepeatList()+,
  \verb+Shuffle()+

\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+LaunchFile()+

\item[Description]	Launch a specified file or URI with a platform-specific handler.

\item[Usage]
\begin{verbatim}
LaunchFile("filename")
\end{verbatim}

\item[Example]
Example uses:
\begin{verbatim}

#open google:
LaunchFile("http://google.com")    
#Open a .pbl file with text editor:
LaunchFile("test.pbl")             
#Open a data directory in file manager:
LaunchFile("data\")                
\end{verbatim}

\item[See Also] 
  \verb+SystemCall()+

\end{desc}



\begin{desc}{Name/Symbol}
   
\item[Name/Symbol] \verb+LayoutGrid+

\item[Description]      Creates a grid of x,y points in a range, that are 
spaced in a specified number of rows and columns.  Furthermore, you can specify
whether they are vertical or horizontally laid out.

\item[Usage]       
\verb+LayoutGrid(<xmin>,<xmax>,<ymin>,<ymax>,<culumns>,<rows>,<vertical>)+

\item[Example]

Example PEBL Program using NonoverlapLayout:
\begin{verbatim}
define Start(p)
{
   gWin <- MakeWindow()
   gVideoWidth <- 800
   gVideoHeight <- 300

   lab1 <- EasyLabel("LayoutGrid, horizontal",
                     200,25,gWin,24)
   lab2 <- EasyLabel("LayoutGrid, vertical",
                     600,25,gWin,24)
   nums <- Sequence(1,20,1)
   stim1 <- []
   stim2 <- []

   font <- MakeFont(gPeblBaseFont,0,25,
              MakeColor("black"),MakeColor("white"),0)
   loop(i,nums)
   {
     stim1 <- Append(stim1,MakeLabel(i+"",font))
     stim2 <- Append(stim2,MakeLabel(i+"",font))
    }

  layout1 <- LayoutGrid(50,gVideoWidth/2-50,
                       50,gVideoHeight-50,5,4,0)
  layout2 <- LayoutGrid(gVideoWidth/2+50,gVideoWidth-50,
                       50,gVideoHeight-50,5,4,1)


  ##Now, layout the stuff.

  loop(i,Transpose([stim1,layout1]))
   {	
      obj <- First(i)
      xy <- Second(i)
      AddObject(obj,gWin)
      Move(obj, First(xy),Second(xy))
   }

  loop(i,Transpose([stim2,layout2]))
   {	
      obj <- First(i)
      xy <- Second(i)
      AddObject(obj,gWin)
      Move(obj, First(xy),Second(xy))
   }

  Draw()
  WaitForAnyKeyPress()
}
\end{verbatim}

The output of the above program is shown below.  Even for the left configuration, which is too compact (and which takes a couple seconds to run), the targets are fairly well distributed.
\includegraphics[scale=.35]{images/LayoutGrid.png} 

\item[See Also]     
\verb+NonOverlapLayout()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Line()+

\item[Description] Creates a line for graphing at x,y ending at x+dx,
  y+dy.  dx and dy describe the size of the line.  Lines must be added
  to a parent widget before it can be drawn; it may be added to
  widgets other than a base window. Properties of lines may be
  accessed and set later.

\item[Usage]
\begin{verbatim}
Line(<x>, <y>, <dx>, <dy>, <color>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  l <- Line(30,30,20,20, MakeColor("green")
  AddObject(l, win)
  Draw()

\end{verbatim}
\item[See Also]	\verb+Square()+, \verb+Ellipse()+, \verb+Rectangle()+, \verb+Circle()+
\end{desc}
\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+List()+

\item[Description]	Creates a list of items. Functional version of \verb+[]+.

\item[Usage]
\begin{verbatim}
List(<item1>, <item2>, ....)
\end{verbatim}

\item[Example]
\begin{verbatim}
List(1,2,3,444)		# == [1,2,3,444]
\end{verbatim}

\item[See Also]	\verb+[ ]+, \verb+Merge()+, \verb+Append()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+ListBy()+

\item[Description]	organizes a list into sublists, based on the
  elements of a second list.  It returns a list of two entities: (1) a
  condition list, describing what values were aggregated across; (2)
  the nested list elements.  The length of each element should be the same.

Together with Match and Filter, ListBy is useful for aggregating data across blocks and conditions for immediate feedback.

\item[Usage]
\begin{verbatim}
ListBy(<list>, <conds>)
\end{verbatim}

\item[Example]
\begin{verbatim}

	a <- Sequence(1,10,1)
    b <- RepeatList([1,2],5)
    x <- ListBy(a,b)
    Print(x)
#[[1, 2],
#  [[1, 3, 5, 7, 9],
#   [2, 4, 6, 8, 10]]
#]

    Print(ListBy(b,a))
#[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
# [[1], [2], [1], [2], [1], [2], [1], [2], [1], [2]]]

\end{verbatim}

\item[See Also]	\verb+List()+, \verb+[ ]+, \verb+Merge()+, \verb+Append()+
\end{desc}
 
\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+ListToString()+

\item[Description]	Converts a list of things to a single string

\item[Usage]
\begin{verbatim}
  ListToString(<list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
ListToString([1,2,3,444])		# == "123444"
ListToString(["a","b","c","d","e"])		# == "abcde"

\end{verbatim}

\item[See Also] \verb+SubString+, \verb+StringLength+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Length()+

\item[Description]	Returns the number of items in a list.

\item[Usage]
\begin{verbatim}
Length(<list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Length([1,3,55,1515])	# == 4
\end{verbatim}

\item[See Also]	\verb+StringLength()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Levels()+

\item[Description]	Returns sorted list of unique elements of a list.

\item[Usage]
\begin{verbatim}
Levels(<list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Levels([1,3,55,1,5,1,5])	# == [1,3,5,55]
\end{verbatim}

\item[See Also]	\verb+Match()+, \verb+Filter()+, \verb+Sort()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+LoadAudioFile()+
 
\item[Description] Loads an audio file supported by  the ffmpeg library.  It is nearly identical to
LoadMovie(), but only works for audio files (.ogg, .mp3, .wav, .aiff, .wma, et.).  It creates a movie
object, which can then be played using PlayMovie() or StartPlayback() functions.  Currently,
only supported on Windows and Linux.

The ffmpeg (\verb+http://ffmpeg.org+) library supports a wide range of audio formats,
including most .wav, .mp3, .ogg, .flac, .aiff, .wma, and others.   Currently, there appears to sometimes
be playback problems if the audio stream is not stereo, so be sure to convert your audio to stereo.
Also, there appears to be some problems with .flac data formats.

If you have problems with playback, 
you should verify that your media file loads with another ffmpeg media player.

\item[Usage]		
\begin{verbatim}
LoadAudioFile(audiofile)
\end{verbatim}

\item[Example]	
\begin{verbatim}
   movie <- LoadAudioFile("instuctions.mp3")
   PrintProperties(inst)
   PlayMovie(inst)
   PausePlayback(insnt)
\end{verbatim}

\item[See Also]  \verb+LoadMovie()+, \verb+PlayMovie()+,\verb+StartPlayback()+ \verb+PausePlayback()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+LoadMovie()+
 
\item[Description] Loads a movie file using the ffmpeg library.  It creates a movie
object, which can then be played using PlayMovie() or StartPlayback() functions.  Currently,
only supported on Windows and Linux.

The ffmpeg (\verb+http://ffmpeg.org+) library supports a wide range of video and audio formats,
including most .mpg, .avi, .ogg and .mp3 type formats.  Audio-only formats should load
and play with LoadMovie, but another function, LoadAudioFile(), has been created for these,
as they do not need to be added to a window to work.

If you have problems with playback, 
you should verify that your media file loads with another ffmpeg media player.

For technical reasons, a movie MUST be loaded directly onto a window, and not another widget.

\item[Usage]		
\begin{verbatim}
LoadMovie(movie,window, width, height)
\end{verbatim}

\item[Example]	
\begin{verbatim}
   movie <- LoadMovie("movie.avi",gWin,640,480)
   PrintProperties(movie)
   Move(movie,20,20)
   Draw() 
   StartPlayback(movie)
   Wait(500) #Play 500 ms of the movie.
   PausePlayback(movie)
\end{verbatim}

\item[See Also] \verb+LoadAudioFile()+, \verb+LoadMovie()+, \verb+PlayMovie()+,\verb+StartPlayback()+ \verb+PausePlayback()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+LoadSound()+

\item[Description]	Loads a soundfile from \verb+<filename>+, 
returning a variable that can be played using the PlayForeground or PlayBackground functions.
\texttt{LoadSound} only loads uncompressed .wav files, but uses a background mixer to play them with fairly low latency.  
In contrast, LoadAudioFile can load many different multimedia files other than .wav, and uses a different audio playback mechanism.  LoadSound
is appropriate for playing stimulus sounds and feedback, whereas LoadAudioFile may be more appropriate for instructions and longer feedback that should be 
encoded efficiently.

When the file gets loaded, it gets automatically transcoded into a stereo 44100-sampling rate audio stream, regardless of its original
playback rate.  We have reports that in some cases, this can cause some problems, especially if a mono file
gets loaded multiple times in an experiment. If you experience playback problems, try converting your audio to 
stereo 44100 hz and see if it helps.

\item[Usage]
\begin{verbatim}
LoadSound(<filename>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  woof   <- LoadSound("dog.wav")
  PlayBackground(woof)
  Wait(200)
  Stop(woof)
  PlayForeground(woof)
\end{verbatim}

\item[See Also]	
\verb+PlayForeground+, \verb+PlayBackground+, \verb+LoadAudioFile+, \verb+LoadMovie+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Log10()+

\item[Description]	Log base 10 of \verb+<num>+.

\item[Usage]
\begin{verbatim}
Log10(<num>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+Log2()+, \verb+LogN()+, \verb+Ln()+, \verb+Exp()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Log2()+

\item[Description]	Log base 2 of \verb+<num>+.

\item[Usage]
\begin{verbatim}
Log2(<num>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+Log()+, \verb+LogN()+, \verb+Ln()+, \verb+Exp()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+LogN()+

\item[Description]	Log base \verb+<base>+ of \verb+<num>+.

\item[Usage]
\begin{verbatim}
LogN(<num>, <base>)
\end{verbatim}

\item[Example]
\begin{verbatim}
LogN(100,10)	# == 2
LogN(256,2)	# == 8
\end{verbatim}

\item[See Also]	\verb+Log()+, \verb+Log2()+, \verb+Ln()+, \verb+Exp()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Lowercase()+

\item[Description]	Changes a string to lowercase.  Useful for testing user
		input against a stored value, to ensure case differences
		are not detected.

\item[Usage]
\begin{verbatim}
Lowercase(<string>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Lowercase("POtaTo")	# == "potato"
\end{verbatim}

\item[See Also]	\verb+Uppercase()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Ln()+

\item[Description]	Natural log of \verb+<num>+.

\item[Usage]		
\begin{verbatim}
Ln(<num>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+Log()+, \verb+Log2()+, \verb+LogN()+, \verb+Exp()+     
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Lookup()+

\item[Description] Returns
element in \verb+<database>+ corresponding to element of
\verb+<keylist>+ that matches \verb+<key>+.

If no match exists, Match returns an empty list.
\item[Usage]		
\begin{verbatim}
Lookup(<key>,<keylist>,<database>)
\end{verbatim}

\item[Example]	

\begin{verbatim}
 keys     <- [1,2,3,4,5]
 database <- ["market","home","roast beef",
              "none","wee wee wee"]
 Print(Lookup(3,keys,database))) 

## Or, do something like this:
  
data  <- [["punky","brewster"],
          ["arnold","jackson"],
          ["richie","cunningham"],
          ["alex","keaton"]]

d2 <- Transpose(data)
key <- First(data)

Print(Lookup("alex", key, data))
##Returns ["alex","keaton"]
\end{verbatim}
\item[See Also]	\verb+Match+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+loop()+

\item[Description]	Loops over elements in a list.  During each iteration, \verb+<counter>+ is bound to each consecutive member of \verb+<list>+.

\item[Usage]		
\begin{verbatim}
loop(<counter>, <list>)
{
 statements
 to
 be	   
 executed
}
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+while()+, \verb+{ }+
\end{desc}

\vfill
\newpage
\sect{M}
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeAttneave()+

\item[Description] Makes a random 'Attneave' figure\footnote{(Collin, C. A., \& Mcmullen, P. A. (2002). Using Matlab to generate  families of similar Attneave shapes. Behavior Research Methods
 Instruments and Computers, 34(1), 55-68.).}. An Attneave figure is a complex polygon that can be used as a
stimulus in a number of situations.  It returns a sequence
of points for use in Polygon().

{\centering
\includegraphics[scale=.5]{images/attneave.png}
}
\\

MakeAttneave uses ConvexHull,  InsertAttneavePointRandom() and
ValidateAttneaveShape(), found in Graphics.pbl.  Override these
to change constraints such as  minimum/maximum side
lengths, angles, complexity, etc.

MakeAttneave uses a sampling-and-rejection scheme to create in-bounds
shapes.  Thus, if you specify impossible or nearly-impossible
constraints, the time necessary to create shapes may be very long or
infinite.

 The arguments to MakeAttneave are:
\begin{itemize}
\item size: size, in pixels, of a circle from which points are
  sampled in a uniform distribution. 
\item numpoints: number of points in the polygon.
\item minangle: smallest angle acceptable (in degrees).
\item maxangle: largest angle acceptable  (in degrees).
\end{itemize}

\item[Usage]
\begin{verbatim}
  MakeAttneave(size,numpoints,minangle,maxangle)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  gWin <- MakeWindow()
  shape <- MakeAttneave(100,5+RandomDiscrete(5),5,170)
  pts <- Transpose(shape)
  poly <- Polygon(200,200,First(pts),Second(pts),
                  MakeColor("blue"),1)
  AddObject(poly,gWin)
  Draw()
  WaitForAnyKeyPress()
\end{verbatim}
\item[See Also]	\verb+MakeImage()+, \verb+Polygon()+, \verb+Square()+
\end{desc}






\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeAudioInputBuffer(<time-in-ms>)+

\item[Description] Creates a sound buffer to use for audio recording or voicekey sound input.  It is currently very simple, allowing only to set the duration.  By default, it record mono at 44100 hz.

\item[Usage]
\begin{verbatim}
MakeAudioInputBuffer(<time-in-ms>)
\end{verbatim}

See number-stroop.pbl in the stroop directory of the test battery for examples.

Note: Version 0.12 seems to have some trouble specifying buffers of different lengths.  5000 seems to work, but others (3500?) may not.
\item[Example]	
\begin{verbatim}

  buffer <- MakeAudioInputBuffer(5000)
  resp0 <-  GetVocalResponseTime(buffer,.35, 200)
  SaveAudioToWaveFile("output.wav",buffer)
  
\end{verbatim}
\item[See Also] 	\verb+GetVocalResponseTime()+, \verb+SaveAudioToWaveFile()+,
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+MakeButton()+

\item[Description]	
Creates a button on a window that can be clicked and launches actions. The button is always 20 pixels high (using images in media\\images), with a rounded grey background.  The label text will be shrunk to fit the width, although this should be avoided as it can look strange.
A button is a custom object made from images and text. It has a property 'clickon' that is bound to 'PushButton'

A button will look like this:\\
 \includegraphics{images/buttons.png}

\item[Usage]
\begin{verbatim}
 MakeButton(label,x,y,window,width)
 \end{verbatim}

\item[Example]      	
The following creates a button, waits for you to click on it, and animates a button press

\begin{verbatim}
 done <- MakeButton("QUIT",400,250,gWin,150)
 resp <- WaitForClickOntarget([done],[1])
 CallFunction(done.clickon,[done,gClick]) 

\end{verbatim}

\item[See Also]	\verb+PushButton()+, \verb+MakeCheckBox()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeCanvas()+

\item[Description] Makes a canvas object  \verb+<x>+ pixels by
  \verb+y+ pixels, in color \verb+<color>+.

A canvas is an object that other objects can be attached to, and imprinted upon.
When the canvas gets moved, the attached objects move as well. The background of a canvas can be
made invisible by using a color with alpha channel == 0. The Setpixel
and SetPoint functions let you change individual pixels on a canvas,
to enable adding noise, drawing functional images, etc. A canvas gets
'cleared' by calling ResetCanvas(canvas). Any object added to a canvas creates an 'imprint' on the canvas that
remains if the object is moved.  This allows you to use another image
as a paintbrush on the canvas, and lets you to add noise to text.
Because a text label gets re-rendered when its drawn, if you want to
add pixel noise to a stimulus, you can create a label, add it to a
canvas, then add pixel noise to the canvas.

\item[Usage]
\begin{verbatim}
MakeCanvas(<x>, <y>, <color>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  gWin <- MakeWindow()
  clear <- MakeColor("white")
  clear.alpha <- 0
  #make a transparent canvas:
  x <- MakeCanvas(300,300,clear)  
  AddObject(x,gWin)
  Move(x,300,300)
  img <- MakeImage("pebl.png")
  AddObject(img,x)
  Move(img,100,100)
  Draw(x)          #imprint the image on the canvas
  Move(img,100,200)
  Draw(x)          #imprint the image on the canvas
  Hide(img)

  #draw a line on the canvas
   i <- 10
   red <- MakeColor("red")
  while(i < 200)
   {
     SetPixel(x,20,i,red)
     i <- i + 1
   }
  Draw()
  WaitForAnyKeyPress()
\end{verbatim}
\item[See Also]	\verb+MakeImage()+, \verb+SetPixel()+,
  \verb+MakeGabor()+, \verb+ResetCanvas()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+MakeCheckbox()+

\item[Description]	
Creates a checkbox on a window that can be clicked and keeps track of its status. The checkbox uses a MakeButton object as its base.  The checkbox button is always 20 pixels high (using images in media\\images), with a rounded grey background.  The label text will be shrunk to fit the width, although this should be avoided as it can look strange.
It has a property 'clickon' that is bound to \texttt{ClickCheckBox}, which flips its state and updates the graphics. It has a property state which is either 0 or 1, depending on the state of the checkbox. Its initial state is 0. Its state can be set using the \texttt{SetCheckBox()} function.

A checkbox will look like this:\\
 \includegraphics{images/checkbox.png}

\item[Usage]
\begin{verbatim}
 MakeCheckBox(label,x,y,window,width)
 \end{verbatim}

\item[Example]      	
The following creates a button, waits for you to click on it, and animates a button press

\begin{verbatim}
 ok <- MakeCheckbox("OK?",400,250,gWin,150)
 resp <- WaitForClickOnTarget([ok],[1])
 CallFunction(done.clickon,[done,gClick]) 
 Draw()
\end{verbatim}

Alternately:

\begin{verbatim}
 ok <- MakeCheckbox("OK?",400,250,gWin,150)
 resp <- WaitForClickOnTarget([ok],[1])
 ClickCheckBox(done,gClick) 
 Draw()
\end{verbatim}


Examples of its use can be found in demo\\ui.pbl
\item[See Also]	\verb+ClickCheckBox()+, \verb+SetCheckBox()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeColor()+

\item[Description] Makes a color from \verb+<colorname>+ such as
  ``red'', ``green'', and nearly 800 others.  Color names and
  corresponding RGB values can be found in \verb+doc/colors.txt+.

\item[Usage]
\begin{verbatim}
MakeColor(<colorname>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
 green <- MakeColor("green")
 black <- MakeColor("black")
\end{verbatim}
\item[See Also]	\verb+MakeColorRGB()+, \verb+RGBtoHSV()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeColorRGB()+ 

\item[Description] Makes an RGB color by specifying \verb+<red>+,
  \verb+<green>+, and \verb+<blue>+ values (between 0 and 255).

\item[Usage]		
\begin{verbatim}
MakeColorRGB(<red>, <green>, <blue>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+MakeColor()+, \verb+RGBtoHSV()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+MakeCustomObject+ 

\item[Description]  
Creates a 'custom' object that can encapsulate multiple properties. It takes a name as an argument, but this is currently not accessible.
  
\item[Usage]       
     \verb+obj <- MakeCustomObject("mybutton")+ 
\item[Example]

\begin{verbatim}
  obj <- MakeCustomObject("myobject")
  obj.taste <- "buttery"
  obj.texture <- "creamy"
  SetProperty(obj,"flavor","tasty")
  
  list <- GetPropertyList(obj)
  loop(i,list)
   {
     if(PropertyExists(obj,i)
      {
        Print(i  + ":  " + GetProperty(obj,i))
      }
   }

\end{verbatim}


\item[See Also]
\verb+GetPropertyList+, \verb+PropertyExists+, \verb+SetProperty+ \verb+IsCustomObject+, \verb+PrintProperties+ ,\verb+GetProperty+
\end{desc} 


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeDirectory()+

\item[Description]	Creates a directory with a particular name. It will have no effect of the directory already exists.
\item[Usage]		
\begin{verbatim}
 FileExists(<path>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
 #create data subdirectory + subject-specific directory
 MakeDirectory("data")
 MakeDirectory("data/"+gsubnum)
 filename <- "data/"+gsubnum+"/output.csv"
  
\end{verbatim}

\item[See Also]\verb+GetDirectoryListing()+, \verb+FileExists()+,       \verb+IsDirectory()+,        
   \verb+MakeDirectory()+      

\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeFont()+

\item[Description]	Makes a font.  The first argument must be a text
  name of a font.  The font can reside anywhere in PEBL's search path,
  which would primarily include the media/fonts directory, and the
  working directory (where the script is saved).
  \begin{itemize}
  \item  style changes from normal to bold/underline, italic.
  \item    fgcolor and bgcolor need to be colors, not just names of colors
  \item  if show-backing is 0, the font gets rendered with an invisible
  \item    background; otherwise with a bgcolor background. (Note: previous to PEBL 0.11, the final argument = 0 rendered the font  with non anti-aliased background, which I can see almost no use for.)
\end{itemize}
\item[Usage]
\begin{verbatim}
MakeFont(<ttf_filename>, <style>, <size>, 
         <fgcolor>, <bgcolor>, <show-backing>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  font <- MakeFont("Vera.ttf",0,22,MakeColor("black"),
                    MakeColor("white"),1)
\end{verbatim}

\item[See Also]	
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeGabor()+

\item[Description]
Creates a greyscale gabor patch, with seven variables:
\begin{itemize}
\item size (in pixels) of square the patch is drawn on
\item freq: frequency of grating (number of wavelengths in size)
\item sd: standard deviation, in pixels, of gaussian window
\item angle: angle of rotation of grating, in radians
\item phase: phase offset of grating (in radians)
\item bglev: number between 0 and 255 indicating background color in greyscale.
\end{itemize}

{
\center
\includegraphics{images/gabor.png}
}
\item[Usage]

\begin{verbatim}
MakeGabor(<size>,<freq>,<sd>, <angle>,<phase>,<bglev>)
\end{verbatim}
MakeGabor creates a canvas that can be used like any image.  It must be added to the window, placed, and drawn to appear.  Typically, it can take several seconds to create a patch of any large size, so it is usually best to create the gabor patches when the test is initiatialized, or save and load images using WritePNG().

Typically, a sd roughly 1/4 to 1/10 the size of size is necessary to avoid vignetting.

\item[Example]	
\begin{verbatim}
   win <- MakeWindow()
   patch <- MakeGabor(80, 0,10,0,0,100)
   AddObject(patch,win)
   Move(patch,200,200)
   Draw()
   
\end{verbatim}

\item[See Also]	
\verb+MakeAttneave()+, \verb+SetPixel()>+, \verb+MakeCanvas()+ 
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeImage()+

\item[Description]	Makes an image widget from an image file.
		\texttt{.bmp} formats should be supported; others may be as well.

\item[Usage]		
\begin{verbatim}

MakeImage(<filename>)
\end{verbatim}

\item[Example]	

\item[See Also]	
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeLabel()+

\item[Description] Makes a text label for display on-screen. Text will
  be on a single line, and the \verb+Move()+ command centers
  \verb+<text>+ on the specified point.

\item[Usage]
\begin{verbatim}
MakeLabel(<text>, <font>)
\end{verbatim}

\item[Example]	

\item[See Also]	
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+MakeMenu()+

\item[Description]	
Creates a menu containing multiple menu items, that automatically call functions specified by the command.
 \includegraphics{images/menu.png}

\item[Usage]
\begin{verbatim}
 MakeMenu(label,x,y,window,fontsize, width, subitems,functions)
 \end{verbatim}

The subitems list should include the names of the menu options.  The functions list should be the same length, and contain the function names called when one of those items is used. MakeMenu uses MakeMenuItem to create each on of those items.  Menus can only be nested one-deep (no submenus allowed).

\item[Example]      	
This creates a menu and awaits clicking on.  More complete examples are available in ui.pbl.  It requires that MyMessage is created somewhere
\begin{verbatim}

   menu1 <- MakeMenu("File",0,0,gWin,14,10,
              ["Open","Save","Save as","Quit"],
              ["MYMESSAGE","MYMESSAGE","MYMESSAGE","MYMESSAGE"])


   menu2<- MakeMenu("Edit",70,0,gWin,14,10,    
              ["Cut","Copy","Paste","Select"],
              ["MYMESSAGE","MYMESSAGE","MYMESSAGE","MYMESSAGE"])

   menu <- [menu1,menu2]
   opt <- WaitForClickOntarget(menu,[1,2])
   ClickOnMenu(Nth(menu,opt),gClick)
\end{verbatim}

\item[See Also]	\verb+MakeMenuItem()+, \verb+OpenSubMenus()+, \verb+ClickOnMenu+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+MakeMenuItem()+

\item[Description]	
Creates a single menu containing a label, whose .clickon property is bound to some other function.

\item[Usage]
\begin{verbatim}
 MakeMenuItem(label,x,y,window,fontsize, width, function)
 \end{verbatim}
This function is typically not used directly, but rather it is called via \texttt{MakeMenu}. However, it can be used as a quick-and-dirty button.

\item[Example]      	
This creates a menu and awaits clicking on.  More complete examples are available in ui.pbl.  It requires that MyMessage is created somewhere
\begin{verbatim}

   menu1 <- MakeMenuItem("File",0,0,gWin,14,10,"MYMESSAGE")


   menu2<- MakeMenu("Edit",70,0,gWin,14,10, "MYMESSAGE")
   
   menus <- [menu1,menu2]
   opt <- WaitForClickOntarget(menu,[1,2])
   ClickOnMenu(Nth(menus,opt),gClick)
\end{verbatim}

\item[See Also]	\verb+MakeMenu()+, \verb+OpenSubMenus()+, \verb+ClickOnMenu+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeNGonPoints()+

\item[Description] 
Creates a set of points that form a regular n-gon.  It can be
transformed with functions like \verb+RotatePoints+, or it can be 
used to create a graphical object with \verb+Polygon+.

Note: \verb+MakeNGonPoints+ returns a list like:
\begin{verbatim}
  [[x1, x2, x3,...],[y1,y2,y3,...]],
\end{verbatim}
while Polygon() takes the X and Y lists independently.

\item[Usage]
\begin{verbatim}
MakeNGonPoints(<radius>, <num_peaks>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
   window <- MakeWindow()
   ngonp <- MakeNGonPoints(50,10)
   ngon <- Polygon(200,200,First(ngonp),Nth(ngonp,2),
                   MakeColor("red"),1)
   AddObject(ngon,window)
   Draw()
\end{verbatim}

\item[See Also]	
\verb+MakeStarPoints+, \verb+Polygon+, \verb+RotatePoints+, \verb+ZoomPoints+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+MakePulldown()+

\item[Description]	
Creates a pulldown list that can be used to select an option. The closed version is s always 20 pixels high. When opened, it will be by default 15 rows high, although this is made smaller if the pulldown is close to the bottom of the screen.
A button is a custom object made from images and text. It has a property 'clickon' that is bound to 'Pulldown'

A closed pulldown will look like this:\\
 \includegraphics[scale=.8]{images/pulldown-closed.png}

An open pulldown will look like this:\\
 \includegraphics[scale=.8]{images/pulldown-open.png}

\item[Usage]
\begin{verbatim}
 MakePulldown(options,x,y,window,fontsize,width,selected)
 \end{verbatim}

The \texttt{options} argument is a list of options you want to appear.  x and y are the coordinates of the upper left corner, window is the name of the window (or other graphical object) it appears on, fontsize is the size of the font, and width is the width of the pulldown in pixels.  The selected argument is the initial selected list item.

Pulldown objects have a property .maxitems, that specify how many elements are displayed.  If the list contains more than obj.maxitems, the pulldown will enable scrolling.  A pulldown's click-on handler is by default bound to the 'Pulldown' function. When \texttt{PullDown(obj,mousexy)} is called, it will pop open the pulldown, allow for a new option to be selected, and return. It returns the index of the selected object, but the selected index can also be accessed using \texttt{obj.selected}. 

\item[Example]      	
See ui.pbl in the demo directory for examples of the use of pulldowns.  Pulldowns are also used within the PEBL launcher for various purposes.  A basic example is:

\begin{verbatim}
 options  <- MakePulldownButton(["A",B","C"],
                            400,250,gWin,14,100,1)
 resp <- WaitForClickOntarget([options],[1])
 CallFunction(options.clickon,[options,gClick]) 
\end{verbatim}

\item[See Also]	\verb+PullDown()+, \verb+DrawPulldown()+, \verb+UpdatePulldown+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+MakeScrollBox()+

\item[Description]	
Creates a graphical object that displays and allows selection of a list of items, and scrolls if the text gets too big. 

It has a property 'clickon' that is bound to 'ClickOnScrollBox'

A Scrolling textbox looks like this:\\
 \includegraphics[scale=.8]{images/scrollbox.png}

\item[Usage]
\begin{verbatim}
 MakeScrollBox(list,header,x,y,window,fontsize,
                  width,height,selected)
 \end{verbatim}

The \texttt{list} argument is a text block you want to display. header is a label. x and y are the coordinates of the upper left corner, window is the name of the window (or other graphical object) it appears on, fontsize is the size of the font, and width and height is the size of the scrollbox in pixels. \verb+selected+ indicates which option is selected, and this selection  (accessed via .selected) is updated by users using \verb+ClickOnScrollBox+, which is bound to the .clickon property.  


Several related function help update and draw a scrollbox.  To change the list or selected item, set the .list property to a new list or .selected to new selection and then call \verb+UpdateScrollBox+.  The function \verb+DrawScrollbox+ to manage redrawing drawing, and \verb+ClickOnScrollBox+ to handle interaction (this is bound to the .clickon property). .inside is bound to \verb+InsideTB+
A summary of important properties:
\begin{itemize}
\item \verb+selected+: which item is selected
\item \verb+numitems+: How many items on the list
\item \verb+maxoffset+: The most lines that can be displayed
\item \verb+list+: the list of options 
\item \verb+inside+: bound to InsideTB
\item \verb+clickon+: bound to ClickOnScrollBox

\end{itemize}


\item[Example]      	
See ui.pbl in the demo directory for examples of the use of a scrolling text box


\begin{verbatim}
  sb <- MakeScrollBox(Sequence(1,50,1),"The numbers",40,40,gWin,12,150,500,3)

   Draw()
   resp <- WaitForClickOntarget([sb],[1])
   CallFunction(sb.clickon,[sb,gClick])
   #Alternately: ClickOnScrollbox(sb,gClick) 
\end{verbatim}

\item[See Also]
\verb+SetScrollingText+
\verb+MakeScrollingTextBox+
\verb+UpdateScrollBox+
\verb+DrawScrollBox+
\verb+ClickOnScrollBox+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+MakeScrollingTextBox()+

\item[Description]	
Creates a graphical object that displays a block of text, and scrolls if the text gets too big. It uses a \verb+Scrollbox+ as its base, but handles parsing the text into lines and hides the selection box.  Thus, no 'selection' is displayed (although it actually exists), and a .text property is added to hold the text being displayed.

It has a property 'clickon' that is bound to 'ClickOnScrollBox'

A Scrolling textbox looks like this:\\
 \includegraphics[scale=.8]{images/scrollingtext.png}

\item[Usage]
\begin{verbatim}
 MakeScrollingTextBox(text,x,y,window,fontsize,
                        width,height,linewrap)
 \end{verbatim}

The \texttt{text} argument is a text block you want to display. x and y are the coordinates of the upper left corner, window is the name of the window (or other graphical object) it appears on, fontsize is the size of the font, and width and height is the size of the scrolling textbox in pixels.  linewrap, if non-zero, will parse the text layout so you see everything, breaking when the text gets to the end of the box, and on linebreaks.  if 0, it will only break at explicit carriage returns.

Note that parsing text into the scrolling textbox is fairly fast, but you may need workarounds for to display extremely long files if you want high responsiveness.

Several related function help update and draw a scrolling textbox.  To change the text, use \verb+SetScrollingText+. Because a scrolling textbox is really just a scrollbox, you also use \verb+DrawScrollbox+ to manage drawing, and \verb+ClickOnScrollBox+ to handle interaction (this is bound to the .clickon property). .inside is bound to \verb+InsideTB+


\item[Example]      	
See ui.pbl in the demo directory for examples of the use of a scrolling text box


\begin{verbatim}
  textscroll <- MakeScrollingTextBox("",200,50,gWin,12,
                                        300,150,0)

  SetScrollingText(textscroll,FileReadText("Uppercase.txt"))
   Draw()
  resp <- WaitForClickOntarget([textscroll],[1])
   CallFunction(textscroll.clickon,[textscroll,gClick]) 
\end{verbatim}

\item[See Also]
\verb+SetScrollingText+
\verb+MakeScrollBox+
\verb+UpdateScrollBox+
\verb+DrawScrollBox+
\verb+ClickOnScrollBox+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeSineWave()+

\item[Description] 
Creates a sine wave that can be played using the Play() or PlayBackground() functions.  It will create a single-channel sound at 44100 bitrate, 16 bit precision.

\item[Usage]
\begin{verbatim}
MakeSineWave(<duration_in_ms>, <hz>, <amplitude>)
\end{verbatim}
\begin{itemize}
 \item  The first argument specifies how long (in ms) the tone should be.
 \item The second argument specifies the frequency.  Good values range between 100 and 2000.
 \item The third argument specifies the volume.  It should be less than 1.0.
 \end{itemize}
 
\item[Example]	
\begin{verbatim}

   ##Make a sound that is 1000 ms, but just play 300 ms
   sound  <- MakeSineWave(200, 220, 1000)
   PlayBackground(sound)
   Wait(300)
   Stop(sound)

\end{verbatim}

\item[See Also]    	\verb+PlayForeground()+, \verb+PlayBackGround()+, \verb+Stop()+
\end{desc}






\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeStarPoints()+

\item[Description] 
Creates a set of points that form a regular star.  It can be
transformed with functions like \verb+RotatePoints+, or it can be 
used to create a graphical object with \verb+Polygon+.

Note: \verb+MakeStarPoints+ returns a list:
\begin{verbatim}
[[x1, x2, x3,...],[y1,y2,y3,...]],
\end{verbatim}
while \verb+Polygon()+ takes the X and Y lists independently.

\item[Usage]
\begin{verbatim}
MakeStarPoints(<outer_radius>, <inner_radius>,
                <num_peaks>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
   window <- MakeWindow()
   sp <- MakeStarPoints(50,20,10)
   star <- Polygon(200,200,First(sp),Nth(sp,2),
                   MakeColor("red"),1)
   AddObject(star,window)
   Draw()
\end{verbatim}

\item[See Also]	
\verb+MakeNGonPoints+, \verb+Polygon+, \verb+RotatePoints+, \verb+ZoomPoints+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeTextBox()+

\item[Description]	Creates a textbox in which to display text. 
		Textboxes allow multiple lines of text to be rendered;
		automatically breaking the text into lines. 

\item[Usage]
\begin{verbatim}
MakeWindow(<text>,<font>,<width>,<height>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
font <-MakeFont("Vera.ttf", 1, 12, MakeColor("red"), 
MakeColor("green"), 1)
tb <- MakeTextBox("This is the text in the textbox", 
font, 100, 250)
\end{verbatim}

\item[See Also]	\verb+MakeLabel()+, \verb+GetText()+, \verb+SetText()+, \verb+SetCursorPosition()+,
		\verb+GetCursorPosition()+, \verb+SetEditable()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeWindow()+ 

\item[Description]	Creates a window to display things in.
		Background is specified by \verb+<color>+.

\item[Usage]		
\begin{verbatim}
MakeWindow(<color>)
\end{verbatim}

\item[Example]
\begin{verbatim}	
  win <- MakeWindow()
  gWin <- MakeWindow("white")
\end{verbatim}
    
\item[See Also]	
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MakeTextList()+ 

\item[Description]	This takes a list and creates a block of text with carriage returns, ensuring each item of the list is on its own line; it also requires an offset, skipping the first lines of the list.  It is mostly a helper function used by \verb+Scrollbox+ objects to help format.  It will make text out of the entire list, so  you should be sure to cut off the end for efficiency if you only want to display some of the lines.


\item[Usage]		
\begin{verbatim}
MakeTextList([<list>], <list-offset>,<prebuffer>)
\end{verbatim}

\item[Example]
\begin{verbatim}	
letters <- FileReadList("Uppercase.txt")
out <- MakeTextList(letters,20,"--")
\end{verbatim}
The above code will create the following:
\begin{verbatim}
--u
--v
--w
--x
--y
--z
\end{verbatim}
    
\item[See Also]	
\verb+ListToString+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Match()+            

\item[Description] Returns a list of 0/1, indicating which elements of  \verb+<list>+ match \verb+<target>+

\item[Usage]		
\begin{verbatim}
Match(<list>,target)
\end{verbatim}

\item[Example]	
\begin{verbatim} 
  x <- [1,2,3,3,2,2,1]
  Print(Match(x,1))  ##== [1,0,0,0,0,0,1]
  Print(Match(x,2))  ##== [0,1,0,0,1,1,0]
  Print( Match(x,3)  ##== [0,0,1,1,0,0,0]

\end{verbatim}

\item[See Also]	\verb+Filter()+, \verb+Subset()+, \verb+Lookup()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Max()+            

\item[Description] Returns the largest of \verb+<list>+.

\item[Usage]		
\begin{verbatim}
Max(<list>)
\end{verbatim}

\item[Example]	
\begin{verbatim} 
  c <- [3,4,5,6]
  m <- Max(c) # m == 6
\end{verbatim}

\item[See Also]	\verb+Min()+, \verb+Mean()+, \verb+StDev()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MD5Sum()+            

\item[Description] Computes MD5 sum of a text string.  Returns blank if no string provided\verb+<list>+.

\item[Usage]		
\begin{verbatim}
MD5Sum(<text>)
\end{verbatim}

\item[Example]	
\begin{verbatim} 

Print(MD5Sum(""))
#Return: d41d8cd98f00b204e9800998ecf8427e
 Print(MD5Sum("bananana"))
#returns bb8e9af523e4aeffa88f1807fb2af9ce

text <- FileReadText("test.pbl")
Print(MD5Sum(text))  
#returns: 3396a651bd3c96f9799ce02eecb48801; see similar example next

Print(MD5File("test.pbl"))
# returns 3396a651bd3c96f9799ce02eecb48801

Print(MD5File("doesnotexist.txt"))
#returns 0

\end{verbatim}
\item[See Also]	\verb+MD5File()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MD5File()+            

\item[Description] Computes MD5 sum of a file.  Returns blank if no string provided\verb+<list>+.

\item[Usage]		
\begin{verbatim}
MD5File(<filename>)
\end{verbatim}

\item[Example]	
\begin{verbatim} 
text <- FileReadText("test.pbl")
Print(MD5Sum(text))  
#returns: 3396a651bd3c96f9799ce02eecb48801; see similar example next

Print(MD5File("test.pbl"))
# returns 3396a651bd3c96f9799ce02eecb48801

Print(MD5File("doesnotexist.txt"))
#returns 0

Print(MD5Sum(""))
#Return: d41d8cd98f00b204e9800998ecf8427e
 Print(MD5Sum("bananana"))
#returns bb8e9af523e4aeffa88f1807fb2af9ce
\end{verbatim}
\item[See Also]	\verb+MD5Sum()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Mean()+

\item[Description] 	Returns the mean of the numbers in \verb+<list>+.

\item[Usage]	Mean(\verb+<list-of-numbers>+)	

\item[Example]	
\begin{verbatim} 
  c <- [3,4,5,6]
  m <- Mean(c) # m == 4.5
\end{verbatim}

\item[See Also]	\verb+Median()+, \verb+Quantile()+, \verb+StDev()+, \verb+Min()+, \verb+Max()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Median()+

\item[Description]	Returns the median of the numbers in
  \verb+<list>+.  

\item[Usage]	Median(\verb+<list-of-numbers>+)

\item[Example]	
\begin{verbatim} 
  c <- [3,4,5,6,7]
  m <- Median(c) # m == 5
\end{verbatim}
\item[See Also]	\verb+Mean()+, \verb+Quantile()+, \verb+StDev()+, \verb+Min()+, \verb+Max()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Merge()+

\item[Description]	Combines two lists, \verb+<lista>+ and \verb+<listb>+, into a single list.

\item[Usage]		
\begin{verbatim}
Merge(<lista>,<listb>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
Merge([1,2,3],[8,9]) 	# == [1,2,3,8,9]
\end{verbatim}

\item[See Also]	\verb+[ ]+, \verb+Append()+, \verb+List()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MessageBox()+

\item[Description]	Hides what is on the screen and presents a textbox with
  specified message, with a button to click at the bottom to continue.


\item[Usage]		
\begin{verbatim}
MessageBox(<message>,<window>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
 gWin <- MakeWindow()
 MessageBox("Click below to begin.",gWin)


\end{verbatim}

\item[See Also]	\verb+GetEasyInput+, \verb+EasyTextBox+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Min()+

\item[Description]	Returns the `smallest' element of a list.

\item[Usage]	
\begin{verbatim}
Min(<list>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  c <- [3,4,5,6]
  m <-  Min(c) # == 3
\end{verbatim}

\item[See Also]	\verb+Max()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Mod()+

\item[Description]	Returns \verb+<num>+, \verb+<mod>+, or remainder of \verb+<num>/<mod>+

\item[Usage]		
\begin{verbatim}
Mod( <num> <mod>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
Mod(34, 10)	# == 4
Mod(3, 10)	# == 3
\end{verbatim}

\item[See Also]	\verb+Div()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Move()+

\item[Description]	Moves an object to a specified location.  
		Images and Labels are moved according to their center; 
		TextBoxes are moved according to their upper left corner.

\item[Usage]
\begin{verbatim}
Move(<object>, <x>, <y>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
Move(label, 33, 100)
\end{verbatim}

\item[See Also]	\verb+MoveCorner()+, \verb+MoveCenter()+, \verb+.X+ and \verb+.Y+ properties.
\end{desc}
\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MoveCenter()+

\item[Description]	Moves a TextBox to a specified location
		according to its center, instead of its upper left corner.

\item[Usage]
\begin{verbatim}
MoveCenter(<object>, <x>, <y>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
MoveCenter(TextBox, 33, 100)
\end{verbatim}

\item[See Also]	\verb+Move()+, \verb+MoveCenter()+, \verb+.X+ and \verb+.Y+ properties
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MoveCorner()+

\item[Description]	Moves a label or image to a specified location
		according to its upper left corner, instead of its center. 

\item[Usage]
\begin{verbatim}
MoveCorner(<object>, <x>, <y>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
MoveCorner(label, 33, 100)
\end{verbatim}

\item[See Also]	\verb+Move()+, \verb+MoveCenter()+, \verb+.X+ and \verb+.Y+ properties
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+MoveObject()+

\item[Description] Calls the function named by the  .move property of a custom object.  Useful if a custom object has complex parts that need to be moved; you can bind .move to a custom move function and then call it (and anything else) using MoveObject. \texttt{MoveObject} will fall back on a normal move, so you can handle movement of many built-in objects with it

\item[Usage]
\begin{verbatim}
MoveObject(obj,x,y)	
\end{verbatim}

\item[Example]	


\begin{verbatim}
  
   ##This overrides buttons placement at the center:  
   done <- MakeButton("QUIT",400,250,gWin,150)
   done.move <- "MoveCorner"
   MoveObject(done, 100,100)
    
\end{verbatim}

\item[See Also]	
\verb+Inside()+, \verb+Move+ \verb+ClickOn+, \verb+DrawObject+

\end{desc}



\vfill
\newpage
\sect{N}
\vfill

\begin{desc}{Name/Symbol}
   
\item[Name/Symbol] \verb+NonOverlapLayout+

\item[Description]        Creates a set of num points in a xy range, that have a (soft) minimum tolerance of 'tol' between points.  That is, to the extent possible, the returned points will have a minumum distance between them of \verb+<tol>+.  This may not be possible or be very difficult, and so after a limited number of attempts (by default, 100), the algorithm will return the current configuration, which may have some violations of the minimum tolerance rule, but it will usually be fairly good.  

The algorithm works by initializing with a random set of points, then computing a pairwise distance matrix between all points, finding the closest two points, and resampling one of them until its minumum distance is larger than the current.  Thus, each internal iteration uniformly improves (or keeps the configuration the same), and the worst points are reconfigured first, so that even if a configuration that does not satisfy the constraints, it will usually be very close.

Internally, the function (located in pebl-lib/Graphics.pbl) has a variable that controls how many steps are taken, called ``limit'', which is set to 100.  For very compacted or very large iterations, this limit can be increased by editing the file or making a copy of the function.  

The function usually returns fairly quickly, so it can often be used real-time between trials.  However, for complex enough configurations, it can take on the order of seconds; furthermore, more  complex configurations might take longer than less complex configurations, which could represent a potential confound (if more complex stimuli have longer ISIs).  Users should thus consider creating the configurations when the test is initialized, or created prior to the study and then saved out to a file for later use.


\newpage

\item[Usage]       
\verb+NonOverlapLayout(<xmin>,<xmax>,<ymin>,<ymax>,<tol>,<num>)+

\item[Example]

Example PEBL Program using NonoverlapLayout:
\begin{verbatim}
define Start(p)
 {
   win <- MakeWindow()  
   ## Make 25 points in a square in the middle 
   ## of the screen, a minimum of 50 pixels apart.  
   ## This is too compact, but it will be OK.

   points <- NonOverlapLayout(100,300,200,400,50,25)
   circs <- []
   ##This should non-overlapping circles of radius 25
   loop(i,points)
    {
       tmp <- Circle(First(i),Second(i),25,
                     MakeColor("blue"),0) 
       AddObject(tmp,win)
       circs <- Append(circs,tmp)
    }


   rect1 <- Square(200,300,200,MakeColor("black"),0)
   rect2 <- Square(600,300,200,MakeColor("black"),0)

   AddObject(rect1,win)
   AddObject(rect2,win)
   ##Reduce the tolerance: this one should be bettter
   points <- NonOverlapLayout(500,700,200,400,50,15)


   ##This should non-overlapping circles of radius 15
   loop(i,points)
    {
       tmp <- Circle(First(i),Second(i),
                     15,MakeColor("blue"),0) 
       AddObject(tmp,win)
	   circs <- Append(circs,tmp)
    }
   Draw()
   WaitForAnyKeyPress()

}
\end{verbatim}
\clearpage
The output of the above program is shown below.  Even for the left configuration, which is too compact (and which takes a couple seconds to run), the targets are fairly well distributed.
\includegraphics[scale=.35]{images/nonoverlap.png} 


\item[See Also]     
\verb+LayoutGrid()+
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+not+

\item[Description]	Logical not

\item[Usage]		

\item[Example]	

\item[See Also]	\verb+and+, \verb+or+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+NormalDensity()+

\item[Description]	Computes density of normal standard distribution
\item[Usage]
\begin{verbatim}
NormalDensity(<x>)
\end{verbatim}

\item[Example]	
\begin{verbatim}


  Print(NormalDensity(-100))     # 1.8391e-2171
  Print(NormalDensity(-2.32635)) #5.97
  Print(NormalDensity(0))        #0.398942
  Print(NormalDensity(1.28155))  #.90687
  Print(NormalDensity(1000))     #inf

\end{verbatim}

\item[See Also]	\verb+RandomNormal()+, \verb+CumNormInv()+ 
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Nth()+

\item[Description]	Extracts the Nth item from a list.  Indexes from 1 upwards.
		\verb+Last()+ provides faster access than \verb+Nth()+ to the end of a list, 
		which must walk along the list to the desired position.

\item[Usage]
\begin{verbatim}
Nth(<list>, <index>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
a <- ["a","b","c","d"]
Print(Nth(a,3)) 		# == 'c'
\end{verbatim}

\item[See Also]	\verb+First()+, \verb+Last()+ 
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+NthRoot()+

\item[Description]	\verb+<num>+ to the power of  1/\verb+<root>+.

\item[Usage]		
\begin{verbatim}
NthRoot(<num>, <root>)
\end{verbatim}

\item[Example]	

\item[See Also]	
\end{desc}

\vfill
\newpage
\sect{O}
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+OpenCOMPort+ 

\item[Description]  
  This opens a COM/Serial port
\item[Usage]       
     \verb+OpenCOMPort(<portnum>,<baud>)+ 

\item[Example]

\item[See Also]
\verb+COMPortGetByte+, \verb+COMPortSendByte+, \verb+OpenPPort+, \verb+SetPPortMode+, \verb+GetPPortMode+ 
\end{desc} 




\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+OpenJoystick+ 

\item[Description]  
  This opens an available joystick, as specified by its index.  The returned object can then be used in to access the state of the joystick.  It takes an integer argument, and for the most part, if you have a single joystick attached to your system, you will use OpenJoystick(1).  If you want to use a second joystick, use OpenJoystick(2), and so on.
  
  \item[Usage]          \verb+OpenJoystick()+ 

\item[Example]
See joysticktest.pbl in the demo\ directory

\item[See Also]
GetNumJoysticks(), OpenJoystick(), GetNumJoystickAxes()
GetNumJoystickBalls(), GetNumJoystickButtons(), GetNumJoystickHats()
GetJoystickAxisState(), GetJoystickHatState(), GetJoystickButtonState()
\end{desc} 


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+OpenNetworkListener()+

\item[Description] Creates a network object that listens on a particular port, and is able to accept incoming connections. You can the nuse \verb+CheckForNetworkConnections+ to accept incoming connections.  
This is an alternative to the \verb+WaitForNetworkConnection+ function that allows more flexibility (and allows updating the during waiting for the connection).

\item[Usage]
\begin{verbatim}
net <- OpennetworkListener(port)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  network <-      OpenNetworkListener(4444) 
  time <- GetTime()
  while(not connected and (GetTime() < time + 5000))
   {
      connected <- CheckForNetwokConnection(network) 
   }

\end{verbatim}
\item[See Also]	\verb+CheckForNetworkConnection()+, \verb+Getdata()+, \verb+WaitForNetworkConnection()+, \verb+CloseNetwork()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+OpenSubMenus()+

\item[Description]	
Used by ClickOnMenu to open, display a submenu and get a click.

\item[Usage]
\begin{verbatim}
 OpenSubMenus(obj,[x,y])
  \end{verbatim}
THis function is bound to the .clickon property of a menu. It will open and display all the submenus, wait for a click, and execute the function called.

\item[Example]      	
This creates a menu and awaits clicking on.  More complete examples are available in ui.pbl.  It requires that MyMessage is created somewhere
\begin{verbatim}

   menu1 <- MakeMenuItem("File",0,0,gWin,14,10,"MYMESSAGE")


   menu2<- MakeMenu("Edit",70,0,gWin,14,10, "MYMESSAGE")
   
   menus <- [menu1,menu2]
   opt <- WaitForClickOntarget(menu,[1,2])
   ClickOnMenu(Nth(menus,opt),gClick)
\end{verbatim}

\item[See Also]	\verb+MakeMenu()+, \verb+OpenSubMenus()+, \verb+MakeMenuItem+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+or+                   

\item[Description]	Logical or

\item[Usage]		

\item[Example]	

\item[See Also]	\verb+and+, \verb+not+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+OpenPPort+ 

\item[Description]  
  Opens a Parallel  port, returning an object that can be used for parallel port communications.
\item[Usage]       
     \verb+OpenPPort(<name>)+ 
 The <name> argument can be one of: "LPT1", "LPT2", and "LPTX".  Most likely, a parallel port will be configured to 
LPT1, but other configurations are sometimes possible. 
\item[Example]

\item[See Also]
\verb+COMPortGetByte+, \verb+COMPortSendByte+, \verb+OpenCOMPort+, \verb+SetPPortMode+, \verb+GetPPortMode+ 
\end{desc} 





\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Order()+

\item[Description]	Returns a list of indices describing the order of values by position, from min to max. 

\item[Usage]
\begin{verbatim}
		Order(<list-of-numbers>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
	n <- [33,12,1,5,9]
  	o <- Order(n)
    Print(o) #should print [3,4,5,2,1]
\end{verbatim}

\item[See Also]	\verb+Rank()+
\end{desc}

\vfill
\newpage
\sect{P}
\vfill

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+PausePlayback()+
 
\item[Description] Pauses a playing movie or audio stream.  This is used for 
movies whose playback was initiated using \verb+StartPlayback+, which then ran as
background threads during a Wait() function. 

\item[Usage]		
\begin{verbatim}
PausePlayBack(movie)
\end{verbatim}

\item[Example]	
\begin{verbatim}
   movie <- LoadMovie("movie.avi",gWin,640,480)
   PrintProperties(movie)
   Move(movie,20,20)
   Draw() 
   StartPlayback(movie)
   Wait(500) #Play 500 ms of the movie.
   PausePlayback(movie)
   Wait(500)
   
\end{verbatim}

\item[See Also] \verb+LoadAudioFile()+, \verb+LoadMovie()+, \verb+PlayMovie()+, \verb+StartPlayback()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+PlayForeground()+  

\item[Description]	Plays the sound `in the foreground'; 
		does not return until the sound is complete.

\item[Usage]		
\begin{verbatim}
PlayForeground(<sound>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
   sound  <- MakeSineWave(200, 220, 1000)
   PlayForeground(sound)
\end{verbatim}
\item[See Also]	\verb+PlayBackground()+, \verb+Stop()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+PlayBackground()+
 
\item[Description]	Plays the sound `in the background', returning immediately.

\item[Usage]		
\begin{verbatim}
PlayBackground(<sound>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
   sound  <- MakeSineWave(200, 220, 1000)
   PlayBackground(sound)
   Wait(300)
   Stop(sound)
\end{verbatim}

\item[See Also]	\verb+PlayForeground()+, \verb+Stop()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+PlayMovie()+
 
\item[Description]	Plays the movie (or other multimedia file) loaded via
either the LoadMovie or LoadAudioFile function.  Note that this functionality uses a 
different underlying system than the sound playing functions PlayBackground and PlayForeground,
and they are not interchangeable.

\item[Usage]		
\begin{verbatim}
PlayMovie(movie)
\end{verbatim}

\item[Example]	
\begin{verbatim}
   movie <- LoadMovie("movie.avi",gWin,640,480)
   PrintProperties(movie)
   Move(movie,20,20)
   movie.volume <- .1
   status <- EasyLabel("Demo Movie Player",300,25,gWin,22)    
   Draw()
   PlayMovie(movie)
\end{verbatim}

\item[See Also] \verb+LoadAudioFile()+, \verb+LoadMovie()+, \verb+StartPlayback()+, \verb+PausePlayback()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Plus+ 

\item[Description] Creates a polygon in the shape of a
 plus sign. Arguments include position in window.
\begin{itemize}
\item \verb+<x>+ and \verb+<y>+ is the position of the center
\item \verb+<size>+ or the size of the plus sign in pixels
\item \verb+<width>+ thickness of the plus
\item \verb+<color>+ is a color object (not just the name)
\end{itemize}

Like other drawn objects, the plus must then be added to the window
to appear.

\item[Usage]		
\begin{verbatim}
 Plus(x,y,size,width,color)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  win <- MakeWindow()
  p1 <- Plus(100,100,80,15,MakeColor("red"))
  AddObject(p1,win)
  Draw()
\end{verbatim}

\item[See Also]   
\verb+BlockE()+, \verb+Polygon()+, \verb+MakeStarPoints()+,
\verb+MakeNGonPoints()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Polygon+ 

\item[Description] Creates a polygon in the shape of the points
specified by \verb+<xpoints>+, \verb+<ypoints>+. The lists \verb+<xpoints>+ and
\verb+<ypoints>+ are adjusted by  \verb+<x>+ and \verb+<y>+, so they
should be relative to 0, not the location you want the points to be at.

Like other drawn objects, the polygon must then be added to the window
to appear.

\item[Usage]		
\begin{verbatim}
  Polygon(<x>,<y>,<xpoints>,<ypoints>,
          <color>,<filled>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  win <- MakeWindow()
   #This makes a T
   xpoints <- [-10,10,10,20,20,-20,-20,-10]
   ypoints <- [-20,-20,40,40,50,50,40,40]
  p1 <-    Polygon(100,100,xpoints, ypoints,
                   MakeColor("black"),1)
  AddObject(p1,win)
  Draw()
\end{verbatim}

\item[See Also]   
\verb+BlockE()+, \verb+Bezier()+, \verb+MakeStarPoints()+,
\verb+MakeNGonPoints()+
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+PopUpEntryBox()+ 

\item[Description]	Creates a small text-entry box at a specified location..

\item[Usage]		
\begin{verbatim}
 PopuUpEntryBox(<text>,<win>,[x,y])

\end{verbatim}

\item[Example]	
\begin{verbatim}
 subnum <- PopUpEntryBox("Enter particpant code",gWin,[100,100])
 
\end{verbatim}

\item[See Also]     
\verb+MessageBox+ \verb+GetEasyInput+, \verb+PopUpMessageBox+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+PopUpMessageBox()+ 

\item[Description]	Creates a small 300x200 information box at the current cursor location, but also adjusts so it is on the screen.  It must be dismissed by clicking the 'OK' button.  

\item[Usage]		
\begin{verbatim}
 PopuUpMessageBox(<text>,<win>)
\end{verbatim}
Note that the function puts the box on the screen at the current mouse position.  If you want control over where it goes, you need to use \verb+SetMouseCursorPosition+ immediately before the box is made.
\item[Example]	
\begin{verbatim}
 subnum <- PopUpMessageBox("There has been an error.",gWin)
 
\end{verbatim}

\item[See Also]     
\verb+MessageBox+ \verb+GetEasyInput+, \verb+PopUpEntryBox+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Print()+

\item[Description]	Prints \verb+<value>+ to stdout (the console [Linux] or the file \texttt{stdout.txt} [Windows]), and then appends a newline afterwards.

\item[Usage]		
\begin{verbatim}
Print(<value>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  Print("hello world")
  Print(33 + 43)
  x <-Print("Once")

\end{verbatim}
\item[See Also]	\verb+Print_()+, \verb+FilePrint()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Pow()+ 

\item[Description]	Raises or lowers \verb+<num>+ to the power of \verb+<pow>+.

\item[Usage]		
\begin{verbatim}
Pow(<num>, <pow>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
Pow(2,6)	# == 64
Pow(5,0)	# == 1
\end{verbatim}

\item[See Also]     
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Print()+

\item[Description]	Prints \verb+<value>+ to stdout (the console [Linux] or the file \texttt{stdout.txt} [Windows]), and then appends a newline afterwards.

\item[Usage]		
\begin{verbatim}
Print(<value>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  Print("hello world")
  Print(33 + 43)
  x <-Print("Once")

\end{verbatim}
\item[See Also]	\verb+Print_()+, \verb+FilePrint()+
\end{desc}
\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+PrintProperties()+

\item[Description]	Prints .properties/values for any complex object.
  These include textboxes, fonts, colors, images, shapes, etc. Mostly
  useful as a debugging tool.

\item[Usage]		
\begin{verbatim}
PrintProperties(<object>)
\end{verbatim}

\item[Example]	
\begin{verbatim}


   win <- MakeWindow()
   tb <- EasyTextbox("one",20,20,win,22,400,80)
   PrintProperties(tb)

##Output:
----------
[CURSORPOS]: 0
[EDITABLE]: 0
[HEIGHT]: 80
[ROTATION]: 0
[TEXT]: one
[VISIBLE]: 1
[WIDTH]: 400
[X]: 20
[Y]: 20
[ZOOMX]: 1
[ZOOMY]: 1
----------

\end{verbatim}
\item[See Also]	\verb+Print()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Print_()+

\item[Description]	Prints \verb+<value>+ to stdout; doesn't append a newline afterwards.

\item[Usage]		
\begin{verbatim}
Print_(<value>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
Print_("This line")
Print_(" ")
Print_("and")
Print_(" ")
Print("Another line")
# prints out: 'This line and Another line'
\end{verbatim}

\item[See Also]	\verb+Print()+, \verb+FilePrint()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+PrintList()+

\item[Description]	Prints a list, without the ','s or []
  characters. Puts a carriage return at the end.  Returns a string
  that was printed.  If a list contains other lists, the printing will
  wrap multiple lines and the internal lists will be printed as
  normal.  To avoid this, try PrintList(Flatten(list)).

\item[Usage]
\begin{verbatim}
PrintList( <list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
PrintList( [1,2,3,4,5,5,5])
##
##  Produces:
##1 2 3 4 5 5 5
PrintList([[1,2],[3,4],[5,6]])
#Produces:
# [1,2]
#,[3,4]
#,[5,6]

PrintList(Flatten([[1,2],[3,4],[5,6]]))
#Produces:
# 1 2 3 4 5 6

\end{verbatim}

\item[See Also]	\verb+Print()+, \verb+Print_()+, \verb+FilePrint()+, \verb+FilePrint_()+, \verb+FilePrintList()+,
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+PropertyExists+ 

\item[Description]  
Tests whether a particular named property exists. This works for custom or built-in objects. This is important to check properties that might not exist, because trying to \verb+GetProperty+ of a non-existent property will cause a fatal error.
  
\item[Usage]       
     \verb+out <- PropertyExists(obj,property)+ 
\item[Example]

\begin{verbatim}
  obj <- MakeCustomObject("myobject")
  obj.taste <- "buttery"
  obj.texture <- "creamy"
  SetProperty(obj,"flavor","tasty")
  
  list <- GetPropertyList(obj)
  loop(i,list)
   {
     if(PropertyExists(obj,i)
      {
        Print(i  + ":  " + GetProperty(obj,i))
      }
   }

\end{verbatim}


\item[See Also]
\verb+GetPropertyList+, \verb+GetProperty+, \verb+SetProperty+ \verb+MakeCustomObject+, \verb+PrintProperties+ 
\end{desc} 


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Pulldown()+

\item[Description]	
This handles making a new selection on a pulldown box.

\item[Usage]
\begin{verbatim}
 Pulldown(object, [x,y])
\end{verbatim}

This function is typically the primary way of interacting with a pulldown box. It will have the effect of opening the pulldown box, waiting for the user to select a new option, and then changing the selected option to whatever they click on.

\item[Example]      	
See demo\\ui.pbl for examples of the use of pulldowns.  Pulldowns are also used within the PEBL launcher for various purposes.  A basic example is:

\begin{verbatim}
 options  <- MakePulldownButton(["A",B","C"],400,250,gWin,14,100,1)
 resp <- WaitForClickOntarget([options],[1])
 newvalue <- Pulldown(options,gClick) 
\end{verbatim}

\item[See Also]	\verb+MakePullDown()+, \verb+DrawPulldown()+, \verb+UpdatePulldown+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+PushButton+

\item[Description]	
Animates a button-pushing. It takes a button created using the MakeButton function and will animate a downclick when the mouse is down, and release when the mouse is unclicked.  To conform with general object handlers, it requires specifying a mouse click position, which could be [0,0], or gclick. This function is bound to the property 'clickon' of any button, allowing you to handle mouse clicks universally for many different objects.

\item[Usage]
\begin{verbatim}
 PushButton(button, xylist)
  \end{verbatim}

\item[Example]      	
The following creates a button, waits for you to click on it, and animates a button press

\begin{verbatim}
 done <- MakeButton("QUIT",400,250,gWin,150)
 resp <- WaitForClickOntarget([done],[1])
 PushButton(done,[0,0])
\end{verbatim}

To handle multiple buttons, you can do:

\begin{verbatim}
 done <- MakeButton("QUIT",400,250,gWin,150)
 ok <-   MakeButton("OK",400,250,gWin,150)

 resp <- 2
 while (resp != 1)
 {
  Draw()
  resp <- WaitForClickOntarget([done,ok],[1,2])
  obj <- Nth([done,ok],resp)
  CallFunction(obj.clickon,[obj,gClick])
 } 
 
\end{verbatim}


\item[See Also]	\verb+MakeCheckBox()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+PushOnEnd+
  
\item[Description]  	Pushes an item onto the end of a list, modifying the list itself.

Note: \texttt{PushOnEnd} is a more efficient replacement for \texttt{Append()}. Unlike \texttt{Append}, it will modify the original list as a side effect, so the following works:

\begin{verbatim}
  PushOnEnd(list, item)
\end{verbatim}
There is no need to set the original list to the result of PushOnEnd, like you must do with Append.  However, it does in fact work, and incurs only a slight overhead, so that Append can often be replaced with PushOnEnd without worry.
\begin{verbatim}
 list <-  PushOnEnd(list, item)
\end{verbatim}

\item[Usage] 
\begin{verbatim}
PushOnEnd(<list>, <item>)
\end{verbatim}

\item[Example]
\begin{verbatim}
list <- Sequence(1,5,1)
double  <- []
loop(i, list)
{
  PushOnEnd(double, [i,i])
}
Print(double)
# Produces [[1,1],[2,2],[3,3],[4,4],[5,5]]

\end{verbatim}

\item[See Also]  \verb+SetElement()+ \verb+List()+, \verb+[ ]+, \verb+Merge()+, \verb+PushOnEnd+
\end{desc}


\vfill
\newpage
\sect{Q}
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Quantile()+

\item[Description]	Returns the \verb+<num>+ quantile of
		the numbers in \verb+<list>+. \verb+<num>+ should be  between
        0 and 100

\item[Usage]		
\begin{verbatim}
Quantile(<list>, <num>)
\end{verbatim}

\item[Example]	
 \begin{verbatim}
      ##Find 75th percentile to use as a threshold.
      thresh <- Quantile(rts,75) 
 \end{verbatim}
\item[See Also]	\verb+StDev()+, \verb+Median()+, \verb+Mean()+, \verb+Max()+, \verb+Min()+
\end{desc}

\vfill
\newpage
\sect{R}
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+RadToDeg()+ 

\item[Description] 	Converts \verb+<rad>+ radians to degrees.

\item[Usage]		
\begin{verbatim}
RadToDeg( <rad>)			 
\end{verbatim}

\item[Example]	

\item[See Also]     	\verb+DegToRad()+, \verb+Tan()+, \verb+Cos()+, \verb+Sin()+, \verb+ATan()+, \verb+ASin()+, \verb+ACos()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Random()+

\item[Description]	Returns a random number between 0 and 1.

\item[Usage]
\begin{verbatim}
Random()
\end{verbatim}

\item[Example]
\begin{verbatim}
a <- Random()
\end{verbatim}

\item[See Also]		\verb+Random()+, \verb+RandomBernoulli()+, \verb+RandomBinomial()+, \verb+RandomDiscrete()+, \verb+RandomExponential()+, \verb+RandomLogistic()+, \verb+RandomLogNormal()+, \verb+RandomNormal()+, \verb+RandomUniform()+, \verb+RandomizeTimer()+, \verb+SeedRNG()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+RandomBernoulli()+

\item[Description]	Returns 0 with probability \verb+(1-<p>)+ and 1 with probability \verb+<p>+.

\item[Usage]		
\begin{verbatim}
RandomBernoulli(<p>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
RandomBernoulli(.3)
\end{verbatim}

\item[See Also] \verb+Random()+, \verb+RandomBernoulli()+,
  \verb+RandomBinomial+, \verb+RandomDiscrete()+,
  \verb+RandomExponential()+, \verb+RandomLogistic()+,
  \verb+RandomLogNormal()+, \verb+RandomNormal()+,
  \verb+RandomUniform()+, \verb+RandomizeTimer()+, \verb+SeedRNG()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+RandomBinomial+

\item[Description] Returns a random number according to the Binomial
  distribution with probability \verb+<p>+ and repetitions \verb+<n>+,
  i.e., the number of \verb+<p>+ Bernoulli trials that succeed out of
  \verb+<n>+ attempts.

\item[Usage]		
\begin{verbatim}
RandomBinomial(<p> <n>)  
\end{verbatim}

\item[Example]	
\begin{verbatim}
RandomBinomial(.3, 10) # returns number from 0 to 10
\end{verbatim}

\item[See Also]	\verb+Random()+, \verb+RandomBernoulli()+, \verb+RandomBinomial+,
		\verb+RandomDiscrete()+, \verb+RandomExponential()+, \verb+RandomLogistic()+,
		\verb+RandomLogNormal()+, \verb+RandomNormal()+, \verb+RandomUniform()+,    
		\verb+RandomizeTimer()+, \verb+SeedRNG()+    
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+RandomDiscrete()+

\item[Description]	Returns a random integer between 1 and the argument 
		(inclusive), each with equal probability.  If the argument is 
		a floating-point value, it will be truncated down; if it is 
		less than 1, it will return 1, and possibly a warning message. 

\item[Usage]		
\begin{verbatim}
RandomDiscrete(<num>)
\end{verbatim}
         
\item[Example]	
\begin{verbatim}
 # Returns a random integer between 1 and 30:
RandomDiscrete(30)
\end{verbatim}

\item[See Also]	\verb+Random()+, \verb+RandomBernoulli()+, \verb+RandomBinomial+, 
		\verb+RandomDiscrete()+, \verb+RandomExponential()+, \verb+RandomLogistic()+,
		\verb+RandomLogNormal()+, \verb+RandomNormal()+, \verb+RandomUniform()+,
		\verb+RandomizeTimer()+, \verb+SeedRNG()+    
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+RandomExponential()+

\item[Description]	Returns a random number according to exponential 
		distribution with mean \verb+<mean>+ (or decay 1/mean).

\item[Usage]		
\begin{verbatim}
RandomExponential(<mean>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
RandomExponential(100)
\end{verbatim}

\item[See Also]	\verb+Random()+, \verb+RandomBernoulli()+, \verb+RandomBinomial+,
		\verb+RandomDiscrete()+, \verb+RandomLogistic()+, \verb+RandomLogNormal()+, 
		\verb+RandomNormal()+, \verb+RandomUniform()+, \verb+RandomizeTimer+, \verb+SeedRNG()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+RandomizeTimer()+

\item[Description]	Seeds the RNG with the current time.

\item[Usage]
\begin{verbatim}
RandomizeTimer()
\end{verbatim}

\item[Example]	
\begin{verbatim}
RandomizeTimer()
x <- Random()
\end{verbatim}
	     
\item[See Also]	\verb+Random()+, \verb+RandomBernoulli()+, \verb+RandomBinomial+,
		\verb+RandomDiscrete()+, \verb+RandomExponential()+, \verb+RandomLogistic()+,
		\verb+RandomLogNormal()+, \verb+RandomNormal()+, \verb+RandomUniform()+, \verb+SeedRNG()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+RandomLogistic()+  

\item[Description]	Returns a random number according to the logistic distribution 
		with parameter \verb+<p>+: f(x) = exp(x)/(1+exp(x))

\item[Usage]		
\begin{verbatim}
RandomLogistic(<p>)
\end{verbatim}

\item[Example]	RandomLogistic(.3)

\item[See Also]	\verb+Random()+, \verb+RandomBernoulli()+, \verb+RandomBinomial+, 
		\verb+RandomDiscrete()+, \verb+RandomExponential()+, \verb+RandomLogNormal()+, 
		\verb+RandomNormal()+, \verb+RandomUniform()+, \verb+RandomizeTimer+, \verb+SeedRNG()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+RandomLogNormal()+

\item[Description]  	Returns a random number according to the log-normal 
		distribution with parameters \verb+<median>+ and \verb+<spread>+. Generated 
		by calculating $median \verb!*! exp(spread \verb!*! RandomNormal(0,1))$. 
		\verb+<spread>+ is a shape parameter, and only affects the variance 
		as a function of the median; similar to the coefficient of 
		variation.  A value near 0 is a sharp distribution (.1-.3), 
		larger values are more spread out; values greater than 2 make 
		little difference in the shape.

\item[Usage]
\begin{verbatim}
RandomLogNormal(<median>, <spread>)
\end{verbatim}

\item[Example]      	
\begin{verbatim}
RandomLogNormal(5000, .1)
\end{verbatim}

\item[See Also]	\verb+Random()+, \verb+RandomBernoulli()+, \verb+RandomBinomial+, 
		\verb+RandomDiscrete()+, \verb+RandomExponential()+, \verb+RandomLogistic()+,
		\verb+RandomNormal()+, \verb+RandomUniform()+, \verb+RandomizeTimer+, \verb+SeedRNG()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+RandomNormal()+

\item[Description] 	Returns a random number according to the standard
             	normal distribution with \verb+<mean>+ and \verb+<stdev>+.

\item[Usage]       	
\begin{verbatim}
RandomNormal(<mean>, <stdev>)
\end{verbatim}

\item[Example]	

\item[See Also]	\verb+Random()+, \verb+RandomBernoulli()+, \verb+RandomBinomial+,
		\verb+RandomDiscrete()+, \verb+RandomExponential()+, \verb+RandomLogistic()+, 
		\verb+RandomLogNormal()+, \verb+RandomUniform()+, \verb+RandomizeTimer+, \verb+SeedRNG()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+RandomUniform()+

\item[Description]	Returns a random floating-point number between 0 and \verb+<num>+.

\item[Usage]		
\begin{verbatim}
RandomUniform(<num>)
\end{verbatim}

\item[Example]	

\item[See Also] \verb+Random()+, \verb+RandomBernoulli()+,
  \verb+RandomBinomial+, \verb+RandomDiscrete()+,
  \verb+RandomExponential()+, \verb+RandomLogistic()+,
  \verb+RandomLogNormal()+, \verb+RandomNormal()+, \verb+RandomizeTimer()+,
  \verb+SeedRNG()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Rank()+

\item[Description]	Returns a list of numbers describing the rank of
  each position, from min to max.  The same as calling \verb+Order(Order(x))+.

\item[Usage]
\begin{verbatim}
		Rank(<list-of-numbers>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
	n <- [33,12,1,5,9]
  	o <- Rank(n)
    Print(o) #should print [5,4,1,2,3]
\end{verbatim}

\item[See Also]	\verb+Order()+
\end{desc}
\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+ReadCSV()+

\item[Description]	Reads a comma-separated  value file into a nested
  list.  Need not be named with a .csv extension.  It should properly
  strip quotes from cells, and not break entries on commas embedded
  within quoted text.


\item[Usage]
\begin{verbatim}
		ReadCSV(<filename>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
	table <- ReadCSV("datafile.csv")
\end{verbatim}

\item[See Also]	\verb+FileReadTable()+, \verb+FileReadList+, \verb+StripQuotes+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Rectangle()+
  
\item[Description]	Creates a rectangle for graphing at x,y with size
  dx and dy. Rectangles are only currently definable oriented in
  horizontal/vertical directions.  A rectangle  must be added
  to a parent widget before it can be drawn; it may be added to
  widgets other than a base window.  The properties of rectangles may be
  changed by accessing their properties directly, including the FILLED
  property which makes the object an outline versus a filled shape.

\item[Usage]
\begin{verbatim}
Rectangle(<x>, <y>, <dx>, <dy>, <color>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  
  r <- Rectangle(30,30,20,10, MakeColor(green))
  AddObject(r, win)
  Draw()

\end{verbatim}
\item[See Also]	 \verb+Circle()+, \verb+Ellipse()+, \verb+Square()+, \verb+ Line()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+ReflectPoints+

\item[Description]  Takes a set of points (defined in a joined list 
[[x1,x2,x3,...],[y1,y2,y3,...]] and reflects them around the vertical
axis x=0, returning a similar [[x],[y]] list.  Identical to
\verb+ZoomPoints(pts,-1,1)+

\item[Usage]
\begin{verbatim}
  ReflectPoints(<points>)
\end{verbatim}

\item[Example] 
\begin{verbatim}
  points <- [[1,2,3,4],[20,21,22,23]]
  newpoints <- ReflectPoints(points)
\end{verbatim}

\item[See Also] \verb+ZoomPoints()+, \verb+RotatePoints+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+RegisterEvent()+ 

\item[Description]  Adds an event to the event loop.  This function is currently experimental, and its usage may change in future versions of PEBL.

\item[Usage]       	
\begin{verbatim}
USAGE CURRENTLY UNDOCUMENTED
\end{verbatim}

\item[Example]	

\item[See Also] 
\verb+ClearEventLoop()+, \verb+StartEventLoop()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+RemoveFile()+

\item[Description] Removes a file from the file system.
\item[Usage]
\begin{verbatim}
RemoveObject( <filename>)
\end{verbatim}

\item[Example]	

\begin{verbatim}
tmpfile <- FileOpenWrite("tmp.txt")
FilePrint(tmpfile,Random())
FileClose(tmpfile)
text <- FileReadText("tmp.txt")
RemoveFile("tmp.txt")
\end{verbatim}

\item[See Also]	
\item[See Also]\verb+GetDirectoryListing()+, \verb+FileExists()+,       \verb+IsDirectory()+,        
   \verb+MakeDirectory()+      
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+RemoveObject()+

\item[Description] Removes a child widget from a parent.  Useful if
  you are adding a local widget to a global window inside a loop.  If
  you do not remove the object and only \verb+Hide()+ it, drawing will
  be sluggish.  Objects that are local to a function are removed
  automatically when the function terminates, so you do not need to
  call \verb+RemoveObject()+ on them at the end of a function.

\item[Usage]
\begin{verbatim}
RemoveObject( <object>, <parent>)
\end{verbatim}

\item[Example]	

\item[See Also]	
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+RemoveSubset()+

\item[Description] Removes a subset of elements from a list. Creates
a new list, and does not affect the original

\item[Usage]
\begin{verbatim}
  RemoveSubset(<list1>,<list-of-element-indices>])
\end{verbatim}

\item[Example]	
\begin{verbatim}
 list1 <- [1,2,2,4,5]
 list2 <- RemoveSubset(list1,[2,3])
 Print(list1) #[1,2,2,4,5]
 Print(list2) #[1,4,5]
\end{verbatim}

\item[See Also]	
\verb+Merge()+, \verb+Insert()+, \verb+Rest()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+Repeat()+

\item[Description] 	Makes and returns a list by repeating \verb+<object>+ \verb+<n>+ times. 
		Has no effect on the object. Repeat will not make new copies 
		of the object. If you later change the object, 
		you will change every object in the list.

\item[Usage]       	
\begin{verbatim}
Repeat(<object>, <n>)
\end{verbatim}
	    	
\item[Example]     	
\begin{verbatim}
x <- "potato"
y <- repeat(x, 10)
Print(y)
# produces ["potato","potato","potato",
            "potato","potato", "potato",
            "potato","potato","potato","potato"]
\end{verbatim}
	     	     
\item[See Also]    	\verb+RepeatList()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+RepeatList()+

\item[Description]  	Makes a longer list by repeating a shorter list \verb+<n>+ times. 
	Has no effect on the list itself, but changes made to objects 
	in the new list will also affect the old list.

\item[Usage]       	
\begin{verbatim}
RepeatList(<list>, <n>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
RepeatList([1,2],3) # == [1,2,1,2,1,2]
\end{verbatim}

\item[See Also]    	\verb+Repeat()+, \verb+Merge()+, \verb+[ ]+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+Replace()+

\item[Description]  	Creates a copy of a (possibly nested) list in which
		items matching some list are replaced for other items.  
		\verb+<template>+ can be any data structure, and can be nested.  
		\verb+<replacementList>+ is a list containing two-item list pairs:
		the to-be-replaced item and to what it should be transformed.\\
		Note: replacement searches the entire \verb+<replacementList>+ for 
		matches.  If multiple keys are identical, the item will be 
		replaced with the last item that matches.

\item[Usage]        	
\begin{verbatim}
Replace(<template>,<replacementList>)
\end{verbatim}
			  
\item[Example]     	
\begin{verbatim}

x <- ["a","b","c","x"]
rep <- [["a","A"],["b","B"],["x","D"]]
Print(Replace(x,rep))
# Result:  [A, B, c, D] 
\end{verbatim}

\item[See Also]	
\verb+ReplaceChar()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]  \verb+ReplaceChar()+

\item[Description]  	Substitutes  \verb+<char2>+ for \verb+<char>+
  in \verb+<string>+. Useful for saving subject entry data in a file;
  replacing spaces with some other character.  The second argument can either be a character to match, or a list of characters to match, in which case they all get replaced with the third argument.

\item[Usage]        	
\begin{verbatim}
ReplaceChar(<string>,<char>,<char2>)
ReplaceChar(<string>,[<chara>, <charb>],<char2>)
\end{verbatim}
			  
\item[Example]     	
\begin{verbatim}

x <- ["Sing a song of sixpence"]
rep <- ReplaceChar(x," ", "_")
Print(rep)
# Result:  Sing_a_song_of_sixpence

x <- ["sing a song of sixpence"]
rep <- ReplaceChar(x,["s","x"], "p")
Print(rep)
# Result:  ping a pong of pippence
\end{verbatim}

\item[See Also]	
 for list items: \verb+Replace()+ , \verb+\SplitString()+, 
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]  \verb+ResetCanvas()+

\item[Description]  Resets a canvas, so that anything drawn onto it is
  erased and returned to its background color.  Implemented by
  resetting the background color to itself: 
\begin{verbatim}
  canvas.color <- canvas. 
\end{verbatim}
 The function does not return the canvas,
  but has the side effect of resetting it.


\item[Usage]        	
\begin{verbatim}
ResetCanvas(<list>)
\end{verbatim}
			  
\item[Example]     	
\begin{verbatim}

#create a canvas, add pixel noise, then reset and repeat.
define Start(p)
{
  gWin <- MakeWindow()
  canvas <- MakeCanvas(100,100,MakeColor("black"))
  AddObject(canvas,gWin); Move(canvas,300,300)
  Draw()
  white <- MakeColor("white")
  ##add pixel noise
  j <- 1
  while(j < 5)
   {
  i <- 1
  while(i < 200)
   {
     SetPixel(canvas,Round(Random()*100),
              Round(Random()*100),white)
     i <- i +1 
   }
  Draw()
  WaitForAnyKeyPress()
  ResetCanvas(canvas)
  Draw()
   j <- j + 1
  }
  WaitForAnyKeyPress()

}
\end{verbatim}

\item[See Also]	
\texttt+SetPixel()+, \texttt+MakeCanvas()+, \texttt+Draw()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  \verb+Rest()+

\item[Description]  Returns the 'rest' of a list; a list minus its
  first element.  If the list is empty or has a single member, it will
  return an empty list [].  This is a very common function in LISP.

\item[Usage]        	
\begin{verbatim}
Rest(<list>)
\end{verbatim}
			  
\item[Example]     	
\begin{verbatim}
x <- Sequence(1,5,1)
y <- Rest(x)
Print(rep)
# Result:  [2,3,4,5]
\end{verbatim}

\item[See Also]	
\verb+Insert()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]  \verb+RGBtoHSV()+

\item[Description]  Converts a color object to HSV values.  May be useful for computing color-space
distances an so on.  No HSVtoRGB is currently implemented.

\item[Usage]        	
\begin{verbatim}
RGBtoHSV(<color>)
\end{verbatim}
			  
\item[Example]     	
\begin{verbatim}

x <- RGBtoHSV(MakeColor("red))

\end{verbatim}

\item[See Also]	
   \verb+MakeColor()+, \verb+MakeColorRGB+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+return+

\item[Description]  	Enables a function to return a value.

\item[Usage]
\begin{verbatim}
define funcname()
{
 return 0
}
\end{verbatim}

\item[Example]	

\item[See Also]	
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Rotate()+

\item[Description] 	Returns a list created by rotating a list by \verb!<n>! items.  
		The new list will begin with the \verb!<n+1>!th item of the old 
		list (modulo its length), and contain all of its items in 
		order, jumping back to the beginning and ending with the \verb!<n>!th
		item. Rotate(\verb!<list>!,0) has no effect.  Rotate does not modify 
		the original list.

\item[Usage]
\begin{verbatim}
Rotate(<list-of-items>, <n>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
Rotate([1,11,111],1)  # == [11,111,1]
\end{verbatim}

\item[See Also]    	\verb+Transpose()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+RotatePoints+

\item[Description]  Takes a set of points (defined in a joined list 
\verb+[[x1,x2,x3,...],+ \verb+[y1,y2,y3,...]]+ and rotates them \verb+<angle>+ degrees
around the point \verb+[0,0]+,  returning a similar \verb+[[x],[y]]+ list.

\item[Usage]
\begin{verbatim}
  ZoomPoints(<points>,<angle>)
\end{verbatim}

\item[Example] 
\begin{verbatim}
  points <- [[1,2,3,4],[20,21,22,23]]
  newpoints <- RotatePoints(points,10)
\end{verbatim}

\item[See Also] \verb+ZoomPoints()+, \verb+ReflectPoints+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+Round()+

\item[Description] 	Rounds \verb+<num>+ to nearest integer, or if optional \verb+<precision>+ argument is included, to nearest $10^{-precision}$.

\item[Usage]        	
\begin{verbatim}
Round(<num>)
Round(<num>,<precision>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Round(33.23)       # == 33
Round(56.65)       # == 57
Round(33.12234,2)  # == 33.12
Round(43134.23,-2) # == 43100
\end{verbatim}

\item[See Also]     	\verb+Ceiling()+, \verb+Floor()+, \verb+AbsFloor()+, \verb+ToInt()+
\end{desc}

\vfill
\newpage
\sect{S}
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Sample()+

\item[Description] Samples a single item from a list, returning it.
  It is a bit more convenient at times than ShuffleN(list,1), which
  returns a list of length 1.  Implemented as First(ShuffleN(list,1))


\item[Usage]       	
\begin{verbatim}
Sample(<list>)
\end{verbatim}

\item[Example]   	
\begin{verbatim}
Sample([1,1,1,2,2])     # Returns a single number
Sample([1,2,3,4,5,6,7]) # Returns a single number
\end{verbatim}

\item[See Also]    	\verb+SeedRNG()+, \verb+Sample()+ \verb+ChooseN()+, \verb+SampleNWithReplacement()+, \verb+Subset()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+SampleN()+

\item[Description] Samples \verb+<number>+ items from list, returning
  a randomly- ordered list. Items are sampled without replacement, so
  once an item is chosen it will not be chosen again. If
  \verb+<number>+ is larger than the length of the list, the entire
  list is returned shuffled.  It differs from \verb+ChooseN+ in that
  \verb+ChooseN+ returns items in the order they appeared in the
  originial list.  It is implemented as \verb+Shuffle(ChooseN())+.

\item[Usage]       	
\begin{verbatim}
SampleN(<list>, <n>)
\end{verbatim}

\item[Example]   	
\begin{verbatim}
SampleN([1,1,1,2,2], 5)     # Returns 5 numbers
SampleN([1,2,3,4,5,6,7], 3) # Returns 3 numbers 
\end{verbatim}

\item[See Also]    	\verb+ChooseN()+, \verb+SampleNWithReplacement()+, \verb+Subset()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SampleNWithReplacement()+

\item[Description] \verb+SampleNWithReplacement+ samples
  \verb+<number>+ items from \verb+<list>+, replacing after each draw
  so that items can be sampled again.  \verb+<number>+ can be larger
  than the length of the list. It has no side effects on its
  arguments.  
\item[Usage]        	
\begin{verbatim}
SampleNWithReplacement(<list>, <number>)
\end{verbatim}

\item[Example] 	
\begin{verbatim}
x <- Sequence(1:100,1)
SampleNWithReplacement(x, 10)
# Produces 10 numbers between 1 and 100, possibly 
# repeating some.
\end{verbatim}

\item[See Also]     	\verb+SampleN()+, \verb+ChooseN()+, \verb+Subset()+
\end{desc}






\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+SetProperty+ 

\item[Description]  
Sets a a property of a custom object.   This works for custom or built-in objects, but new properties can only be set on custom object. This function works essentially identically to the obj.property assignment, but it allows you to create property names from input. It is used extensively for the PEBL parameter setting.
  
\item[Usage]       
     \verb+SetProperty(obj,property, value)+ 
\item[Example]

\begin{verbatim}
  obj <- MakeCustomObject("myobject")
  obj.taste <- "buttery"
  obj.texture <- "creamy"
  SetProperty(obj,"flavor","tasty")
  
  list <- GetPropertyList(obj)
  loop(i,list)
   {
     if(PropertyExists(obj,i)
      {
        Print(i  + ":  " + GetProperty(obj,i))
      }
   }
\end{verbatim}


\item[See Also]
\verb+GetProperty+, \verb+PropertyExists+, \verb+GetPropertyList+ \verb+MakeCustomObject+, \verb+PrintProperties+ 
\end{desc} 




\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SDTBeta()+

\item[Description] \verb+SDTBeta+ computes beta, as defined by signal detection theory.  

\item[Usage]        	
\begin{verbatim}
SDTBeta(<hr>, <far>)
\end{verbatim}

\item[Example] 	
\begin{verbatim}

  Print(SDTBeta(.1,.9))  #.67032
  Print(SDTBeta(.1,.5))  #.88692
  Print(SDTBeta(.5,.5))  #1
  Print(SDTBeta(.8,.9))  #0.918612
  Print(SDTBeta(.9,.95)) #0.954803
\end{verbatim}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+SaveAudioToWaveFile+

\item[Description] Saves a buffer, recorded using the GetAudioInputBuffer, to a .wav file for later analysis or archive.


\item[Usage]
\begin{verbatim}
SaveAudioToWaveFile(filename, buffer)
\end{verbatim}

This will save a .wav file of a buffer that was recorded (e.g., using GetVocalResponseTime).

See number-stroop.pbl in the stroop directory of the test battery and testaudioin.pbl in demo/ for examples.


\item[Example]	
\begin{verbatim}

      gResponseBuffer <- MakeAudioInputBuffer(5000)
	  resp0 <-  GetVocalResponseTime(gResponseBuffer,.35, 200)
      SaveAudioToWaveFile("output.wav",gResponseBuffer)		

\end{verbatim}
\item[See Also] 	\verb+GetVocalResponseTime()+, \verb+MakeAudioInputBuffer()+
\end{desc}




\item[See Also]\verb+SDTDPrime()+,
\end{desc}
\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SDTDPrime()+

\item[Description] \verb+SDTDPrime+ computes d-prime, as defined by
signal detection theory.  This is a measure of sensitivy based jointly
on hit rate and false alarm rate.

\item[Usage]        	
\begin{verbatim}
SDTDPrime(<hr>, <far>)
\end{verbatim}

\item[Example] 	
\begin{verbatim}

  Print(SDTDPrime(.1,.9))  #2.56431
  Print(SDTDPrime(.1,.5))  #1.28155
  Print(SDTDPrime(.5,.5))  #0
  Print(SDTDPrime(.8,.9))  #.43993
  Print(SDTDPrime(.9,.95)) #.363302

\end{verbatim}

\item[See Also]\verb+SDTBeta()+,
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+SetCheckbox()+

\item[Description]	
This sets the .status property of a checkbox and draws it.   Its state can also be updated using the the \texttt{ClickCheckBox()} function, which flips the current state. 

\item[Usage]
\begin{verbatim}
 SetCheckBox(obj, value)
  \end{verbatim}

\item[Example]      	


\begin{verbatim}
 ok <- MakeCheckbox("OK?",400,250,gWin,150)
 Draw()
 SetCheckBox(ok,1)
 Draw()	
 Wait(1000)
 SetCheckbox(ok,0)
 Draw()
 Wait(1000)
\end{verbatim}

Examples of its use can be found in demo\\ui.pbl
\item[See Also]	\verb+MakeCheckBox()+, \verb+ClickCheckBox()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]   \verb+SeedRNG()+

\item[Description] Seeds the random number generator with \verb+<num>+
  to reproduce a random sequence.  This function can be used cleverly
  to create a multi-session experiment: Start by seeding the RNG with
  a single number for each subject; generate the stimulus sequence,
  then extract the appropriate stimuli for the current block. Remember
  to \verb+RandomizeTimer()+ afterward if necessary.

\item[Usage] 
\begin{verbatim}
SeedRNG(<num>) 
\end{verbatim}

\item[Example]	

\begin{verbatim}
    ##This makes sure you get the same random order 
    ## across sessions for individual subjects.
     SeedRNG(gSubNum)
     stimTmp <- Sequence(1:100,1)
     stim <- Shuffle(stimTmp)
     RandomizeTimer()
\end{verbatim}

\item[See Also]	
     \verb+RandomizeTimer()+
\end{desc}
\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+SendData()+

\item[Description]	Sends data on network connection.  Example of
  usage in demo/nim.pbl. You can only send text data.

\item[Usage]
\begin{verbatim}
 SendData(<network>,<data_as_string>)
\end{verbatim}

\item[Example]	

On 'server':
\begin{verbatim}
  net <- WaitForNetworkConnection("localhost",1234)
  SendData(net,"Watson, come here. I need you.")
  CloseNetworkConnection(net)
\end{verbatim}
On Client:
\begin{verbatim}
  net <- ConnectToHost("localhost",1234)
  value <-  GetData(net,20)
  Print(value)
  CloseNetworkConnection(net)
##should print out "Watson, come here. I need you."
\end{verbatim}
\item[See Also]
  \verb+ConnectToIP+, \verb+ConnectToHost+, \verb+WaitForNetworkConnection+, \verb+GetData+, \verb+ConvertIPString+, \verb+CloseNetworkConnection+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]   	\verb+SegmentsIntersect()+

\item[Description] Determines whether two line segments, defined by
  four xy point pairs, intersect. Two line segments that share a
  corner return 0, although they could be considered to intersect.

This function is defined in pebl-lib/Graphics.pbl

\item[Usage] 
\begin{verbatim}
 SegmentsIntersect(x1,y1,x2,y2, 
                   a1,b1,a2,b2)
\end{verbatim}

\item[Example]
\begin{verbatim}
 SegmentsIntersect(1,0,2,0, 
                   1,2,2,2)  #0

 #returns 0, though they share (1,0)
 SegmentsIntersect(1,0,2,0,
                    1,0,2,2)  
 SegmentsIntersect(1,1,3,1,
                   2,2,2,0)  #1


\end{verbatim}

\item[See Also]    	\verb+GetAngle3+, \verb+ToRight+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]   	\verb+Sequence()+

\item[Description] Makes a sequence of numbers from \verb+<start>+ to
  \verb+<end>+ at \verb+<step>+-sized increments. If \verb+<step>+ is
  positive, \verb+<end>+ must be larger than \verb+<start>+, and if
  \verb+<step>+ is negative, \verb+<end>+ must be smaller than
  \verb+<start>+. If \verb!<start> + n*<step>! does not exactly equal
  \verb+<end>+, the last item in the sequence will be the number
  closest number to \verb+<end>+ in the direction of \verb+<start>+
  (and thus \verb+<step>+).

\item[Usage] 
\begin{verbatim}
Sequence(<start>, <end>, <step>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Sequence(0,10,3)    # == [0,3,6,9]
Sequence(0,10,1.5)  # == [0,1.5,3,4.5, 6, 7.5, 9]
Sequence(10,1,3)    # error
Sequence(10,0,-1)   # == [10,9,8,7,6,5,4,3,2,1]
\end{verbatim}

\item[See Also]    	\verb+Repeat()+, \verb+RepeatList()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SetCursorPosition()+

\item[Description] 	Moves the editing cursor to a specified character
		position in a textbox.

\item[Usage]
\begin{verbatim}
SetCursorPosition(<textbox>, <integer>)
\end{verbatim}

\item[Example]
\begin{verbatim}
SetCursorPosition(tb, 23)
\end{verbatim}

\item[See Also]   	\verb+SetEditable()+, \verb+GetCursorPosition()+, \verb+SetText()+, \verb+GetText()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SetEditable()+

\item[Description] Sets the ``editable'' status of the textbox.  All
  this really does is turns on or off the cursor; editing must be done
  with the (currently unsupported) device function \verb+GetInput()+.

\item[Usage] 
\begin{verbatim}
SetEditable()
\end{verbatim}

\item[Example]
\begin{verbatim}

SetEditable(tb, 0)
SetEditable(tb, 1)
\end{verbatim}

\item[See Also]    	\verb+GetEditable()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SetElement()+

\item[Description] Efficiently alter a specific item from a list.  \verb+SetElement+ has 
length-constant access time, and so it can be efficient to pre-create a list structure
and then populate it one-by-one.
	

\item[Usage]
\begin{verbatim}
SetElement(<list>, <index>, <value>)
\end{verbatim}

\item[Example]
\begin{verbatim}
 
 ##Set a random subset of elements to their index:
 list <- Repeat(0,10)
  index <- 1
  while(index <= 10)
  {
    if(Random()<.2)
     {
        SetElement(list,index,index)
      }
    index <- index + 1
   }

\end{verbatim}

\item[See Also]   	\verb+Nth()+, \verb+Append()+, \verb+PushOnEnd()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SetFont()+

\item[Description] Resets the font of a textbox or label.  Change will
  not appear until the next \verb+Draw()+ function is called.  Can be
  used, for example, to change the color of a label to give richer
  feedback about correctness on a trial (see example below).  Font can
alse be set by assigning to the object.font property of an object.

\item[Usage]
\begin{verbatim}
SetFont(<text-widget>, <font>)
\end{verbatim}

\item[Example]   	
\begin{verbatim}
fontGreen <- MakeFont("vera.ttf",1,22, 
                      MakeColor("green"),
                      MakeColor("black"), 1)
fontRed   <- MakeFont("vera.ttf",1,22,
                      MakeColor("red"),
                      MakeColor("black"), 1)
label <- MakeLabel(fontGreen, "Correct")

#Do trial here.       	

if(response == 1)
{
SetText(label, "CORRECT")
SetFont(label, fontGreen)
} else {
SetText(label, "INCORRECT")
SetFont(label, "fontRed)
}
Draw()
\end{verbatim}

\item[See Also]    	\verb+SetText()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+SetMouseCursorPosition()+

\item[Description] Sets the current x,y coordinates of the mouse
  pointer, 'warping' the mouse to that location immediately

\item[Usage]
\begin{verbatim}
   SetMouseCursorPosition(<x>,<y>)
\end{verbatim}

\item[Example]	
\begin{verbatim}

  ##Set mouse to center of screen:
  SetMouseCursorPosition(gVideoWidth/2,
                         gVideoHeight/2)
\end{verbatim}


\item[See Also]
  \verb+ShowCursor+, \verb+WaitForMouseButton+,
  \verb+SetMouseCursorPosition+, \verb+GetMouseCursorPosition+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+SetPixel()+, \verb+SetPoint()+

\item[Description] Sets the pixel at x,y to a particular color.  It
  can also be called using SetPoint().  SetPoint is primarily useful
  for images and canvases--labels and textboxes get re-rendered upon
  draw so any use of SetPixel will get overwritten when it gets
  drawn.  It won't work on windows or shapes.

\item[Usage]
\begin{verbatim}
   SetPixel(<x>,<y>,<color>)
   SetPoint(<x>,<y>,<color>)
\end{verbatim}

\item[Example]	
\begin{verbatim}

  back <- MakeCanvas(50,50)
  AddObject(back,gWin)
  col <- MakeColor("green")
  xy <- [[10,10],[10,11],[10,12],[10,13]]
   loop(i,xy)
   {
    SetPixel(First(i),Second(i),col)
   }
  Draw()
\end{verbatim}


\item[See Also]
  \verb+SetPoint+, \verb+MakeGabor+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+SetPPortMode+ 

\item[Description]  
  Sets a parallel port mode, either "<input>" or "<output>".
  
\item[Usage]       
     \verb+SetPPortMode("<input>")+ 
\item[Example]

\item[See Also]
\verb+COMPortGetByte+, \verb+COMPortSendByte+, \verb+OpenPPort+ \verb+OpenCOMPort+, \verb+SetPPortMode+, \verb+GetPPortState+ 
\end{desc} 

\begin{desc}{Name/Symbol}
\item[Name/Symbol] \verb+SetPPortState+ 

\item[Description]  
  Sets a parallel port state, using a list of 8 'bits' (1s or 0s).
  
\item[Usage]       
     \verb+SetPPortState([0,0,0,0,0,0,0,0])+ 
\item[Example]


\item[See Also]
\verb+COMPortGetByte+, \verb+COMPortSendByte+, \verb+OpenPPort+ \verb+OpenCOMPort+, \verb+SetPPortMode+, \verb+GetPPortState+ 
\end{desc} 


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+SetScrollingText()+

\item[Description]	
This updates the text in a \verb+ScrollingTextBox+. Because text must be parsed to be put into the box, you cannot just update the .text property, but instead should use this function.

\item[Usage]
\begin{verbatim}
 SetScrollingText(stb, newtext)
  \end{verbatim}

Here,  \texttt{stb} is a scrolling textbox created with \verb|MakeScrollingTextBox|, and \texttt{newtext} is the new text you want to display.


\item[Example]      	
See ui.pbl in the demo directory for examples of the use of a scrolling text box.  A brief example follows:

\begin{verbatim}
  textscroll <- MakeScrollingTextBox("",200,50,gWin,12,
                                        300,150,0)

  SetScrollingText(textscroll,FileReadText("Uppercase.txt"))
   Draw()
  resp <- WaitForClickOntarget([textscroll],[1])
   CallFunction(textscroll.clickon,[textscroll,gClick]) 
\end{verbatim}

\item[See Also]
\verb+MakeScrollingTextBox+
\verb+MakeScrollBox+
\verb+UpdateScrollBox+
\verb+DrawScrollBox+
\verb+ClickOnScrollBox+
\end{desc}




\begin{desc}{Name/Symbol}

\item[Name/Symbol] 	\verb+SetText()+

\item[Description] 	Resets the text of a textbox or label.  Change will not
		appear until the next \verb+Draw()+ function is called.  The
object.text property can also be used to change text of an object, by
doing: \verb+object.text <- "new text"+

\item[Usage]
\begin{verbatim}
SetText(<text-widget>, <text>)
\end{verbatim}

\item[Example]
\begin{verbatim}
# Fixation Cross:
label <- MakeLabel(font, "+")
Draw()

SetText(label, "X")
Wait(100)
Draw()
\end{verbatim}

\item[See Also]    	\verb+GetText()+, \verb+SetFont()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Show()+

\item[Description] Sets a widget to visible, once it has been added to
  a parent widget.  This just changes the visibility property, it does
  not make the widget appear.  The widget will not be displayed until
  the \verb+Draw()+ function is called.  The .visible property of
objects can also be used to hide or show the object.

\item[Usage]
\begin{verbatim}
Show(<object>)
\end{verbatim}

\item[Example]
\begin{verbatim}
window <- MakeWindow()
image1  <- MakeImage("pebl.bmp")
image2  <- MakeImage("pebl.bmp")
AddObject(image1, window)
AddObject(image2, window)
Hide(image2)
Draw()
Wait(300)
Show(image2)
Draw()
\end{verbatim}

\item[See Also]     	\verb+Hide()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ShowCursor()+

\item[Description] Hides or shows the mouse cursor.  Currently, the
  mouse is not used, but on some systems in some configurations, the
  mouse cursor shows up.  Calling \verb+ShowCursor(0)+ will turn off the
  cursor, and \verb+ShowCursor(1)+ will turn it back on.  Be sure to turn it
  on at the end of the experiment, or you may actually lose the cursor
  for good.

\item[Usage]
\begin{verbatim}
ShowCursor(<value>)
\end{verbatim}

\item[Example]
\begin{verbatim}
window <- MakeWindow()
ShowCursor(0)
## Do experiment here
##

## Turn mouse back on.
ShowCursor(1)
\end{verbatim}
\item[See Also] 
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+Shuffle()+

\item[Description] 	Randomly shuffles a list.

\item[Usage]    
\begin{verbatim}
Shuffle(list)
\end{verbatim}

\item[Example]
\begin{verbatim}
Print(Shuffle([1,2,3,4,5]))
# Results might be anything, like [5,3,2,1,4]
\end{verbatim}

\item[See Also]    	\verb+Sort()+, \verb+SortBy()+, \verb+ShuffleRepeat()+,
                    \verb+ShuffleWithoutAdjacents()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+ShuffleRepeat()+

\item[Description] 	Randomly shuffles  \verb+<list>+, repeating \verb+<n>+ times.  Shuffles  each iteration of the list separately, so you are guaranteed to go  through all elements of the list before you get another.  Returns a nested list.

\item[Usage]    
\begin{verbatim}
ShuffleRepeat(<list>, <n>)
\end{verbatim}


\item[Example]
\begin{verbatim}
Print(ShuffleRepeat([1,2,3,4,5]),3)
##  Results might be anything, like:
## [[5,3,2,1,4], [3,2,5,1,4], [1,4,5,3,2]]
\end{verbatim}

Typically, you will want to flatten before using:
\begin{verbatim}
list <-  Flatten(ShuffleRepeat([1,2,3], 5))
\end{verbatim}

\item[See Also]    	\verb+Sort()+, \verb+SortBy()+, \verb+ShuffleRepeat()+,
                    \verb+ShuffleWithoutAdjacents()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+ShuffleWithoutAdjacents()+

\item[Description] 	Randomly shuffles  \verb+<nested-list>+, attempting to
  create a list where the nested elements do not appear adjacently in
  the new list. Returns a list that is flattened one level. It will
  always return a shuffled list, but it is not guaranteed to return
  one that has the non-adjecent structure specified, because this is
  sometimes impossible or very difficult to do randomly.  Given small
  enough non-adjacent constraints with enough fillers, it should be
  able to find something satisfactory.

\item[Usage]    
\begin{verbatim}
ShuffleWithoutAdjacents(<nested-list>)
\end{verbatim}

\item[Example]

\begin{verbatim}
Print(ShuffleWithoutAdjacents([[1,2,3],
                               [4,5,6],
                               [7,8,9]])
## Example Output: 
## [8, 5, 2, 7, 4, 1, 6, 9, 3]
## [7, 4, 8, 1, 9, 2, 5, 3, 6]

## Non-nested items are shuffled without constraint
Print(ShuffleWithoutAdjacents([[1,2,3], 
                              11,12,13,14,15,16]))
## output: [13, 11, 2, 14, 3, 15, 1, 16, 12]
##         [13, 12, 2, 16, 15, 11, 1, 14, 3]
##         [11, 1, 15, 2, 12, 16, 14, 13, 3]

## Sometimes the constraints cannot be satisfied.  
## 9 will always appear in position 2
Print(ShuffleWithoutAdjacents([[1,2,3], 9])
## output: [3, 9, 1, 2]
##         [2, 9, 3, 1]
##         [3, 9, 2, 1]
\end{verbatim}

\item[See Also]    	\verb+Shuffle()+, \verb+Sort()+, \verb+SortBy()+,
        \verb+ShuffleRepeat()+, \verb+ShuffleWithoutAdjacents()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+Sign()+

\item[Description] 	Returns +1 or -1, depending on sign of argument.

\item[Usage]
\begin{verbatim}
Sign(<num>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Sign(-332.1)  # == -1
Sign(65)      # == 1

\end{verbatim}

\item[See Also]     	\verb+Abs()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SignalFatalError()+

\item[Description] Stops PEBL and prints \verb+<message>+ to stderr.
  Useful for type-checking in user-defined functions.

\item[Usage]
\begin{verbatim}
SignalFatalError(<message>)
\end{verbatim}
\item[Example]
\begin{verbatim}

If(not IsList(x))
{
 SignalFatalError("Tried to frobnicate a List.")
}
##Prints out error message and 
##line/filename of function
\end{verbatim}

\item[See Also]     	\verb+Print()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Sin()+

\item[Description]  	Sine of \verb+<deg>+ degrees.

\item[Usage]        	
\begin{verbatim}
Sin(<deg>)
\end{verbatim}
\item[Example]
\begin{verbatim}
 Sin(180)
 Sin(0)
\end{verbatim}
\item[See Also]    	\verb+Cos()+, \verb+Tan()+, \verb+ATan()+, \verb+ACos()+, \verb+ATan()+ 
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+Sort()+

\item[Description] 	Sorts a list by its values from smallest to largest.

\item[Usage]       	
\begin{verbatim}
Sort(<list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Sort([3,4,2,1,5]) # == [1,2,3,4,5]
\end{verbatim}

\item[See Also]    	\verb+SortBy()+, \verb+Shuffle()+
\end{desc}

\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SortBy()+

\item[Description] 	Sorts a list by the values in another list, in ascending
		order.

\item[Usage]
\begin{verbatim}
SortBy(<value-list>, <key-list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
SortBy(["Bobby","Greg","Peter"], [3,1,2]) 
# == ["Greg","Peter","Bobby"]
\end{verbatim}

\item[See Also]    	\verb+Shuffle()+, \verb+Sort()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+SplitString()+

\item[Description]	Splits a string into tokens. \verb+<split>+ must be a string. If 
		\verb+<split>+ is not found in \verb+<string>+, a list containing the entire 
		string is returned; if split is equal to \verb+""+, the each letter 
		in the string is placed into a different item in the list.  Only the first character of \verb+<split>+ is used.  IF you need a multicharacter split, you can use \verb+<SplitStringSlow>+, which can handle multi-character splits but is relatively slower. This should not matter for short strings, but if you are using splitstring on long files, it could make a difference.


\item[Usage]
\begin{verbatim}
SplitString(<string>, <split>)
\end{verbatim}

\item[Example]      	
\begin{verbatim}
SplitString("Everybody Loves a Clown", " ") 
# Produces ["Everybody", "Loves", "a", "Clown"]
\end{verbatim}

\item[See Also]     	\verb+FindInString()+, \verb+ReplaceChar+, \verb+SplitStringSlow+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+SplitStringSlow()+

\item[Description]	Splits a string into tokens. \verb+<split>+ must be a string. If 
		\verb+<split>+ is not found in \verb+<string>+, a list containing the entire 
		string is returned; if split is equal to \verb+""+, the each letter 
		in the string is placed into a different item in the list.  The entire text of \verb+<split>+ is used to tokenize, but as a consequence this function is relatively slow, and should be avoided if your string is longer than a few hundred characters.

\item[Usage]
\begin{verbatim}
SplitStringSlow(<string>, <split>)
\end{verbatim}

\item[Example]      	
\begin{verbatim}
SplitStringSlow("Everybody Loves a Clown", " ") 
# Produces ["Everybody", "Loves", "a", "Clown"]
SplitStringSlow("she sells seashells", "ll")
#produces ["she se","s seashe", "s"] 

\end{verbatim}

\item[See Also] \verb+Splitstring+     	\verb+FindInString()+, \verb+ReplaceChar+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Square()+
  
\item[Description]	Creates a square for graphing at x,y with size
  \verb+<size>+. Squares are only currently definable oriented in
  horizontal/vertical directions.  A square  must be added
  to a parent widget before it can be drawn; it may be added to
  widgets other than a base window.  The properties of squares may be
  changed by accessing their properties directly, including the FILLED
  property which makes the object an outline versus a filled shape.

\item[Usage]
\begin{verbatim}
Ellipse(<x>, <y>, <size>, <color>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  
  s <- Square(30,30,20, MakeColor(green))
  AddObject(s, win)
  Draw()

\end{verbatim}
\item[See Also]	 \verb+Circle()+, \verb+Ellipse()+, \verb+Rectangle()+, \verb+Line()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Sqrt()+ 

\item[Description]  	Square root of \verb+<num>+.

\item[Usage]        	
\begin{verbatim}
Sqrt(<num>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Sqrt(100)  # == 10
\end{verbatim}

\item[See Also]	
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+StartEventLoop()+ 

\item[Description]  Starts the event loop with currently-registered events.  This function is currently experimental, and its usage may change in future versions of PEBL.

\item[Usage]       	
\begin{verbatim}
StartEventLoop()        
\end{verbatim}

\item[Example]	

\item[See Also] 
\verb+RegisterEvent()+, \verb+ClearEventLoop()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+StartPlayback()+
 
\item[Description] Initiates playback of a movie so that it will play in the background
when a Wait() or WaitFor() function is called.  This allows one to collect a response while 
playing a movie.  The movie will not actually play until the event loop is started, typically
with something like Wait().

\item[Usage]		
\begin{verbatim}
StartPlayBack(movie)
\end{verbatim}

\item[Example]	
\begin{verbatim}
   movie <- LoadMovie("movie.avi",gWin,640,480)
   PrintProperties(movie)
   Move(movie,20,20)
   Draw() 
   StartPlayback(movie)
   Wait(500) #Play 500 ms of the movie.
   PausePlayback(movie)
\end{verbatim}

\item[See Also] \verb+LoadAudioFile()+, \verb+LoadMovie()+, \verb+PlayMovie()+, \verb+PausePlayback()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+StDev()+ 

\item[Description]  Returns the standard deviation of \verb+<list>+.

\item[Usage]       	
\begin{verbatim}
StDev(<list>)        
\end{verbatim}

\item[Example]	
\begin{verbatim}
   sd <- StDev([3,5,99,12,1.3,15])        
\end{verbatim}

\item[See Also]     	\verb+Min()+, \verb+Max()+, \verb+Mean()+, \verb+Median()+, \verb+Quantile()+, \verb+Sum()+
\end{desc}






\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Stop()+	

\item[Description] Stops a sound playing in the background from
  playing.  Calling \verb+Stop()+ on a sound object that is not
  playing should have no effect, but if an object is aliased,
  \verb+Stop()+ will stop the file.  Note that sounds play in a
  separate thread, so interrupting the thread has a granularity up to
  the duration of the thread-switching quantum on your computer; this
  may be tens of milliseconds.

\item[Usage]
\begin{verbatim}
Stop(<sound-object>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
buzz <- LoadSound("buzz.wav")
PlayBackground(buzz)
Wait(50)
Stop(buzz)
\end{verbatim}

\item[See Also]    	\verb+PlayForeground()+, \verb+PlayBackGround()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+StringLength()+

\item[Description] 	Determines the length of a string, in characters.

\item[Usage]
\begin{verbatim}
StringLength(<string>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
StringLength("absolute")     # == 8
StringLength("   spaces   ") # == 12
StringLength("")             # == 0
\end{verbatim}

\item[See Also]    	\verb+Length()+, \verb+SubString()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+StripQuotes()+

\item[Description] 	Strips quotation marks from the outside of a
  string.  Useful if you are reading in data that is quoted.


\item[Usage]
\begin{verbatim}
StripQuotes(<text>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
 text <- gQuote + "abcd" + gQuote
 Print(StripQuotes(text))  ## abcd
 Print(StripQuotes("aaa")) ##aaa
\end{verbatim}

\item[See Also]    	\verb+StripSpace()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+StripSpace()+

\item[Description] 	Strips spaces from the start and end of a
  string.  Useful for cleaning up input and such.


\item[Usage]
\begin{verbatim}
StripSpaces(<text>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
 text <-  " abcd  "
 Print(StripSpace(text))  ## 'abcd'
 Print(StripSpace("aaa")) ## 'aaa'
\end{verbatim}

\item[See Also]    	\verb+StripQuotes()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+SubList()+

\item[Description] 	Extracts a list from another list, by specifying 
	     	beginning and end points of new sublist.

\item[Usage]
\begin{verbatim}
SubList(<list>, <begin>, <end>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
SubList([1,2,3,4,5,6],3,5)	# == [3,4,5]
\end{verbatim}

\item[See Also]    	\verb+SubSet()+, \verb+ExtractListItems()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Subset()+

\item[Description] Extracts a subset of items from another list,
  returning a new list that includes items from the original list only
  once and in their original orders.  Item indices in the second
  argument that do not exist in the first argument are ignored.  It
  has no side effects on its arguments.  

\item[Usage]       	
\begin{verbatim}
Subset(<list>, <list-of-indices>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
Subset([1,2,3,4,5,6],[5,3,1,1])	# == [1,3,5]
Subset([1,2,3,4,5], [23,4,2])		# == [2,4]
\end{verbatim}

\item[See Also]   	\verb+SubList()+, \verb+ExtractItems()+, \verb+SampleN()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+SubString()+

\item[Description]  	Extracts a substring from a longer string.

\item[Usage]
\begin{verbatim}
SubString(<string>,<position>,<length>)
\end{verbatim}
  If position is larger than the length of the string, an empty string
  is returned.  If position + length exceeds the length of the string,
  a string from \verb+<position>+ to the last character of the string
  is returned.

\item[Example]
\begin{verbatim}
SubString("abcdefghijklmnop",3,5)	# == "cdefg"
\end{verbatim}

\item[See Also]	
\end{desc}







\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Sum()+ 

\item[Description]  Returns the sum  of \verb+<list>+.

\item[Usage]       	
\begin{verbatim}
Sum(<list>)        
\end{verbatim}

\item[Example]	
\begin{verbatim}
   sum <- StDev([3,5,99,12,1.3,15])      # == 135.3
\end{verbatim}

\item[See Also]     	\verb+Min()+, \verb+Max()+, \verb+Mean()+, \verb+Median()+, \verb+Quantile()+, \verb+StDev()+
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+SummaryStats()+

\item[Description] Computes summary statistics for a data list,
  aggregated by labels in a condition list.
For each condition (distinct label in the \verb+<cond>+ list), it will 
return a list with the following entries:
\verb+<cond>+ \verb+<N>+ \verb+<median>+ \verb+<mean>+ \verb+<sd>+

\item[Usage]		
\begin{verbatim}
SummaryStats(<data>,<cond>)        
\end{verbatim}

\item[Example]	
\begin{verbatim}
  dat <- [1.1,1.2,1.3,2.1,2.2,2.3]
  cond <- [1,1,1,2,2,2]
  Print(SummaryStats(dat,cond))
\end{verbatim}
Result:
\begin{verbatim}
[[1, 3, 1.1, 1.2, 0.0816497]
, [2, 3, 2.1, 2.2, 0.0816497]
]
\end{verbatim}
\item[See Also]	
  	\verb+StDev()+, \verb+Min()+, \verb+Max()+, \verb+Mean()+, \verb+Median()+, \verb+Quantile()+, \verb+Sum()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+SystemCall()+

\item[Description] Calls/runs another operating system command.  Can also be used to 
launch another PEBL program.  Useful to check GetSystemType() before running.

 Note that the output of a
   command-line argument is generally not passed back into PEBL; just
   the function's return code, which is usually 0 on success or some
   other number on failure (depending upon the type of failure).  Some
   uses might include:

\item[Usage]		
\begin{verbatim}
SystemCall("text-of-command")
SystemCall("text-of-command","command-line-options")
\end{verbatim}

\item[Example]	
\begin{verbatim}
   if(GetSystemType() == "WINDOWS")
     {
       x <- SystemCall("dir input.txt") 
     } else {
       x <- SystemCall("ls input.txt") 
     }
      if(x <> 0)
      {
         SignalFatalError("Expected file ["+
               "input.txt] does not exist")
      }


\end{verbatim}

\item[See Also]	
  \verb+GetSystemType()+
\end{desc}

\vfill
\newpage
\sect{T}
\vfill



\begin{desc}{Name/Symbol}

\item[Name/Symbol] \verb+Tab()+

\item[Description]  Produces a tab character which can be added to a
  string. If displayed in a text box, it will use a 4-item tab stop.

\item[Usage]        \verb!Tab(3)!


\item[Example]     
\begin{verbatim}
         Print("Number: "  Tab(1) + number )
         Print("Value: "  Tab(1) + value )
         Print("Size: "  Tab(1) + size )
\end{verbatim}
\item[See Also]
\verb+Format()+, \verb+CR()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Tan()+	

\item[Description] 	Tangent of \verb+<deg>+ degrees.

\item[Usage]       	
\begin{verbatim}
Tan(<deg>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Tan(180)
\end{verbatim}

\item[See Also]    	\verb+Cos()+, \verb+Sin()+, \verb+ATan()+, \verb+ACos()+, \verb+ATan()+ 
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ThickLine()+	

\item[Description] 	Makes a thick line between two coordinates. This just creates
  a polygon object to serve as the line.

\item[Usage]       	
\begin{verbatim}
ThickLine(<x1>,<y1>,<x2>,<y2>,
          <size-in-pixels>,<color>)
\end{verbatim}

\item[Example]
\begin{verbatim}
   

   a <- ThickLine(10,10,300,400,20,
                MakeColor("red"))
   AddObject(a,gWin)
   Draw()

\end{verbatim}

\item[See Also]  \verb+Line()+, \verb+Polygon()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+TimeStamp()+

\item[Description] Returns a string containing the date-and-time,
  formatted according to local conventions. Should be used for
  documenting the time-of-day and date an experiment was run, but not
  for keeping track of timing accuracy.  For that, use
  \verb+GetTime()+.
	     
\item[Usage]
\begin{verbatim}
TimeStamp()
\end{verbatim}

\item[Example]
\begin{verbatim}
a <- TimeStamp()
Print(a)
\end{verbatim}

\item[See Also]     	\verb+GetTime()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ToInteger()+
              
\item[Description]  	Rounds a number to an integer, changing internal 
		representation.

\item[Usage]
\begin{verbatim}
ToInteger(<number>)
ToInteger(<floating-point>)
ToInteger(<string-as-number>)
\end{verbatim}

\item[Example]
\begin{verbatim}
ToInteger(33.332)  # == 33
ToInteger("3213")  # == 3213
\end{verbatim}

\item[See Also]    	\verb+Round()+, \verb+Ceiling()+, \verb+AbsCeiling()+, \verb+Floor()+, \verb+AbsFloor()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ToFloat()+

\item[Description] 	Converts number to internal floating-point representation.

\item[Usage]
\begin{verbatim}
ToFloat(<number>)
\end{verbatim}

\item[Example]	

\item[See Also]	
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ToNumber()+

\item[Description] Converts a variant to a number. Most useful for
  character strings that are interpretable as a number, but may also
  work for other subtypes.

\item[Usage]     
\begin{verbatim}
ToNumber(<string)
ToNumber(<number>)
\end{verbatim}

\item[Example]
\begin{verbatim}
a <- ToNumber("3232")
Print(a + 1)		# produces the output 3233. 
\end{verbatim}

\item[See Also]     	\verb+ToString()+, \verb+ToFloat()+, \verb+Round()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ToRight()+
              
\item[Description]  	Determines whether a point p3 is 'to the right'
  of a line segment defined by p1  to p2.  Works essentially by
  computing the determinant.

\item[Usage]
\begin{verbatim}
  ToRight(<p1>,<p2>,<p3>)
\end{verbatim}

\item[Example]
\begin{verbatim}
  a <- [100,0]
  b <- [100,100]
  c <- [150,50]
  ToRight(a,b,c) # returns 1; true
  ToRight(b,a,c) # returns 0; false

\end{verbatim}

\item[See Also]  
\verb+GetAngle()+ \verb+GetAngle3+, \verb+SegmentsIntersect+
\end{desc}






\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ToString()+

\item[Description] Converts value to a string representation. Most
  useful for numerical values.  This conversion is done automatically
  when strings are combined with numbers.

\item[Usage]     
\begin{verbatim}
ToString(<number>)
ToString(<string>)
\end{verbatim}

\item[Example]
\begin{verbatim}
a <- ToString(333.232)
Print(a + "111")
# produces the output '333.232111'.
\end{verbatim}
		

\item[See Also] \verb+ToString()+, \verb|+|.
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+TranslateKeyCode()+

\item[Description] Translates a code corresponding to a keyboard key
  into a keyboard value.  This code is returned by some event/device
  polling functions.

\item[Usage]		

\item[Example]	

\item[See Also]	
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Transpose()+

\item[Description] Transposes or ``rotates'' a list of lists.  Each
  sublist must be of the same length.

\item[Usage]       	
\begin{verbatim}
Transpose(<list-of-lists>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
Transpose([[1,11,111],[2,22,222],
           [3,33,333], [4,44,444]])
# == [[1,2,3,4],[11,22,33,44],
#      [111,222,333,444]]
\end{verbatim}

\item[See Also]    	\verb+Rotate()+
\end{desc}

\vfill
\newpage
\sect{U}
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+UpdatePulldown()+

\item[Description]	
This changes the list being used in a Pulldown object.  It tries to maintain the same selected option (matching the text of the previous selection), but if not found will select index 1. It calls \verb+DrawPullDown+ when complete, but a \verb+Draw()+ command must be issued before the pulldown changes will appear.

\item[Usage]
\begin{verbatim}
 UpdatePullDown(object, newlist)
 \end{verbatim}

\item[Example]      	
\begin{verbatim}
 options  <- MakePulldownButton(["A",B","C"],400,250,gWin,14,100,3)
 Draw()
 WaitForAnyKeyPress()
 
 ##This should add a fourth option but C should still be selected.
 UpdatePullDown(options,["A","B","C","D"])
 Draw()
 WaitForAnyKeyPress()

\end{verbatim}

\item[See Also]	\verb+MakePullDown()+, \verb+Pulldown()+, \verb+DrawPulldown+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+UpdateScrollbox()+

\item[Description]	
This updates the layout of a \verb+ScrollBox+. It should be used if you manually change the .list or .listoffset properties.  It won't actually redraw the scrollbox (which is done by DrawScrollbox).

\item[Usage]
\begin{verbatim}
 UpdateScrollBox(sb)
  \end{verbatim}

Here,  \texttt{sb} is the scrollbox object.

\item[Example]      	
See ui.pbl in the demo directory for examples of the use of a scrolling text box.  A brief example follows:

\begin{verbatim}
   sb <- MakeScrollBox(Sequence(1,50,1),"The numbers",40,40,gWin,12,150,500,3)
   Draw()
	  
   resp <- WaitForClickOntarget([sb],[1])
   CallFunction(sb.clickon,[sb,gClick])
   #Alternately: ClickOnScrollbox(sb,gClick) 
 
   ##change the selected items
   sb.list <- Sequence(sb.selected,sb.selected+50,1)
   UpdateScrollbox(sb)      
   DrawScrollbox(sb)
   Draw()
 
\end{verbatim}

\item[See Also]
\verb+MakeScrollingTextBox+
\verb+MakeScrollBox+
\verb+DrawScrollBox+
\verb+ClickOnScrollBox+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Uppercase()+

\item[Description]  	Changes a string to uppercase.  Useful for testing user
	      	input against a stored value, to ensure case differences
	      	are not detected.

\item[Usage]
\begin{verbatim}
Uppercase(<string>)
\end{verbatim}

\item[Example]     
\begin{verbatim}
Uppercase("POtaTo")  # == "POTATO"
\end{verbatim}

\item[See Also]     	\verb+Lowercase()+
\end{desc}

\vfill
\newpage
\sect{W}
\vfill



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Wait()+ 

\item[Description] 	Waits the specified number of milliseconds, then returns. 

\item[Usage]
\begin{verbatim}
Wait(<time>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Wait(100)
Wait(15)
\end{verbatim}

\item[See Also]	
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForAllKeysUp()+

\item[Description]	
               Wait until all keyboard keys are in the up
               position. This includes numlock, capslock, etc.
\item[Usage]		

\item[Example]	

\item[See Also]	

\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForAnyKeyDown()+

\item[Description]	
             Waits for any key to be detected in the down position.
             This includes numlock, capslock, etc, which can be locked
             in the down position even if they are not being held
             down.  Will return immediately if a key is being held
             down before the function is called. 

\item[Usage]		

\item[Example]	

\item[See Also]	
            \verb+WaitForAnyKeyPress()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForAnyKeyDownWithTimeout()+

\item[Description] Waits until any key is detected in the down position, but will return
  after a specified number of milliseconds.

\item[Usage]
\begin{verbatim}
WaitForAnyKeyDownWithTimeout(<time>)
\end{verbatim}

\item[Example]	

\item[See Also]	
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForClickOnTarget()+

\item[Description]	
  Allows you to specify a list of graphical objects in \verb+<objectlist>+ and awaits a click
  on any one of them, returning the corresponding key in <keylist>.  Also, sets the 
  global variable gClick which saves the location of the click, if 
  you need it for something else.
\item[Usage]		
\begin{verbatim}
  x <- WaitForClickOnTarget(<objectlist>,<keylist>)
\end{verbatim}

\item[Example]	

\begin{verbatim}
  resp <- Sequence(1,5,1)
  objs <- []
  loop(i,resp)
  {
    tmp <- EasyLabel(i +". ",
             100+50*i,100,gWin,25)
    objs <- Append(objs, tmp)
  }
  Draw()
  click  <- WaitForClickOnTarget(objs,resp)
  Print("You clicked on " + click)
  Print("Click location: [" + First(gClick) + 
        ", " + Second(gClick) + "]")
\end{verbatim}
\item[See Also]	
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForClickOnTargetWithTimeout()+

\item[Description]	
  Allows you to specify a list of graphical objects in \verb+<objectlist>+ and awaits a click
  on any one of them, returning the corresponding key in \verb+<keylist>+.  Also, sets the 
  global variable gClick which saves the location of the click, if 
  you need it for something else.  The function will return after the specified time limit.

  If no response is made by timeout, the text <timeout> will be returned (instead of the correspnoding keylist element),
and gClick will be set to [-1, -1].

This function can also be useful to dynamically update some visual object while waiting for
a response.  Give timeout some small number (below 50 ms, as low as 1-5), and loop over this
repeatedly until a 'proper' response is given, redrawing a timer or other dynamic visual element
each time.

\item[Usage]		
\begin{verbatim}
  x <- WaitForClickOnTarget(<objectlist>,<keylist>,<timeout-in-ms>)
\end{verbatim}

\item[Example]	

\begin{verbatim}
  resp <- Sequence(1,5,1)
  objs <- []
  loop(i,resp)
  {
    tmp <- EasyLabel(i +". ",
             100+50*i,100,gWin,25)
    objs <- Append(objs, tmp)
  }
  Draw()
  click  <- WaitForClickOnTargetWithTimeout(objs,resp,3000)
  Print("You clicked on " + click)
  Print("Click location: [" + First(gClick) + 
        ", " + Second(gClick) + "]")
\end{verbatim}
\item[See Also]	
  \verb+WaitForDownClick()+, \verb+WaitForMouseButton()+
\end{desc}





\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForDownClick()+

\item[Description]	Will wait until the mouse button is clicked down.  Returns
  the same 4-tuple as \verb+WaitForMouseButton:+
\begin{verbatim}
 [xpos,
   ypos, 
   button id [1-3], 
   "<pressed>" or "<released>"]
\end{verbatim}
 but the last element will always be \verb+<pressed>+.
 Useful as a 'click mouse to continue' probe.

\item[Usage]		
 \verb+ WaitForDownClick()+

\item[Example]	
\begin{verbatim}
  x <- WaitForDownClick()
  Print("Click location: [" + First(x) + 
        ", " + Second(x) + "]")  
\end{verbatim}

\item[See Also]	
  \verb+WaitForClickOnTarget()+, \verb+WaitForMouseButton()+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForKeyListDown()+

\item[Description] Returns when any one of the keys specified in the
  argument is down. If a key is down when called, it will return immediately.

\item[Usage]
\begin{verbatim}
WaitForKeyListDown(<list-of-keys>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
WaitForKeyListDown(["a","z"])
\end{verbatim}

\item[See Also]	
 \end{desc}







\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForListKeyPressWithTimeout()+

\item[Description] Returns when any one of the keys specified in the
  argument is pressed, or when the timeout has elapsed; whichever
  comes first. Will only return on a new keyboard/timeout events, and
  so a previously pressed key will not trip this function, unlike
  \verb+WaitForKeyListDown()+.  The \verb+<style>+ parameter is currently
  unused, but may be deployed in the future for differences in how
  or when things should be returned.  Returns the value of the pressed
  key.  If the function terminates by exceeding the \verb+<timeout>+,
  it will return the string \verb+["<timeout>"]+.

\item[Usage]
\begin{verbatim}
 WaitForListKeyPressWithTimeout(<list-of-keys>,
                                <timeout>,<style>)
\end{verbatim}

\verb+<list-of-keys>+ can include text versions of many keys.  See Chapter 4,
section ``Keyboard Entry'' for complete list of keynames.

\item[Example]     	
\begin{verbatim}
  x <- WaitForListKeyPressWithTimeout(["a","z"],
                                       2000,1)
  if(IsList(x))
  {
     Print("Did Not Respond.")
  }
\end{verbatim}

\item[See Also]	
   \verb+WaitForKeyListDown+, \verb+WaitForListKeyPress+, \verb+WaitForKeyPressWithTimeout+
 \end{desc}







\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForListKeyPress()+

\item[Description] Returns when any one of the keys specified in the
  argument is pressed. Will only return on a new keyboard event, and
  so a previously pressed key will not trip this function, unlike
  \verb+WaitForKeyListDown()+  Returns a string indicating the value
  of the keypress.

\item[Usage]
\begin{verbatim}
WaitForListKeyPress(<list-of-keys>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
WaitForListKeyPress(["a","z"])
\end{verbatim}

\item[See Also]	
   \verb+WaitForKeyListDown+, \verb+WaitForListKeyPressWithTimeout+
 \end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForKeyPress()+

\item[Description] Waits for a keypress event that matches the
  specified key.  Usage of this function is preferred over
  \verb+WaitForKeyDown()+, which tests the state of the key. Returns the
  value of the key pressed.

\item[Usage]
\begin{verbatim}
WaitForKeyPress(<key>)
\end{verbatim}

\item[Example]	

\item[See Also]     	\verb+WaitForAnyKeyPress()+, \verb+WaitForKeyRelease()+, \verb+WaitForListKeyPress()+
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+WaitForKeyUp()+

\item[Description]	

\item[Usage]		

\item[Example]	

\item[See Also]	
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+WaitForMouseButton()+

\item[Description] Waits for a mouse click event to occur.
  This takes no arguments, and returns a 4-tuple list, indicating:

\begin{verbatim}
[xpos, 
 ypos, 
 button id [1-3], 
 "<pressed>" or "<released>"]
\end{verbatim}

\item[Usage]
\begin{verbatim}
   WaitForMouseButton()
\end{verbatim}

\item[Example]	
\begin{verbatim}
## Here is how to wait for a mouse down-click

 continue <- 1
 while(continue)
 {
     x <- WaitForMouseButton()
     if(Nth(x,4)=="<pressed>")
      {
          continue <- 0
      }
 }
 Print("Clicked")
\end{verbatim}


\item[See Also]
  \verb+ShowCursor+, \verb+WaitForMouseButtonWithTimeout+
  \verb+SetMouseCursorPosition+, \verb+GetMouseCursorPosition+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+WaitForMouseButtonWithTimeout()+

\item[Description] Waits for a mouse click event to occur, or a
  timeout to be reached.
  This takes a single argument: timeout delay in ms. When clicked, it returns a
  4-tuple list, indicating:
\begin{verbatim}
[xpos,
 ypos, 
 button id [1-3], 
 "<pressed>" or "<released>"]
\end{verbatim}
  when not click and timeout is reached, it returns a list:
   \verb+[timeout]+

\item[Usage]

\begin{verbatim}
   WaitForMouseButtonWithTimeOut()
\end{verbatim}

\item[Example]	
\begin{verbatim}
## Here is how to wait for a mouse down-click

 continue <- 1
 while(continue)
 {
     x <- WaitForMouseButtonWithTimeout()
     if(First(x)=="<timeout>")
      {
         Print("time is "+GetTime())
          continue <- 1
      } else {
          continue <- 0
      }
 }
 Print("Clicked")
\end{verbatim}


\item[See Also]
  \verb+ShowCursor+,
  \verb+SetMouseCursorPosition+, \verb+GetMouseCursorPosition+
\end{desc}







\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+WaitForNetworkConnection()+

\item[Description]	Listens on a port, waiting until another computer or process
  connects. Return a network object that can be used for communication.

\item[Usage]
\begin{verbatim}
   WaitForNetworkConnection(<port>)
\end{verbatim}

\item[Example]	

  See nim.pbl for example of two-way network connection.
\begin{verbatim}

  net <- WaitForNetworkConnection(1234)
  dat <- GetData(net,20)
  Print(dat)
  CloseNetworkConnection(net)
\end{verbatim}

\item[See Also]
  \verb+ConnectToHost+, \verb+ConnectToIP+, \verb+GetData+, \verb+WaitForNetworkConnection+,
   \verb+SendData+, \verb+ConvertIPString+, \verb+CloseNetworkConnection+
\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+while+

\item[Description] `while' is a keyword, and so is part of the syntax,
  not a function per se.  It executes the code inside the \verb+{}+
  brackets until the test inside the \verb+()+ executes as false.
  This can easily lead to an infinite loop if conditions are not met.
  Also, there is currently no break statement to allow execution to
  halt early.  Unlike some other languages, PEBL requires that the
  \verb+{}+ be present.

\item[Usage]
\begin{verbatim}

while(<test expression>)
{
 code line 1
 code line 2
}
\end{verbatim}

\item[Example] 
\begin{verbatim}
i <- 1
while(i <= 10)
{
 Print(i)
 i <- i + 1
}		# prints out the numbers 1 through 10
\end{verbatim}

\item[See Also] 	\verb+loop()+, \verb+{ }+


\end{desc}




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+WritePNG()+

\item[Description] WritePNG() creates a graphic file of the screen or
  a widget on the screen.  It can also be given an arbitrary widget.
  For the most part, widgets added to other widgets will be captured
  fine, but sometimes polygons and shapes added to other widgets may
  not appear in the output png.

\item[Usage]

\begin{verbatim}
  x <-  WritePNG("screen1.png",gWin)

  ## Use like this to create an animated screencast
   define DrawMe()
    {
      pname <- "fileout"+ZeroPad(gid,5)+".png"
      Draw()
      WritePNG(pname,gWin)
    }
  
   define Start(p)  
   {
     gid <- 1
     gWin <- MakeWindow()
     img <- MakeImage("pebl.png")
     AddObject(img,gWin)
     while(gid < 100)
      {
         Move(img,RandomDiscrete(800),
                  RandomDiscrete(600))
 
         DrawMe()
         gid <- gid + 1
      }

   }   
  
\end{verbatim}
\item[See Also]	\verb+FileWriteTable+
\end{desc}

\vfill
\newpage

\sect{Z}
\vfill


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+ZeroPad+

\item[Description]  Takes a number and pads it with zeroes left of the
  decimal point so that its length is equal to <size>. Argument must
  be a positive integer and less than ten digits.  Returns a string.


\item[Usage]
\begin{verbatim}
  ZeroPad(<number>, <length>)
\end{verbatim}

\item[Example] 
\begin{verbatim}
  Print(ZeroPad(33,5))     # "00033"
  Print(ZeroPad(123456,6)) #"123456"
  Print(ZeroPad(1,8))      #"00000001"
\end{verbatim}

\item[See Also] \verb+Format()+
\end{desc}



\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+ZoomPoints+

\item[Description]  Takes a set of points (defined in a joined list 
[[x1,x2,x3,...],[y1,y2,y3,...]] and adjusts them in the x and y
direction independently, returning a similar [[x],[y]] list.

Note: The original points should be centered at zero, because the get
adjusted relative to zero, not relative to their center.

\item[Usage]
\begin{verbatim}
  ZoomPoints(points,<xzoom>,<yzoom>)
\end{verbatim}

\item[Example] 
\begin{verbatim}
  points <- [[1,2,3,4],[20,21,22,23]]
  newpoints <- ZoomPoints(points,2,.5)
  ##Produces [[2,4,6,8],[10,11.5,11,11.5]]
\end{verbatim}

\item[See Also] \verb+RotatePoints()+, \verb+ReflectPoints+
\end{desc} 
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
