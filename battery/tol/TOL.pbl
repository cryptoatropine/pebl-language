
#################################################
##
##   PEBL's Tower of London Test
##
##   Version 0.6
##   Released July 2011
##
##
##
## see
## Shallice T. (1982), Philosophical Transactions of the Royal Society of
## London, B, 298, 199-209.
##
##
##  Problem sets available from:
##  Fimbel, E., Lauzon, S., & Rainville, C. (2009). Performance of
## Humans vs. Exploration Algorithms on the Tower of London Test.
## (J. Bongard, Ed.)PLoS ONE, 4(9),
## e7263. doi:10.1371/journal.pone.0007263

##  Phillips, L. H., Wynn, V., Gilhooly, K. J., Della Sala, S., &
##    Logie, R. H. (1999). The role of memory in the Tower of London
##    task. Memory, 7(2), 209-231.
##
## Schnirman, G. M., Welsh, M. C., & Retzlaff, P. D. (1998).
##      Development of the Tower of London-Revised. Assessment,
##       5(4), 355-360. Retrieved from
##
## Culbertson, W. C., & Zillmer, E. A. (1998). The
##   Tower of LondonDX: A Standardized Approach to Assessing Executive
##   Functioning in Children. Archives of Clinical Neuropsychology, 13(3),
##   285-301. doi:10.1016/S0887-6177(97)00033-4

## Special thanks to Adam Thomas of NIH/NIMH for implementing the
##    TOL-R trials.
## Polish translation from Magda Piorkowska
## Croatian (HR) courtesy Silvaja Rucevic
define Start(p)
{

##  Basic translations strings are assigned in GetStrings (see bottom of file).
##
##

  ##gLanguage defaults to 'en', but can be set at command line.  
  ##using the --language flag.
  ##gLanguage <- "EN"
  GetStrings(gLanguage)


   parpairs <- [["showHand",1],    #Show the hand
                ["useReverse",0],  #reverse the order of stacks
                ["testtype",-1],    ##test type==-1: choose in-script. Otherwise, set based on initial instructions.
		["timelimit",120],
		["allowreset",0]
               ]


 gParams <- CreateParameters(parpairs,gParamFile)

#  gShowHand     <- 1  #Show the hand graphic?
#  gUseReverse <- 0    ## reverse the stacks. Some of the subtests do
                      ## this automatically.
  Init()


gInstructions <- MakeTextBox("",gFont,760,560)
AddObject(gInstructions,gWin)
Move(gInstructions,20,20)

if(gParams.testtype==-1)
  {
   ##  Comment out the following lines and replace with something like 
   ##  type <- "3"
   ##  to go directly to a test configuration.

  gInstructions.text  <-gSelect
  Draw()
  type <- WaitForListKeyPress(["1","2","3","4","5","6","7","8","9","0","A"])

  }else{
   type <- gParams.testtype+""
  }

   ##Choose which set of trials to generate based on 'type'.
   if(type == "1")
   {
     stim <- ProgressiveDisks([3,4,5],8)  ## unconstrained pole height,
                                         ## with number of disks in
										 ## order specified by first argument
   }elseif(type=="2")
   {
    stim <- RandomDisks([3,4,5],8)       ## unconstrained pole height,
                                         ## like above but in random order

   }elseif(type=="3")
   {
      stim <- Shallice()
   }elseif(type=="4")
   { 

    stim <- ShalliceRandom(30)           ##Basic Shallice problem with
		 								 ##	3 disks on 
		 								 ## different-sized poles, and
										 ##random problems
    
   }elseif(type=="5")
   { 
    stim <- Phillips1999("A")
   }elseif(type=="6")
   {

    stim <- Phillips1999("B")

   }elseif(type=="7")
   {

    stim <- Phillips1999("C")            ##5-disk problems,
		 								 ## unconstrained pole heights
                                         ## Argument specifies sets "A", "B", or "C"
										 ## which consist of different problems
   }elseif(type=="8")
   {
    stim <- FimbelOld()                  ##15 Shallice-like problems
   }elseif(type=="9")
   {

    stim <- FimbelYoung()                ##35 Shallice-like problems
      
   }elseif(type=="0")
   {

    stim <- TOLR()                ##TOL-R ala Schnirman

   } elseif(Uppercase(type)=="A")
   {
      ##Culbertson & Zillmer            ##15 shallice-like problems, easy for adolescents.
      stim <- TOLDX()
   }



##############################################################
##
##
##  These are some global variables that override test-specific settings.
##
##

#   gUseTimer <- 1  ##This hard-codes use of timer. Uncomment to
                   ##override the defaults built into each particular test function.

#  gUseTurnLimit <- 1  ##this hard-codes turn limits, overiding
                       ## setting in original definition



##############################################################
  
  if(gParams.UseReverse)
   {
      stim <-  ReverseStimuli(stim)
   }

  gInstructions.text <- gInstText1


  if(gUseTimer)
   {
     gInstructions.text <- gInstructions.text + gInstText2
   }
  if(gUseTurnLimit)
   {
     gInstructions.text <- gInstructions.text +gInstText3
   }



  gInstructions.text <- gInstructions.text + CR(1) + gBegin
  gInstructions.font <- gFont2
  Draw()

  WaitForDownClick()
  Hide(gInstructions)
  Draw()
 
  InitPoles()   
   


  gInstructions.width <- 220
  gInstructions.height <- 520
  Move(gInstructions,555,50)
  gInstructions.text <- gContinue



  gTrial  <- 1

  ##Keep track of a 'score' option.
  gScore <- 0

  gTotalMoves <- 0
  gMinMoves <- 0
  gTotalTime <- 0


  loop(pair, stim)
  {


   gReset <- 1
   gTries <- 1

    ##You should run a trial if gReset is both not 0 (0 signals completion)
    ## and gReset <3 (4+ indicates you ran out of turns)
    gStartTime <- GetTime()   
    gEndTime <- gStartTime+ gParams.TimeLimit*1000

    while(gReset == 1 and gTries <= 3) 
      {

 
      if(gParams.allowReset)
         {
          gResetLabel.text <- gResetText + " ["+(3-gTries)+"]"
         }
 
       gReset <- 0



       ##This runs a single trial attempt.
       success <- Trial(pair)




    ##### The following creates the proper feedback messages.
     if(success)
      {

	     ##Success--use message about 'complete, click mouse to continue'
         gInstructions.text <- gContinue
         gReset <- 0

      } else {
 

         gInstructions.text <- gIncomplete
      if(gReset)
       {
	      #the hit the reset button.
          gInstructions.text <- gInstructions.text + " " + gResetLab
          gTries <- gTries + 1

       } else {
    

        if(gMovesRanOut)
         {
         ##Moves ran out on a single round
         ginstructions.text <- gInstructions.text +" " + gMovesOutLab

         if(gParams.allowReset and gTries < 3)
           {
            ##reset the 
            gInstructions.text <- gInstructions.text +" " +gResetLab
            gTries <- gTries + 1
            gReset <- 1
           }

         }

      if(gTimeRanOut)
       {
         ginstructions.text <- gInstructions.text + gTimeOutLab
       }
      }
      if(gReset ==0)
        {
          gInstructions.text <- gInstructions.text+CR(2)+ gContinueFail
        }
    }


     ##Do some cleanup after the trial is over.
#     RemoveObject(gInstructions,gWin)
#     AddObject(gInstructions,gWin)
     Show(gInstructions)
     Draw()
     WaitForDownClick()
     Hide(gInstructions)
     HideAll()
      }

    gTrial <- gTrial + 1


   }

   ##Record a final line 
   report <-"Tower of London Test"+CR(1)+
      TimeStamp() + CR(1)+
    "Participant:          " +gSubNum +CR(1)+ 
    "Trials:               "+Length(stim)+CR(1)+
    "Total moves:          "+gTotalMoves+CR(1)+
    "Minimum moves:        " +gMinMoves +CR(1)+
    "Total time:           "+gtotalTime/1000
 

   FilePrint(gReportFile,report)
   FilePrint(gPooledFile,gSubNum+","+TimeStamp()+","+  Length(stim)+","+
 gTotalMoves+","+gMinMoves +","+gtotalTime)

   gInstructions.text <- gDebriefing + CR(2) + report

   Show(gInstructions)
   Draw()
   WaitForAnyKeyPress()
}



define Trial(pair)
{

   ##Keep track of time to make first move.
   firstmovetime <- -1

   ##extract data from input
   config <- First(pair)
   config1 <- Second(pair)
   shortest <- Third(pair)
   startlab <- Fourth(pair)
   endlab <- Fifth(pair)
   numdisks <- Length(Flatten(config))
   origstring <- MakeStateString(config)


   ##reset flags that keep track if move/time runs out.
   gMovesranout <- 0
   gTimeranout <- 0

    ## Make standard and new configurations
    c1 <- PlotDisksAnimate(config,0,450,gDisks,10)
    c2 <- PlotDisksAnimate(config1,0,130,gDisks2,10)


    ##if appropriate, create the click graph
    if(shortest > 0 and gUseTurnLimit)    
    {
      cGraph <- MakeGraph(shortest,shortest,650,400,gClickLab,shortest)
    }

    #Set some initial timing variables

    startTime <- GetTime()
    lasttime <- startTime
    time <- startTime

    ##record the starting configuration of the trial
    FilePrint(gfileout, gSubNum + "," + gTrial + "," + numdisks + "," +
                  MakeStateString(config) + "," +
                  MakeStateString(config1) + ",0,0," + gTries + "," +gScore + "," +
                   starttime + ",0,"+
                  (time - lasttime)  + ",0")


    continue <- 1
    step <- 1 


    ##This part creates the timer graph
    if(gUseTimer)
    {
      ##Timegraph defaults to 120 sec.
      ##the ticks hsould be every 10 sec, unless there are less than 4
      ## ticks. then every 5, then every 1 sec
      numticks <- gParams.TimeLimit/10
      if(numticks < 4)
       {
         numticks <- gParams.TimeLimit/5
       }
      if(numticks < 3)
       {
         numticks <- gParams.TimeLimit
       }
    

      gTimeGraph <- MakeGraph(gParams.TimeLimit,gParams.TimeLimit,710,400,gTimeLab,numticks)
    }

    Draw()

    success <- 0
    #Now, allow disk moves until the two have identical configurations.
    while(continue)
    {

      #Get the location we want to move the disk to
      config <- MoveDisk(config)
      time <- GetTime()


      ##record time to first move.
	  if ( firstmovetime == -1) 
       {
             firstmovetime <- time -starttime
       }


      ##Check to see if we have succeeded
      if(StackEqual(config,config1))
       {
     
         success <- 1
         continue <- 0

         #update the score; we are correct
         gScore <- gScore + (4-gTries)
       }

      ##record move time.
      FilePrint(gfileout, gSubNum + "," + gTrial + "," + numdisks + "," +
              MakeStateString(config) + "," + MakeStateString(config1) + "," + 
                 step + "," + gReset + "," + gTries + "," + gScore + "," +
                  time + "," + (time - starttime) +"," +
                    (time-lasttime) + "," + success)

      lasttime <- time


    ##only update the graph if we have a good measure of
    ## shortest path, and if the global flag specifies it.
    if(shortest > 0 and gUseTurnLimit)
     {
        rem <- Max([0,shortest-step])
        UpdateGraph(cgraph,rem, 650,400,shortest)
        #if no moves remain:
        if(rem == 0)
         {
           #if continue == 0, we have solved the puzzle already. 
           if(continue == 0)
              {
                  success <- 1
              }else{
                  gMovesRanOut <- 1     
                  continue <- 0
                  success <- 0

              }
         }
     }

    ##See if the move ended because time ran out
    if(gUseTimer)
     {  
         if(gTimeRanOut)
          {
              success <- 0
              continue <- 0

          }
     }

    ##see if the move ended because we hit the reset button.
    if(gReset)
      {
        continue <- 0
        success <- 0

      }

    Draw()
    step <- step + 1 
    
   }

   Wait(100)
   FilePrint(gFileOutSum, gSubNum + "," + gTrial + "," + numdisks + 
       ","+ shortest + ","  +   startlab+ ","+ endlab + "," +
       origstring  + "," +  MakeStateString(config1) + "," + success +
       ","+ gTries + "," + gScore + "," + (step-1) + "," + gStartTime +
       "," +  starttime + "," +   firstmovetime + ","+ (time-starttime))


     gTotalMoves <- gTotalMoves+(step-1)
     gMinMoves <- gMinmoves + shortest
     gTotalTime <- gTotalTime + (time-starttime)


     if(gUseTimer)
        {
          RemoveComplex(gTimeGraph)
        }
    
     if(shortest > 0 and  gUseTurnLimit)
         { 
           RemoveComplex(cGraph)
         }
       firstmovetime <- -1


  
   return success

}






define HideAll()
{
   loop(i, Merge(gDisks,gDisks2))
   {
     Hide(i)
   }
}

define Init()
{
  gSleepEasy <- 1

#  gVideoWidth <- 800
#  gVideoHeight <- 600
#  ShowCursor(0)
  gWin <- MakeWindow("black")
 
   if(gSubNum+""=="0")
   {
     gSubNum <- GetSubNum(gWin)
   }

  ##  gPEBLBaseFont <- "Vera.ttf"  ##uncomment for version 0.10
  ##These may need to be changed for a particular language.
  gFont <- MakeFont(gPEBLBaseFont,0,15,MakeColor("white"),MakeColor("black"),1)
  gFont2 <- MakeFont(gPEBLBaseFont,0,24,MakeColor("white"),MakeColor("black"),1)
   ##Global flag keeping track of whether the trial was aborted.
  gReset <- 0
}

define InitPoles()
{
##Make hot zones for each stack.


   footerfont <-   MakeFont(gPEBLBaseFont,0,20,MakeColor("grey"),MakeColor("black"),1)


   gFooter <- MakeLabel(gFooterLab,footerfont)
   AddObject(gFooter,gWin)
   Move(gFooter,300,490)


   height <- First(gPoleHeights)*30+15
   y <- 470-height/2
   r1 <-  Rectangle(220,y,110,height,MakeColor("grey20"),1)
   height <-Second(gPoleHeights)*30+15
   y <- 470-height/2
   r2 <-  Rectangle(340,y,110,height,MakeColor("grey20"),1)
   height <- Third(gPoleHeights)*30+15
   y <- 470-height/2
   r3 <-  Rectangle(460,y,110,height,MakeColor("grey20"),1)

   AddObject(r1,gWin)
   AddObject(r2,gWin)
   AddObject(r3,gWin)



   ##if we have a 'reset' button, add one.
   if(gParams.allowReset)
     {
        r0 <- Rectangle(340,gFooter.y+50,300,40,MakeColor("grey20"),0)
        AddObject(r0,gWin)
        gZones <- [r0,r1,r2,r3]
        gResetLabel <- MakeLabel(gResetText,footerfont)
        Move(gResetLabel,340,gFooter.y+50)
        AddObject(gResetLabel,gWin)
     } else {
        gZones <- [r1,r2,r3]
     }

  gDisks <-   [MakeImage("png/disk1.png"),MakeImage("png/disk2.png"),
               MakeImage("png/disk3.png"),MakeImage("png/disk4.png"),
               MakeImage("png/disk5.png"),MakeImage("png/disk6.png")]
  gDisks2 <-  [MakeImage("png/disk1.png"),MakeImage("png/disk2.png"),
               MakeImage("png/disk3.png"),MakeImage("png/disk4.png"),
               MakeImage("png/disk5.png"),MakeImage("png/disk6.png")]

  if(gParams.ShowHand)
    {
     gHand   <- MakeImage("png/hand.png")
     AddObject(gHand,gWin)
     Move(gHand,330,225)
    }
  gRect <- Rectangle(330,80,380,140,MakeColor("grey20"),1)
  AddObject(gRect,gWin)




   gHeader <- MakeTextBox(gHeaderLab,footerfont,105,95)
   AddObject(gHeader,gWin)
   Move(gHeader,30,50)
  ##Keep track of the image complex:
  gComplex <- []



  gFileOut <- GetNewDataFile(gSubNum,gWin,"tol","csv",
   "sub,trial,size,current,end,step,reset,tries,score,abstime,trialtime,clicktime,done")

  gFileOutSum <- GetNewDataFile(gSubNum,gWin,"tol-summary","csv",
   "sub,trial,size,shortest,startlab,endlab,startconf,endconf,success,tries,score,steps,roundstart,starttime,firsttime,time")

  gReportFile <- GetNewDataFile(gSubNum,gWin,"tol-report","txt","")
  gPooledFile <- FileOpenAppend("data/pooled-tol.csv")

 }


define PlotDisks(config,inhand,ybase,disks)
{
  x <- 100
  complex <- []
  
  loop(column,config)
  {
    y <- ybase
    x <- x + 120
    loop(i,column)
    {
     disk <- Nth(disks,i)
     AddObject(disk,gWin)
     Move(disk,x, y) 
     Show(disk)
     y <- y - 25 
     complex <- Append(complex,disk)
    }
  }
 if(inhand >0)
  {
     Move(Nth(disks,inhand),320,250)
     AddObject(Nth(disks,inhand),gWin)
  }
 return  complex
}




define PlotDisksAnimate(config,inhand,ybase,disks,steps)
{

  if(inhand > 0)
   {
    diskIDs <- Flatten(Append(config,inhand))
   }else{
    diskIDs <- Flatten(config)
   } 



  disks2 <- SubSet(disks,Sort(diskIDs))  #Get the disks objects, in order

  

  startxy <- []
  loop(i, disks2)
   {
     startxy <- Append(startxy, [i.x,i.y])
   }

  x <- 100
  complex <- []
  

  ##Go through each column of the config string
  endxy <- []
  i <- 1
  loop(column,config)
  {
    y <- ybase
    x <- x + 120
    loop(i,column)
    {
     disk <- Nth(disks,i)
     AddObject(disk,gWin)
     Show(disk)

     pos <- [x,y]
     endxy <- Append(endxy,pos)
     y <- y - 25 
     complex <- Append(complex,disk)
    }

    i <- i + 1
  }
   if(inhand > 0 )
     {
       endXY <- Append(endXY, [320,225])
       disk <- Nth(disks,inhand)
       AddObject(disk,gWin)
       Show(disk)
     }
  endXY <- SortBy(endXY,diskIDs)
  startend <- Transpose([startxy, endxy])
  stepxy <- []

  loop(i, startend)
   {
      start <- First(i)
      end <- Second(i)
      stepxy <- Append(stepxy,[(First(end)-First(start))/steps,
                               (Second(end)-Second(start))/steps])
   }

  diskstep <- Transpose([disks2,endxy,stepxy])
  step <- 1
  while(step <= steps)
  {
    loop(i, diskstep)
     {
        disk <- First(i)
        end <- Second(i)
        diff <- Third(i)

        disk.x <- First(end) - First(diff)   * (steps-step)
        disk.y <- Second(end) - Second(diff) * (steps-step)
    }

   Draw()          
   step <- step + 1
  }

 return  complex
}


define MoveDisk(config)
{
   
   ##We need a different target set when reset button is enabled.
   if(gParams.allowReset)
     {
       out <- Sequence(0,3,1)
     } else {
       out <- Sequence(1,3,1)
     }



   reset <- 0
   ##We need to use separate code for timer/non-timer.
   if(gUseTimer)
   {
    cont <- 1
    while(cont)
     {
         first <- WaitForClickOnTargetWithTimeout(gZones, out,100)
         if(first=="<timeout>")
           {
		      timeleft <- (gEndTime-GetTime())/1000
              if(timeleft < 0)
               {
                   gTimeRanOut <- 1
                   cont <- 0
               }
              UpdateGraph(gTimegraph,Max([0,timeleft]), 710,400,gParams.TimeLimit)
              Draw()

           } else {
               if(first ==0)
                {
                  ##We hit the 'abort' button.
                  cont <- 0
                  reset <- 1
                } else {
                 ##Time is not out; but we need to make sure there is 
                 ##something in the pile
  			     if(Length(Nth(config,first))>0)
                  {
                   cont <- 0
                  }
                }
           }
     }

   } else {
 ########################################
 ##Non-timer branch, so use just standard click.
          
       first <- WaitForClickOnTarget(gZones, out)


       if(first == 0)
        { 
           reset <- 1

        } else {
          while(Length(Nth(config,first))==0)
           {
             first <- WaitForClickOnTarget(gZones, out)
           }

         } 
   }
     ##At this point, we either 
     ##1. ran out of time: gtimeranout == 1
     ##2. picked up a valid disk  gtimeranout == 0, reset == 0
     ##3. hit the reset button.  reset == 1, 

   ##Valid click:
   if((not gTimeranout) and reset == 0)
     {

	    x <- RemoveDisk(first,config)
 
       config <- First(x)
       disk <- Nth(x,2)
 
     if(disk != 0)
      {
      ##Remove the disk complex so it can be re-drawn
      RemoveComplex(gComplex)
      gComplex <- PlotDisksAnimate(config,disk,450,gDisks,10)
      Draw()


      ###############################################
      ###############################################
      ## Now, get the pile to place the disk in.


      cont <- 1
      while(cont)
      {
       #Now, get the target pile 1-3


      if(gUseTimer)
      {
       timecont <- 1
       while(timecont)
       {

         next <- WaitForClickOnTargetWithTimeout(gZones, out,100)

         if(next=="<timeout>")
           {
	      timeleft <- (gEndTime-GetTime())/1000
              UpdateGraph(gTimegraph,Max([0,timeleft]), 710,400,gParams.TimeLimit)
              Draw()
              if(timeleft < 0)
               {
                   gTimeRanOut <- 1
               }


           } else {

              ##We hit the 'abort' button
              if(next == 0)
               {
                   reset <- 1
               } 

               timecont <- 0
           }
       }

      } else {
        ##No timer, so use just standard click.
        next <- WaitForClickOnTarget(gZones, out)

      }

   
	  ##Check to see if the new configuration violates the pole height
	  ##      limitation.
       if(Length(Nth(config ,next))<Nth(gPoleHeights,next))
          {
            cont <- 0
          }

      }


      RemoveComplex(gComplex)
      config <- AddDisk(config,next,disk)
      gComplex <- PlotDisksAnimate(config,0,450,gDisks,5)
      Draw()
    }
   }

   if(reset)
     {
        gReset <-  1
     }

   return config
}

define RemoveComplex(x)
{ 
    loop(i,x)
    {
       RemoveObject(i,gWin)
    }
}

##Returns a string describing a state of the problem
define MakeStateString(config)
{

  string <- "|"
  loop(i,config)
  {
    loop(j,i)
    {
      string <- string + j
    }
    string <- string + "|"
  }  

  return string
}

##This works just on the data structure, not on the display.
define RemoveDisk(col,ind)
{
##Removing:

   removed <- 0
   a <- 1
   newcomp <- []
   loop(i,ind)
   {

    if(a == col)
    {
      l <- Length(i)
      ## Remove the last element of the list, if it exists
      if(l == 0)
      { 
        newcomp <- Append(newcomp,[])
      } elseif(l==1){

        newcomp <- Append(newcomp,[])
        removed <- First(i)

      }else {

        ##
        newcomp <- Append(newcomp, SubList(i,1,l-1))
        removed <- Nth(i,l)

      }

    } else {
     newcomp <- Append(newcomp,i)
    }

	a <- a +1
   }

  return [newcomp,removed]
}


define AddDisk(config,nextcol,disk)
{

   a <- 1
   newcomp <- []
   loop(i,config)
   {
    if(a == nextcol)
    {
      newcomp <- Append(newcomp, Append(i,disk))

    } else {
     newcomp <- Append(newcomp,i)
    }

	a <- a +1
   }

  return newcomp
}

##Makes a disk configuration, with the restriction that an individual
##stack must be shorter than its relevant pole height.
define ShuffleDisks(num)
{
  order <- Shuffle(Sequence(1,num,1))
  config <- [[],[],[]]

  loop(i,order)
   {
      cont <- 1
      while(cont)
      {
        stack <- RandomDiscrete(3)  #is there room in the stack?
        if(Length(Nth(config,stack)) < Nth(gPoleHeights,stack))
        {
         cont <- 0
        }
      }

      config <- AddDisk(config,stack,i)
   }


   return config
}


define StackEqual(stack1,stack2)
{
  equal <- 1

  loop(x,  Transpose([stack1,stack2]))
  {
     a <-  First(x)
     b <-  Nth(x,2)

    if(Length(a) == Length(b) )
       {
            loop(j,Transpose([a,b]))
            {
                if(First(j) != Nth(j,2))
                 {
                     equal <- 0
                 }
            }
 
       } else {
         equal <- 0
       }
  }
 return equal
}


define Phillips1999(set)
{

   ##Don't use the timer or turn limits here.
   gUseTimer <- 0  
   gUseTurnLimit <- 0  

   gPoleHeights <- [5,5,5]

    trialsA <-  [[[[],[4,3,2,1],[5]],   [[2,3],[4],[5,1]] ,-1,0,0],
	             [[[5,3,2,4,1],[],[]],  [[],[1,4,3],[2,5]],-1,0,0],
	             [[[4],[3,2],[5,1]],    [[2,4,3,1],[],[5]],-1,0,0],
	             [[[3],[1,2,5],[4]],    [[],[4,3],[2,5,1]],-1,0,0],#orig. wierd
            	 [[[],[3,5],[1,4,2]],   [[3,5],[2],[1,4]] ,-1,0,0], #original wierd
                 [[[4,3],[5],[2,1]],    [[3,5],[2],[1,4]] ,-1,0,0],
				 [[[2],[5,3],[1,4]],    [[],[],[5,1,4,2,3]],-1,0,0],
				 [[[1,2,5,3,4],[],[]],  [[2,3],[],[5,4,1]],-1,0,0]]  #orig  goal wierd
	            

    trialsB <-  [ [[[4],[2,1,5],[3]],    [[4,5,1,3],[2],[]],-1,0,0],
                  [[[],[2,3,4,5],[1]],    [[5,1,4],[],[3,2]],-1,0,0],
                  [[[],[2],[4,3,1,5]],    [[2,1,5,3],[],[4]],-1,0,0],
                  [[[],[1,3],[4,5,2]],    [[3,4,2],[1,5],[]],-1,0,0], #orig goal wierd
                  [[[5,1],[],[3,4,2]],    [[2,3,4,5],[1],[]],-1,0,0],
                  [[[],[],[2,1,5,3,4]],   [[1],[],[5,3,4,2]],-1,0,0],
                  [[[],[3,2,4,1,5],[]],   [[5],[1,2,3],[4]],-1,0,0],
                  [[[],[2,5,3,4,1],[]],   [[3,2],[1],[5,4]],-1,0,0] ]

    trialsC <-  [ [[[4,3],[],[2,1,5]],    [[4],[5,1,3],[2]],-1,0,0],
                  [[[4,1],[5,3,2],[]],    [[2,1,4,5],[],[3]],-1,0,0],  #original wierd
                  [[[1,3],[4,5,2],[]],    [[],[4,3,1,5],[2]],-1,0,0],
                  [[[2],[],[5,4,3,1]],    [[],[2,1],[5,3,4]],-1,0,0],  #orig goal wierd
                  [[[4,2,1],[3,5],[]],    [[],[1],[5,2,3,4]],-1,0,0],
                  [[[5],[1,4,3],[2]],     [[],[2,5,3],[1,4]],-1,0,0],
                  [[[4,1,2,5],[],[3]],    [[3,1,4],[],[5,2]],-1,0,0],
                  [[[],[],[5,1,3,2,4]],    [[],[],[2,4,1,5,3]],-1,0,0]]

  if(set == "A")
  {
   ret <- trialsA
  } elseif(set=="B")
  {
  ret <- trialsB
  }  else {
  ret <- trialsC
  }
 return ret
}


define Shallice()
{

   ##Don't use the timer or turn limits here.
   gUseTimer <- 0
   gUseTurnLimit <- 1
 
  gPoleHeights <- [3,2,1]


  ## 1=RED, 2=YELL, 3=BLUE
  ##
  ##



s <- [
    [ [[2,1],[3],[]],[[],[3,2],[1]],2,63,66 ],
    [ [[2,1],[3],[]],[[2],[1],[3]]  ,2,63,55],
    [ [[2,1],[3],[]],[[2,3],[1],[]] ,3,63,53],
    [ [[2,1],[3],[]],[[2],[1,3],[]] ,3,63,54],
    [ [[2,1],[3],[]],[[1,2],[3],[]] ,4,63,13],
    [ [[2,1],[3],[]],[[3],[1,2],[]] ,4,63,44],
    [ [[2,1],[3],[]],[[1,3],[],[2]] ,4,63,22],
    [ [[2,1],[3],[]],[[],[1,3],[2]] ,4,63,46],
    [ [[2,1],[3],[]],[[1,2,3],[],[]],5,63,11],
    [ [[2,1],[3],[]],[[1,3,2],[],[]],5,63,21],
    [ [[2,1],[3],[]],[[3,2],[1],[]] ,5,63,43],
    [ [[2,1],[3],[]],[[3],[1],[2]]  ,5,63,45]]

  return s
}


###This mirror-reverses the stimuli and stacks.
define   ReverseStimuli(stim)	
{
    gPoleheights <- Reverse(gPoleHeights)
	newstim <- []
	loop(i,stim)
	{
	   line <- [Reverse(First(i)), Reverse(Second(i)), Third(i),Fourth(i),Fifth(i)]
	   newstim <- Append(newstim,line)
	}

  return newstim
    
}

define GetTOLDist(matrix,a,b,c,d)
{
    row <- (a-1)* 6 + b
    col <- (c-1)* 6 + d
    return ToNumber(M(matrix,row,col))
}

define AssembleTrial(a1,a2,b1,b2,states,dists)
{
  return [M(states,a1,a2),M(states,b1,b2), GetTOLDist(dists,a1,a2,b1,b2), a1+""+a2, b1+""+b2 ]
}

## Computes the minimum distance between states, courtes of  Fimbel
## http://sites.google.com/site/tolspace/
##
define StateDist()
{
   state <- [[0,1,1,2,2,3,4,3,3,3,2,3,6,6,5,4,5,4,7,6,7,8,7,8,6,5,6,7,7,8,6,6,5,4,4,3],
   [1,0,1,2,2,3,3,3,2,2,1,2,5,5,4,3,4,3,6,5,6,7,6,7,6,5,6,7,7,8,6,6,5,4,4,3],
   [1,1,0,1,1,2,3,2,3,3,2,3,6,6,5,4,5,4,7,6,7,8,7,7,5,4,5,6,6,7,5,5,4,3,3,2],
   [2,2,1,0,1,2,3,2,3,4,3,4,7,7,6,5,6,5,8,7,8,7,7,6,4,3,4,5,5,6,4,4,3,3,2,1],
   [2,2,1,1,0,1,2,1,2,3,3,4,7,7,6,5,5,4,7,6,7,7,8,7,5,4,5,6,5,6,4,4,3,2,3,2],
[3,3,2,2,1,0,3,2,3,4,4,5,8,8,7,6,6,5,8,7,7,6,7,6,4,3,4,5,4,5,3,3,2,1,2,3],
[4,3,3,3,2,3,0,1,1,2,2,3,6,6,5,4,4,3,6,5,6,7,7,8,7,6,7,8,7,8,6,6,5,4,5,4],
[3,3,2,2,1,2,1,0,1,2,2,3,6,6,5,4,4,3,6,5,6,7,7,8,6,5,6,7,6,7,5,5,4,3,4,3],
[3,2,3,3,2,3,1,1,0,1,1,2,5,5,4,3,3,2,5,4,5,6,6,7,7,6,7,8,7,7,6,6,5,4,5,4],
[3,2,3,4,3,4,2,2,1,0,1,2,4,4,3,3,2,1,4,3,4,5,5,6,8,7,8,7,7,6,7,7,6,5,6,5],
[2,1,2,3,3,4,2,2,1,1,0,1,4,4,3,2,3,2,5,4,5,6,5,6,7,6,7,7,8,7,7,7,6,5,5,4],
[3,2,3,4,4,5,3,3,2,2,1,0,3,3,2,1,2,3,4,3,4,5,4,5,8,7,7,6,7,6,8,8,7,6,6,5],
[6,5,6,7,7,8,6,6,5,4,4,3,0,1,1,2,2,3,4,3,3,3,2,3,6,6,5,4,5,4,7,6,7,8,7,8],
[6,5,6,7,7,8,6,6,5,4,4,3,1,0,1,2,2,3,3,3,2,2,1,2,5,5,4,3,4,3,6,5,6,7,6,7],
[5,4,5,6,6,7,5,5,4,3,3,2,1,1,0,1,1,2,3,2,3,3,2,3,6,6,5,4,5,4,7,6,7,8,7,7],
[4,3,4,5,5,6,4,4,3,3,2,1,2,2,1,0,1,2,3,2,3,4,3,4,7,7,6,5,6,5,8,7,8,7,7,6],
[5,4,5,6,5,6,4,4,3,2,3,2,2,2,1,1,0,1,2,1,2,3,3,4,7,7,6,5,5,4,7,6,7,7,8,7],
[4,3,4,5,4,5,3,3,2,1,2,3,3,3,2,2,1,0,3,2,3,4,4,5,8,8,7,6,6,5,8,7,7,6,7,6],
[7,6,7,8,7,8,6,6,5,4,5,4,4,3,3,3,2,3,0,1,1,2,2,3,6,6,5,4,4,3,6,5,6,7,7,8],
[6,5,6,7,6,7,5,5,4,3,4,3,3,3,2,2,1,2,1,0,1,2,2,3,6,6,5,4,4,3,6,5,6,7,7,8],
[7,6,7,8,7,7,6,6,5,4,5,4,3,2,3,3,2,3,1,1,0,1,1,2,5,5,4,3,3,2,5,4,5,6,6,7],
[8,7,8,7,7,6,7,7,6,5,6,5,3,2,3,4,3,4,2,2,1,0,1,2,4,4,3,3,2,1,4,3,4,5,5,6],
[7,6,7,7,8,7,7,7,6,5,5,4,2,1,2,3,3,4,2,2,1,1,0,1,4,4,3,2,3,2,5,4,5,6,5,6],
[8,7,7,6,7,6,8,8,7,6,6,5,3,2,3,4,4,5,3,3,2,2,1,0,3,3,2,1,2,3,4,3,4,5,4,5],
[6,6,5,4,5,4,7,6,7,8,7,8,6,5,6,7,7,8,6,6,5,4,4,3,0,1,1,2,2,3,4,3,3,3,2,3],
[5,5,4,3,4,3,6,5,6,7,6,7,6,5,6,7,7,8,6,6,5,4,4,3,1,0,1,2,2,3,3,3,2,2,1,2],
[6,6,5,4,5,4,7,6,7,8,7,7,5,4,5,6,6,7,5,5,4,3,3,2,1,1,0,1,1,2,3,2,3,3,2,3],
[7,7,6,5,6,5,8,7,8,7,7,6,4,3,4,5,5,6,4,4,3,3,2,1,2,2,1,0,1,2,3,2,3,4,3,4],
[7,7,6,5,5,4,7,6,7,7,8,7,5,4,5,6,5,6,4,4,3,2,3,2,2,2,1,1,0,1,2,1,2,3,3,4],
[8,8,7,6,6,5,8,7,7,6,7,6,4,3,4,5,4,5,3,3,2,1,2,3,3,3,2,2,1,0,3,2,3,4,4,5],
[6,6,5,4,4,3,6,5,6,7,7,8,7,6,7,8,7,8,6,6,5,4,5,4,4,3,3,3,2,3,0,1,1,2,2,3],
[6,6,5,4,4,3,6,5,6,7,7,8,6,5,6,7,6,7,5,5,4,3,4,3,3,3,2,2,1,2,1,0,1,2,2,3],
[5,5,4,3,3,2,5,4,5,6,6,7,7,6,7,8,7,7,6,6,5,4,5,4,3,2,3,3,2,3,1,1,0,1,1,2],
[4,4,3,3,2,1,4,3,4,5,5,6,8,7,8,7,7,6,7,7,6,5,6,5,3,2,3,4,3,4,2,2,1,0,1,2],
[4,4,3,2,3,2,5,4,5,6,5,6,7,6,7,7,8,7,7,7,6,5,5,4,2,1,2,3,3,4,2,2,1,1,0,1],
[3,3,2,1,2,3,4,3,4,5,4,5,8,7,7,6,7,6,8,8,7,6,6,5,3,2,3,4,4,5,3,3,2,2,1,0]]


 return state
}


define FimbelOld()
{


  ##Don't use the timer or turn limits here.
  gUseTimer <- 0  
  gUseTurnLimit <- 0  


  gPoleHeights <- [1,2,3]
 
  ## 1=RED, 2=YELL, 3=BLUE
  ##
  ##


  ##THIS IS ALL THE STATES
  s <-[[[[],[],[1,2,3]],[[3],[],[1,2]],[[],[3],[1,2]],[[],[3,2],[1]],[[2],[3],[1]],[[2],[3,1],[]]],
            [[[],[],[1,3,2]],[[2],[],[1,3]],[[],[2],[1,3]],[[],[2,3],[1]],[[3],[2],[1]],[[3],[2,1],[]]],
            [[[],[],[3,1,2]],[[2],[],[3,1]],[[],[2],[3,1]],[[],[2,1],[3]],[[1],[2],[3]],[[1],[2,3],[]]],
            [[[],[],[3,2,1]],[[1],[],[3,2]],[[],[1],[3,2]],[[],[1,2],[3]],[[2],[1],[3]],[[2],[1,3],[]]],
            [[[],[],[2,3,1]],[[1],[],[2,3]],[[],[1],[2,3]],[[],[1,3],[2]],[[3],[1],[2]],[[3],[1,2],[]]],
            [[[],[],[2,1,3]],[[3],[],[2,1]],[[],[3],[2,1]],[[],[3,1],[2]],[[1],[3],[2]],[[1],[3,2],[]]]]

  ##This is the minimal distance between states:
  dists <- StateDist()

  trialsOld <- [AssembleTrial(1,2,1,3,s,dists),
				AssembleTrial(5,3,5,2,s,dists),
                                AssembleTrial(2,3,2,4,s,dists),
				AssembleTrial(1,2,1,5,s,dists),
				AssembleTrial(2,3,3,6,s,dists),

				AssembleTrial(5,3,6,5,s,dists),
				AssembleTrial(2,3,3,5,s,dists),
				AssembleTrial(5,3,6,4,s,dists),
				AssembleTrial(1,2,1,6,s,dists),
				AssembleTrial(5,3,1,6,s,dists),

				AssembleTrial(1,2,6,4,s,dists),
				AssembleTrial(2,3,3,3,s,dists),
				AssembleTrial(1,2,6,3,s,dists),
				AssembleTrial(5,3,1,5,s,dists),
				AssembleTrial(2,3,3,2,s,dists)]


   return trialsOld
}


define FimbelYoung()
{

   ##Don't use the timer or turn limits here.
   gUseTimer <- 0  
   gUseTurnLimit <- 0  


  gPoleHeights <- [1,2,3]
 
  ## 1=RED, 2=YELL, 3=BLUE
  ##
  ##


  ##THIS IS ALL THE STATES
  s <-[[[[],[],[1,2,3]],[[3],[],[1,2]],[[],[3],[1,2]],[[],[3,2],[1]],[[2],[3],[1]],[[2],[3,1],[]]],
            [[[],[],[1,3,2]],[[2],[],[1,3]],[[],[2],[1,3]],[[],[2,3],[1]],[[3],[2],[1]],[[3],[2,1],[]]],
            [[[],[],[3,1,2]],[[2],[],[3,1]],[[],[2],[3,1]],[[],[2,1],[3]],[[1],[2],[3]],[[1],[2,3],[]]],
            [[[],[],[3,2,1]],[[1],[],[3,2]],[[],[1],[3,2]],[[],[1,2],[3]],[[2],[1],[3]],[[2],[1,3],[]]],
            [[[],[],[2,3,1]],[[1],[],[2,3]],[[],[1],[2,3]],[[],[1,3],[2]],[[3],[1],[2]],[[3],[1,2],[]]],
            [[[],[],[2,1,3]],[[3],[],[2,1]],[[],[3],[2,1]],[[],[3,1],[2]],[[1],[3],[2]],[[1],[3,2],[]]]  ]
  dists <-  StateDist()

  trialsYoung    <- [
                  AssembleTrial(2,3,1,2,s,dists),
                  AssembleTrial(2,1,1,5,s,dists),
                  AssembleTrial(1,4,2,2,s,dists),
                  AssembleTrial(2,6,1,2,s,dists),
                  AssembleTrial(5,6,4,3,s,dists),   

                  AssembleTrial(3,3,4,4,s,dists),
                  AssembleTrial(3,4,4,3,s,dists),
                  AssembleTrial(5,3,6,3,s,dists),
                  AssembleTrial(6,3,5,3,s,dists),
                  AssembleTrial(6,4,1,4,s,dists),   

                  AssembleTrial(4,6,3,4,s,dists),
                  AssembleTrial(2,2,6,5,s,dists),
                  AssembleTrial(3,3,2,3,s,dists),
                  AssembleTrial(2,2,3,4,s,dists),
                  AssembleTrial(6,5,1,1,s,dists),   

                  AssembleTrial(2,2,6,2,s,dists),
                  AssembleTrial(3,1,2,3,s,dists),
                  AssembleTrial(5,2,3,2,s,dists),
                  AssembleTrial(4,4,2,6,s,dists),
                  AssembleTrial(3,2,2,3,s,dists),   

                  AssembleTrial(2,1,3,1,s,dists),
                  AssembleTrial(3,2,1,1,s,dists),
                  AssembleTrial(2,3,4,5,s,dists),
                  AssembleTrial(2,2,3,1,s,dists),
                  AssembleTrial(4,1,1,2,s,dists),   

                  AssembleTrial(1,4,3,1,s,dists),
                  AssembleTrial(2,5,4,3,s,dists),
                  AssembleTrial(3,6,6,5,s,dists),
                  AssembleTrial(4,6,1,5,s,dists),
                  AssembleTrial(6,3,3,1,s,dists),   

                  AssembleTrial(2,2,4,6,s,dists),
                  AssembleTrial(2,4,5,1,s,dists),
                  AssembleTrial(2,6,6,2,s,dists),
                  AssembleTrial(3,5,6,5,s,dists),
                  AssembleTrial(5,6,2,1,s,dists)]


   return trialsYoung
 }


## ShalliceRandom uses the fimbel space.
##
define ShalliceRandom(numtrials)
{


   ##Don't use the timer or turn limits here.
   gUseTimer <- 0  
   gUseTurnLimit <- 0  


  gPoleHeights <- [1,2,3]
 
  ## 1=RED, 2=YELL, 3=BLUE
  ##
  ##

  ##THIS IS ALL THE STATES
  s <-[[[[],[],[1,2,3]],[[3],[],[1,2]],[[],[3],[1,2]],[[],[3,2],[1]],[[2],[3],[1]],[[2],[3,1],[]]],
            [[[],[],[1,3,2]],[[2],[],[1,3]],[[],[2],[1,3]],[[],[2,3],[1]],[[3],[2],[1]],[[3],[2,1],[]]],
            [[[],[],[3,1,2]],[[2],[],[3,1]],[[],[2],[3,1]],[[],[2,1],[3]],[[1],[2],[3]],[[1],[2,3],[]]],
            [[[],[],[3,2,1]],[[1],[],[3,2]],[[],[1],[3,2]],[[],[1,2],[3]],[[2],[1],[3]],[[2],[1,3],[]]],
            [[[],[],[2,3,1]],[[1],[],[2,3]],[[],[1],[2,3]],[[],[1,3],[2]],[[3],[1],[2]],[[3],[1,2],[]]],
            [[[],[],[2,1,3]],[[3],[],[2,1]],[[],[3],[2,1]],[[],[3,1],[2]],[[1],[3],[2]],[[1],[3,2],[]]]  ]
  dists <-  StateDist()


   ##Don't use the timer or turn limits here.
   gUseTimer <- 0  
   gUseTurnLimit <- 0  


  ##Generates a random set of trials using Shallice's original 123
  ##stack heights

   id  <- Sequence(1,6,1)

  trials <- []   
  i <- 1
  while(i <= numtrials)
   {
     a1 <- Pick(id)
     a2 <- Pick(id)
     b1 <- Pick(id)
     b2 <- Pick(id)

    ##Make sure the two stacks are not identical at outset:
    while(GetTOLDist(dists,a1,a2,b1,b2)<2)  # Make sure you need at
                                            # least 2 moves
     {
        a1 <- Pick(id)
        a2 <- Pick(id)
        b1 <- Pick(id)
        b2 <- Pick(id)
     }

    trials <- Append(trials,AssembleTrial(a1,a2,b1,b2,s,dists))
    i <- i + 1
  }
  return trials
}

define TOLDX() 
{

##Culbertson, W. C., & Zillmer, E. A. (1998). The
##Tower of LondonDX: A Standardized Approach to Assessing Executive
##Functioning in Children. Archives of Clinical Neuropsychology, 13(3),
##285-301. doi:10.1016/S0887-6177(97)00033-4

 ##Don't use the timer on
## or turn limits here.
   gUseTimer <- 0  
   gUseTurnLimit <- 0  ##prior to 12-2013, this was 1.
   gParams.UseReverse <- 1    ## Mirror reverse all stimuli and stacks.

  gPoleHeights <- [1,2,3]
 
  ## 1=RED, 2=YELL/(green), 3=BLUE
  ##
  ##

  ##THIS IS ALL THE STATES
  s <-[     [[[],[],[1,2,3]], [[3],[],[1,2]], [[],[3],[1,2]], [[],[3,2],[1]], [[2],[3],[1]], [[2],[3,1],[]]],
            [[[],[],[1,3,2]], [[2],[],[1,3]], [[],[2],[1,3]], [[],[2,3],[1]], [[3],[2],[1]], [[3],[2,1],[]]],
            [[[],[],[3,1,2]], [[2],[],[3,1]], [[],[2],[3,1]], [[],[2,1],[3]], [[1],[2],[3]], [[1],[2,3],[]]],
            [[[],[],[3,2,1]], [[1],[],[3,2]], [[],[1],[3,2]], [[],[1,2],[3]], [[2],[1],[3]], [[2],[1,3],[]]],
            [[[],[],[2,3,1]], [[1],[],[2,3]], [[],[1],[2,3]], [[],[1,3],[2]], [[3],[1],[2]], [[3],[1,2],[]]],
            [[[],[],[2,1,3]], [[3],[],[2,1]], [[],[3],[2,1]], [[],[3,1],[2]], [[1],[3],[2]], [[1],[3,2],[]]]  ]

  dists <-  StateDist()

  trials     <-  [AssembleTrial(6,3,5,3,s,dists),
                  AssembleTrial(6,3,1,5,s,dists),
                  AssembleTrial(6,3,5,4,s,dists),
                  AssembleTrial(6,3,1,3,s,dists),
                  AssembleTrial(6,3,4,4,s,dists),

                  AssembleTrial(6,3,4,6,s,dists),
                  AssembleTrial(6,3,4,5,s,dists),
                  AssembleTrial(6,3,1,2,s,dists),
                  AssembleTrial(6,3,4,3,s,dists),
                  AssembleTrial(6,3,2,4,s,dists),

                  AssembleTrial(6,3,4,2,s,dists),
                  AssembleTrial(6,3,2,5,s,dists),
                  AssembleTrial(6,3,3,3,s,dists),
                  AssembleTrial(6,3,3,1,s,dists),
                  AssembleTrial(6,3,3,5,s,dists)]



  return trials


}


define Pick(list)
{ 
   return First(Shuffle(list))
}


define ProgressiveDisks(numdisks,numtrials)
{

   gUseTimer <- 0  
   gUseTurnLimit <- 0  

  ##Generates a random set of trials using Shallice's original 123
  ##stack heights


  gPoleHeights <- [6,6,6]

  trials <- []   

  loop(size,numdisks)
   {
   i <- 1
   while(i <= numtrials)
   {
     config1 <- ShuffleDisks(size)
     config2  <- ShuffleDisks(size)

    ##Make sure the two stacks are not identical at outset:
    while(StackEqual(config1,config2))
    {
      config1 <- ShuffleDisks(size)
      config2  <- ShuffleDisks(size)
    }

    trials <- Append(trials, [config1,config2,-1,0,0])
    i <- i + 1
  }
  } 
 return trials
}


define RandomDisks(numdisks,numtrials)
{

  ##Generates a random set of trials using Shallice's original 123
  ##stack heights

  tmp <- ProgressiveDisks(numdisks,numtrials)
  return Shuffle(tmp)
}



define M(m,i,j)
{
  return Nth(Nth(m,i),j)
}




define MakeGraph(remaining,total,x,y,label,numticks)
{
    ##Sets up some basic parameters for plotting the graph at the bottom of the screen
    font <- MakeFont(gPEBLBaseFont,0,12,MakeColor("grey80"),MakeColor("black"),0)
    height <- 250
    dataheight <- remaining/total * height
    width  <- 20
    scale <- height/total      ##pixels/unit

    ycenter <- y
    xcenter <- x

    
    bgcol <- MakeColor("grey20")
#    fgcol <- MakeColor("red")
    fgcol <- MakeColorRGB(170,0,0)
    black <- MakeColor("grey80")

	
    #Create rectangle for background and for data
    back <- Rectangle(xcenter,ycenter, 70, height+50, bgcol, 1)
    data <- Rectangle(xcenter,ycenter + height/2 - dataheight/2, width, dataheight, fgcol, 1)
     lab <- MakeLabel(label,font)
     Move(lab,xcenter, ycenter+height/2+14)
     

    AddObject(back,gWin)
    AddObject(data,gWin)
    AddObject(lab,gWin)
    ##Create all the labels, based on yvals. Add each label to the 
    ##appropriate location, and combine them all into a single
    ##composite to make removal easier.
    ##These labels are all re-created each trial--they could be
    ##static, which would be a little more efficient, but it is really 
    ##fast as is.
    composite <-[back,data,lab]

	

    yvals <- Sequence(0, total, total/numticks)
   
     loop(i,yvals)
      { 
        yy <- MakeLabel(i+"", font)
        AddObject(yy,gWin)
        Move(yy,  xcenter-20, ycenter + height/2 - i*scale)
        Show(yy)
        composite <- Append(composite,yy)
		tick <- Line(Floor(xcenter-width/2),ycenter+height/2-i*scale,width,0,black)
        AddObject(tick,gWin)
        composite <- Append(composite,tick)
        
      }
    Draw()


    return composite
}

define UpdateGraph(myGraph, remaining, x,y, total)
{

    ##Sets up some basic parameters for plotting the graph at the bottom of the screen

    height <- 250
    dataheight <- remaining/total * height

    ycenter <- y
    xcenter <- x

    #Extract the data from graph.
    data <- Second(myGraph)
    data.height <- dataheight
    data.y <- Floor(ycenter + height/2 -dataheight/2)

}




##
##
##

define TOLR()
{

# Schnirman et al (1998) TOL-R


  ## Use the timer and turn limits here.
  gUseTimer <- 1
  gUseTurnLimit <- 1
 

  gPoleHeights <- [1,2,3]



  ## 1=RED, 2=YELL, 3=BLUE
  ##
  ##



  ##THIS IS ALL THE STATES
  s <-[[[[],[],[1,2,3]],[[3],[],[1,2]],[[],[3],[1,2]],[[],[3,2],[1]],[[2],[3],[1]],[[2],[3,1],[]]],
            [[[],[],[1,3,2]],[[2],[],[1,3]],[[],[2],[1,3]],[[],[2,3],[1]],[[3],[2],[1]],[[3],[2,1],[]]],
            [[[],[],[3,1,2]],[[2],[],[3,1]],[[],[2],[3,1]],[[],[2,1],[3]],[[1],[2],[3]],[[1],[2,3],[]]],
            [[[],[],[3,2,1]],[[1],[],[3,2]],[[],[1],[3,2]],[[],[1,2],[3]],[[2],[1],[3]],[[2],[1,3],[]]],
            [[[],[],[2,3,1]],[[1],[],[2,3]],[[],[1],[2,3]],[[],[1,3],[2]],[[3],[1],[2]],[[3],[1,2],[]]],
            [[[],[],[2,1,3]],[[3],[],[2,1]],[[],[3],[2,1]],[[],[3,1],[2]],[[1],[3],[2]],[[1],[3,2],[]]]]


  ##This is the minimal distance between states:
  dists <- StateDist()
 

  trialsTOLR <- [
                  AssembleTrial(1,1,6,5,s,dists),
                  AssembleTrial(1,4,5,1,s,dists),
                  AssembleTrial(3,5,1,2,s,dists),

                  AssembleTrial(1,4,6,1,s,dists),
                  AssembleTrial(1,4,5,3,s,dists),
                  AssembleTrial(1,4,2,6,s,dists),

                  AssembleTrial(6,3,4,4,s,dists),
                  AssembleTrial(1,4,6,2,s,dists),
                  AssembleTrial(6,3,4,6,s,dists),

                  AssembleTrial(3,5,5,6,s,dists),
                  AssembleTrial(3,5,5,4,s,dists),
                  AssembleTrial(6,3,4,3,s,dists),

                  AssembleTrial(1,1,3,5,s,dists),
                  AssembleTrial(1,4,3,4,s,dists),
                  AssembleTrial(6,3,4,5,s,dists),

                  AssembleTrial(6,3,2,1,s,dists),
                  AssembleTrial(6,3,1,2,s,dists),
                  AssembleTrial(6,3,2,3,s,dists),

                  AssembleTrial(1,4,5,5,s,dists),
                  AssembleTrial(1,4,3,6,s,dists),
                  AssembleTrial(1,1,6,1,s,dists),

                  AssembleTrial(1,1,3,1,s,dists),
                  AssembleTrial(6,3,2,5,s,dists),
                  AssembleTrial(1,1,3,2,s,dists),

                  AssembleTrial(6,3,4,1,s,dists),
                  AssembleTrial(6,3,3,2,s,dists),
                  AssembleTrial(1,4,4,6,s,dists),

                  AssembleTrial(1,4,5,6,s,dists),
                  AssembleTrial(2,1,5,1,s,dists),
                  AssembleTrial(3,5,1,6,s,dists)]

 
   return trialsTOLR

}


## trials from 
## Anderson, P., Anderson, V., & Lajoie, G., (1996). The tower of
## London test: Validation and standardization for pediatric populations.
define TOLAnderson()
{

# Schnirman et al (1998) TOL-R


  ## Use the timer and turn limits here.
  gUseTimer <- 1
  gUseTurnLimit <- 1
 

  gPoleHeights <- [1,2,3]



  ## 1=RED, 2=YELL, 3=BLUE
  ##
  ##



  ##THIS IS ALL THE STATES
  s <-[[[[],[],[1,2,3]],[[3],[],[1,2]],[[],[3],[1,2]],[[],[3,2],[1]],[[2],[3],[1]],[[2],[3,1],[]]],
            [[[],[],[1,3,2]],[[2],[],[1,3]],[[],[2],[1,3]],[[],[2,3],[1]],[[3],[2],[1]],[[3],[2,1],[]]],
            [[[],[],[3,1,2]],[[2],[],[3,1]],[[],[2],[3,1]],[[],[2,1],[3]],[[1],[2],[3]],[[1],[2,3],[]]],
            [[[],[],[3,2,1]],[[1],[],[3,2]],[[],[1],[3,2]],[[],[1,2],[3]],[[2],[1],[3]],[[2],[1,3],[]]],
            [[[],[],[2,3,1]],[[1],[],[2,3]],[[],[1],[2,3]],[[],[1,3],[2]],[[3],[1],[2]],[[3],[1,2],[]]],
            [[[],[],[2,1,3]],[[3],[],[2,1]],[[],[3],[2,1]],[[],[3,1],[2]],[[1],[3],[2]],[[1],[3,2],[]]]]


  ##This is the minimal distance between states:
  dists <- StateDist()
 

  trialsTOLR <- [
                  AssembleTrial(1,1,6,5,s,dists),
                  AssembleTrial(1,4,5,1,s,dists),
                  AssembleTrial(3,5,1,2,s,dists),

                  AssembleTrial(1,4,6,1,s,dists),
                  AssembleTrial(1,4,5,3,s,dists),
                  AssembleTrial(1,4,2,6,s,dists),

                  AssembleTrial(6,3,4,4,s,dists),
                  AssembleTrial(1,4,6,2,s,dists),
                  AssembleTrial(6,3,4,6,s,dists),

                  AssembleTrial(3,5,5,6,s,dists),
                  AssembleTrial(3,5,5,4,s,dists),
                  AssembleTrial(6,3,4,3,s,dists),

                  AssembleTrial(1,1,3,5,s,dists),
                  AssembleTrial(1,4,3,4,s,dists),
                  AssembleTrial(6,3,4,5,s,dists),

                  AssembleTrial(6,3,2,1,s,dists),
                  AssembleTrial(6,3,1,2,s,dists),
                  AssembleTrial(6,3,2,3,s,dists),

                  AssembleTrial(1,4,5,5,s,dists),
                  AssembleTrial(1,4,3,6,s,dists),
                  AssembleTrial(1,1,6,1,s,dists),

                  AssembleTrial(1,1,3,1,s,dists),
                  AssembleTrial(6,3,2,5,s,dists),
                  AssembleTrial(1,1,3,2,s,dists),

                  AssembleTrial(6,3,4,1,s,dists),
                  AssembleTrial(6,3,3,2,s,dists),
                  AssembleTrial(1,4,4,6,s,dists),

                  AssembleTrial(1,4,5,6,s,dists),
                  AssembleTrial(2,1,5,1,s,dists),
                  AssembleTrial(3,5,1,6,s,dists)]

 
   return trialsTOLR

}



## This provides basic translations.  To translate to a new language, copy the text between
##  elseif(lang== "es") and }else{
##  and past before the final }else{, ensuring you have a single pair of matching brackets.
##  Then translate each english string to your language of choice.  Be sure to not include line breaks unless you mean it.
##  also, make a 2-character
##  label to specify your language.  Then, change the 'Getstrings("en") at the top of the file to 
##  be your language of choice.  Finally, copy the function into an email and send to the pebl email list
##  at pebl-list@lists.sourceforge.net, so others can enjoy your labor.

define GetStrings(language)
{

   lang <- Uppercase(language)
  if(lang == "EN") 
   {
    gSelect <- "Type number of test to use:"+ CR(2) +
     "[1] Unconstrained pile heights, {3,4,5} disks, progressive difficulty, 24 trials"+CR(2)+
     "[2] Unconstrained pile heights, {3,4,5} disks, Random presentation, 24 trials"+CR(2)+
     "[3] Shallice test ([1,2,3] pile heights, 3 disks, Shallice's 12 problems."+CR(2)+
     "[4] Shallice pile heights [1,2,3], 3 disks, 30  random trials."+CR(2)+
     "[5] Phillips (1999) trials A (unconstrained piles, 5 disks, progressive difficulty, 8 trials)"+CR(2)+
     "[6] Phillips (1999) trials B (unconstrained piles, 5 disks, progressive difficulty, 8 trials)"+CR(2)+
     "[7] Phillips (1999) trials C (unconstrained piles, 5 disks, progressive difficulty, 8 trials)"+CR(2)+
     "[8] Fimbel et al (2009) old: [1,2,3] pile heights, 3 disks, progressive difficulty, 15 trials)"+CR(2)+
     "[9] Fimbel et al (2009) young: [1,2,3] pile heights, 3 disks, progressive difficulty, 35 trials)"+CR(2)+
     "[0] TOL-R (Schnirman et al, 1998). [1,2,3] pile heights, 3 disks, 30 problems, time and move limit)"+CR(2)+
     "[a] TOL-DX (Culbertson & Zillmer, 1998). [1,2,3] pile heights, 3 discs, 15 problems)"+CR(3)+
     "Edit TOL.pbl directly to specify a test configuration automatically."

    gHeaderLab <- "Target"+CR(1)+"Stacks:"
    gFooterLab <- "Click on pile to pick up and drop disk"

    gInstText1 <- "You are about to perform a task called the 'Tower of London'.  Your goal is to move a pile of disks from their original configuration to the configuration shown on the top of the screen.  You can only move one disk at a time, and you cannot move a disk onto a pile that has no more room (indicated by the size of the grey rectangle).  To move a disk, click on the pile you want to move a disk off of, and it will move up above the piles.  Then, click on another pile, and the disk will move down to that pile."
    gInstText2 <- " You will have a time limit to finish each problem.  Attempt to finish each problem within the allotted time."
    gInstText3 <- " You will have only a limited number of moves to solve each problem. Before you make your first move, think about the problem to make sure you can solve it within your move limit.  If you do not finish the problem within the limit, the turn will end and you will move on to the next problem."
    gBegin <-  "Click the mouse to begin."
    gContinue <- "Trial Complete. "+CR(2)+ "Click mouse to continue to the next trial."
    gIncomplete <- "Trial Incomplete. "
    gClickLab <- "Clicks"
    gTimeLab <-  "Time (s)"
    gMovesOutLab <-  "You failed to complete the problem in the number of moves required."
    gResetText   <- "Reset problem"
    gResetLab    <- "Click screen to restart problem."
    gTimeOutLab <-  "You ran out of time."
    gDebriefing <- "Thank you for participating. The experiment is now complete.  Press any key to exit."
    gContinueFail <- "Click screen to move on to the next problem."
   }   elseif(lang == "BR") 
   {
    gSelect <- "Digite o número do teste a ser usado:"+ CR(2) +
     "[1] Pilhas de alturas não-limitadas, {3,4,5} discos, dificuldade progressiva, 24 problemas"+CR(2)+
     "[2] Pilhas de alturas não-limitadas, {3,4,5} discos, apresentação aleatória, 24 problemas"+CR(2)+
     "[3] Teste de Shallice (pilhas de alturas [1,2,3], 3 discos, 12 problemas de Shallice."+CR(2)+
     "[4] Pilhas nas alturas [1,2,3] de Shallice, 3 discos, 30 problemas aleatórios."+CR(2)+
     "[5] Phillips (1999) trials A (pilhas não-limitadas, 5 discos, dificuldade progressiva, 8 problemas)"+CR(2)+
     "[6] Phillips (1999) trials B (pilhas não-limitadas, 5 discos, dificuldade progressiva, 8 problemas)"+CR(2)+
     "[7] Phillips (1999) trials C (pilhas não-limitadas, 5 discos, dificuldade progressiva, 8 problemas)"+CR(2)+
     "[8] Fimbel et al (2009) antigo: [1,2,3] pile heights, 3 discos, dificuldade progressiva, 15 problemas)"+CR(2)+
     "[9] Fimbel et al (2009) novo: [1,2,3] pile heights, 3 discos, dificuldade progressiva, 35 problemas)"+CR(2)+
     "[0] TOL-R (Schnirman et al, 1998). Pilhas de alturas [1,2,3], 3 discos, 30 problemas, limite de tempo e movimentos)"+CR(2)+
     "[a] TOL-DX (Culbertson & Zillmer, 1998). novo: [1,2,3] pile heights, 3 discos, dificuldade progressiva, 15 problemas)"+CR(3)+

     "Edite TOL.pbl diretamente para especificar uma configuração automática do teste."

    gHeaderLab <- "Posições-alvo"+CR(1)+"Pilhas:"
    gFooterLab <- "Clique na pilha para escolher e soltar um disco"

    gInstText1 <- "Você está prestes a iniciar um teste chamado 'Torre de Londres'.  Seu objetivo é mover a pilha de discos de sua configuração original para a configuração mostrada no alto da tela.  Você pode mover apenas um disco por vez, e você não pode mover um disco para uma pilha que não tem mais espaço (indicado pelo tamanho do retângulo cinza).  Para mover um disco, clique na pilha da qual você quer retirar um disco e ele ficará acima das pilhas.  Então, clique em outra pilha e o disco se moverá para essa pilha."
    gInstText2 <- " Você terá um limite de tempo para resolver cada problema.  Tente terminar cada problema dentro do tempo estabelecido."
    gInstText3 <- " Você terá apenas um número limitado de movimentos para resolver cada problema. Antes de fazer seu primeiro movimento, pense sobre o problema para ter certeza de que você pode resolvê-lo dentro do seu limite de movimentos.  Se você não terminar o problema dentro do limite, sua vez terminará e você irá para o próximo problema."
    gBegin <-  "Clique no mouse para começar."
    gContinue <- "Problema resolvido. "+CR(2)+ "Clique com o mouse para continuar para o próximo problema."
    gIncomplete <- "Problema não-resolvido. "
    gClickLab <- "Cliques"
    gTimeLab <-  "Tempo (s)"
    gMovesOutLab <-  "Você não conseguiu terminar o problema no número de movimentos necessários."
    gResetText   <- "Reiniciar o problema"
    gResetLab    <- "Você está começando o problema de novo."
    gTimeOutLab <-  "Você esgotou seu tempo."
    gDebriefing <- "Obrigado por participar. O teste está agora terminado.  Pressione qualquer tecla para sair."
    gContinueFail <- "Clique com o mouse para continuar para o próximo problema."
    } elseif(lang=="ES"){

     ## Note, this is not a proper Spanish translation.
     ##
    gSelect <- "Type number of test to use:"+ CR(2) +
     "[1] Unconstrained pile heights, {3,4,5} disks, progressive difficulty, 24 trials"+CR(2)+
     "[2] Unconstrained pile heights, {3,4,5} disks, Random presentation, 24 trials"+CR(2)+
     "[3] Shallice test ([1,2,3] pile heights, 3 disks, Shallice's 12 problems."+CR(2)+
     "[4] Shallice pile heights [1,2,3], 3 disks, 30  random trials."+CR(2)+
     "[5] Phillips (1999) trials A (unconstrained piles, 5 disks, progressive difficulty, 8 trials)"+CR(2)+
     "[6] Phillips (1999) trials B (unconstrained piles, 5 disks, progressive difficulty, 8 trials)"+CR(2)+
     "[7] Phillips (1999) trials C (unconstrained piles, 5 disks, progressive difficulty, 8 trials)"+CR(2)+
     "[8] Fimbel et al (2009) old: [1,2,3] pile heights, 3 disks, progressive difficulty, 15 trials)"+CR(2)+
     "[9] Fimbel et al (2009) young: [1,2,3] pile heights, 3 disks, progressive difficulty, 35 trials)"+CR(2)+
     "[0] TOL-R (Schnirman et al, 1998). [1,2,3] pile heights, 3 disks, 30 problems, time and move limit)"+CR(2)+
     "[a] TOL-DX (Culbertson & Zillmer, 1998). [1,2,3] pile heights, 3 discs, 15 problems)"+CR(3)+
     "Edit TOL.pbl directly to specify a test configuration automatically."

    gHeaderLab <- "Objetivo montóns:"
    gFooterLab <- "Haga clic en pila para recoger y llevar a disco"
    gInstText1 <- "Estás a punto de realizar una tarea llamada 'Torre de Su Londres'. Objetivo es pasar un montón de discos desde su configuración original a la configuración mostrada en la parte superior de la pantalla. Sólo puedes mover un disco a la vez, y no se puede mover un disco sobre un montón que no tiene más espacio (indicado por el tamaño del rectángulo gris). Para mover un disco, haga clic en el montón que desea mover un disco fuera de, y se moverá hacia arriba por encima de la pila. A continuación, haga clic en otra pila, y el disco se moverá hasta que el montón. "
    gInstText2 <- " Tendrá un límite de tiempo para terminar cada problema. Intento de terminar cada problema en el tiempo asignado."
    gInstText3 <- " Usted tendrá solamente un número limitado de movimientos para resolver cada problema. Antes de hacer su primer movimiento, pensar en el problema para asegurarse de que puede resolver dentro de su límite de movimiento. Si no termina el problema en el límite, el a su vez terminará y se trasladará al siguiente problema."
    gBegin <-  "Haga clic en el ratón para empezar."
    gContinue <- "Prueba Completa. "+ CR(1) +" Haga clic en el ratón para continuar a la siguiente prueba. "
    gIncomplete <- "Prueba Incompleta. "
    gClickLab <- "Clics"
    gTimeLab <-  "Tiempo (s)"
    gMovesOutLab <-  "Usted no pudo completar el problema del número de movimientos necesarios."
    gResetText   <- "Reset problem"
    gResetLab    <- "You are starting the problem again."
    gTimeOutLab <-  "Usted acabó el tiempo."
    gDebriefing <- "Gracias por participar. El experimento ya está completa. Pulse cualquier tecla para salir."
    gContinueFail <- " Haga clic en el ratón para continuar a la siguiente prueba. "

    } elseif(Uppercase(lang) == "PL") 
     {

    gSelect <- "Type number of test to use:"+ CR(2) +
     "[1] Unconstrained pile heights, {3,4,5} disks, progressive difficulty, 24 trials"+CR(2)+
     "[2] Unconstrained pile heights, {3,4,5} disks, Random presentation, 24 trials"+CR(2)+
     "[3] Shallice test ([1,2,3] pile heights, 3 disks, Shallice's 12 problems."+CR(2)+
     "[4] Shallice pile heights [1,2,3], 3 disks, 30  random trials."+CR(2)+
     "[5] Phillips (1999) trials A (unconstrained piles, 5 disks, progressive difficulty, 8 trials)"+CR(2)+
     "[6] Phillips (1999) trials B (unconstrained piles, 5 disks, progressive difficulty, 8 trials)"+CR(2)+
     "[7] Phillips (1999) trials C (unconstrained piles, 5 disks, progressive difficulty, 8 trials)"+CR(2)+
     "[8] Fimbel et al (2009) old: [1,2,3] pile heights, 3 disks, progressive difficulty, 15 trials)"+CR(2)+
     "[9] Fimbel et al (2009) young: [1,2,3] pile heights, 3 disks, progressive difficulty, 35 trials)"+CR(2)+
     "[0] TOL-R (Schnirman et al, 1998). [1,2,3] pile heights, 3 disks, 30 problems, time and move limit)"+CR(2)+
     "[a] TOL-DX (Culbertson & Zillmer, 1998). [1,2,3] pile heights, 3 discs, 15 problems)"+CR(3)+
     "Edit TOL.pbl directly to specify a test configuration automatically."

    gHeaderLab <- "Target"+CR(1)+"Stacks:"
    gFooterLab <- "Proszę kliknąć na stercie aby podnieść i upuścić dysk"

    gInstText1 <- "Za chwilę weźmie Pani/Pan udział w zadaniu 'Tower of London'.  Celem będzie przeniesienie sterty dysków z oryginalnej konfiguracji tak,aby uzyskać konfigurację ukazaną na górze ekranu.  Może Pani/Pan podnieść jeden dysk jednocześnie i nie można przenieść dysku na stertę, gdzie nie ma już miejsca (co będzie wskazywane przez wielkość szarego prostokąta).By przemieścić dysk, proszę kliknąć na stertę, z której należy zabrać dysk, zostanie wtedy podniesiony ponad stertę. Następnie proszę kliknąć na kolejną stertę, wtedy dysk zostanie ułożony na niej. Proszę poinformować mnie o zakończeniu zadania."
    gInstText2 <- " Będziesz mieć limit czasu, aby zakończyć każdy problem. Spróbuj zakończyć każdy problem w wyznaczonym czasie."
    gInstText3 <- " Będziesz mieć ograniczoną liczbę ruchów do rozwiązania każdego problemu. Zanim podejmiesz pierwszy krok, pomyśl o problemie, aby upewnić się, że można go rozwiązać w ramach limitu ruchów. Jeśli nie zakończysz problemu w ramach limitu, etap zakończy się i przejdziesz do następnego problemu."
    gBegin <-  " Proszę kliknąć myszką, aby rozpocząć."
    gContinue <- "Problem rozwiązany. "+CR(2)+ " Proszę kliknąć myszką, aby przejść do kolejnego problemu."
    gIncomplete <- "Problem nierozwiązany. "
    gClickLab <- "Liczba ruchów"
    gTimeLab <-  "Czas (s)"
    gMovesOutLab <-  "Nie udało się zakończyć problemu w liczbie ruchów wymaganych."
    gResetText   <- "Zresetuj problem"
    gResetLab    <- "Click screen to restart problem."
    gTimeOutLab <-  "Przekroczyłeś limit czasu."
    gDebriefing <- "Dziękuję za udział w badaniu. Eksperyment jest już skończony. Proszę nacisnąć dowolny klawisz, aby zakończyć."
    gContinueFail <- "Proszę kliknąć na ekranie aby przejść do kolejnego problemu."

 } elseif(Uppercase(lang) == "HR") 
     { 
        ##Courtesy Silvaja Rucevic

gSelect <- "Type number of test to use:"+ CR(2) +
     "[1] Unconstrained pile heights, {3,4,5} disks, progressive difficulty, 24 trials"+CR(2)+
     "[2] Unconstrained pile heights, {3,4,5} disks, Random presentation, 24 trials"+CR(2)+
     "[3] Shallice test ([1,2,3] pile heights, 3 disks, Shallice's 12 problems."+CR(2)+
     "[4] Shallice pile heights [1,2,3], 3 disks, 30  random trials."+CR(2)+
     "[5] Phillips (1999) trials A (unconstrained piles, 5 disks, progressive difficulty, 8 trials)"+CR(2)+
     "[6] Phillips (1999) trials B (unconstrained piles, 5 disks, progressive difficulty, 8 trials)"+CR(2)+
     "[7] Phillips (1999) trials C (unconstrained piles, 5 disks, progressive difficulty, 8 trials)"+CR(2)+
     "[8] Fimbel et al (2009) old: [1,2,3] pile heights, 3 disks, progressive difficulty, 15 trials)"+CR(2)+
     "[9] Fimbel et al (2009) young: [1,2,3] pile heights, 3 disks, progressive difficulty, 35 trials)"+CR(2)+
     "[0] TOL-R (Schnirman et al, 1998). [1,2,3] pile heights, 3 disks, 30 problems, time and move limit)"+CR(2)+
     "[a] TOL-DX (Culbertson & Zillmer, 1998). [1,2,3] pile heights, 3 discs, 15 problems)"+CR(3)+
     "Edit TOL.pbl directly to specify a test configuration automatically."

    gHeaderLab <- "Ciljana"+CR(1)+"hrpa:"
    gFooterLab <- "Pritisni na hrpu i pusti disk"

    gInstText1 <- "Upravo cete sudjelovati u zadatku koji se zove Londonski toranj. Vas zadatak je da slozite diskove onako kako su prikazani na gornjem dijelu ekrana. Mozete pomicati disk po disk, ali ne mozete pomakntui disk na hrpu na kojoj vise nema mjesta (oznaceno velicinom sivog pravokutnika). Da bi ste pomakli disk kliknite na hrpu s kojeg ga zelite pomaknuti, nakon cega ce se disk pojaviti u ruci. Nakon toga, kliknite na hrpu na koju zelite staviti disk i on ce se spustiti na nju."
    gInstText2 <- " Imat cete ograniceno vrijeme da biste zavrsili svaki zadatak.  Pokusajte zavrsiti zadatak unutar zadanog vremena."
    gInstText3 <- " Imat cete ogranicen broj poteza da rijesite svaki zadatak. Prije prvog poteza razmislite o svakom zadatku kako biste bili sigurni da ga mozete rijesiti unutar zadanog broja poteza. Ukoliko ne zavrsite zadatak unutar ogranicenja on ce zavrsiti, a vi cete dobiti novi zadatak."
    gBegin <-  "Pritisnite lijevo dugme misa za pocetak."
    gContinue <- "Zavrsen pokusaj. "+CR(2)+ "Pritisnite misa da biste zapoceli novi zadatak."
    gIncomplete <- "Nezavrsen zadatak. "
    gClickLab <- "Broj poteza"
    gTimeLab <-  "Vrijeme"
    gMovesOutLab <-  "Niste uspjeli rijesiti zadatak u zadanom broju poteza."
    gResetText   <- "Resetiraj zadatak"
    gResetLab    <- "Kliknite na ekran da biste ponovili zadatak."
    gTimeOutLab <-  "Isteklo vam je vrijeme."
    gDebriefing <- "Hvala vam na sudjelovanju. Zadaci su gotovi.  Pritisnite bilo koju tipku za izlazak."
    gContinueFail <- "Kliknite na ekran da biste zapoceli s novim zadatkom."
    } else{
     Print("Language: ["+lang+"] unknown.  Falling back on English translations.")
     GetStrings("en")
   }
}
